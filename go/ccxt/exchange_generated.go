package ccxt
// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

func  (this *Exchange) safeBoolN(dictionaryOrList interface{}, keys interface{}, defaultValue bool)  {
    /**
     * @ignore
     * @method
     * @description safely extract boolean value from dictionary or list
     * @returns {bool | undefined}
     */
    return defaultValue
}
func  (this *Exchange) safeBool2(dictionary interface{}, key1 interface{}, key2 interface{}, defaultValue bool)  {
    /**
     * @ignore
     * @method
     * @description safely extract boolean value from dictionary or list
     * @returns {bool | undefined}
     */
    return this.safeBoolN(dictionary, []interface{}{key1, key2}, defaultValue)
}
func  (this *Exchange) safeBool(dictionary interface{}, key interface{}, defaultValue bool)  {
    /**
     * @ignore
     * @method
     * @description safely extract boolean value from dictionary or list
     * @returns {bool | undefined}
     */
    return this.safeBoolN(dictionary, []interface{}{key}, defaultValue)
}
func  (this *Exchange) safeDictN(dictionaryOrList interface{}, keys interface{}, defaultValue interface{})  {
    /**
     * @ignore
     * @method
     * @description safely extract a dictionary from dictionary or list
     * @returns {object | undefined}
     */
    value := this.safeValueN(dictionaryOrList, keys, defaultValue)
    if IsTrue(IsEqual(value, null)) {
        return defaultValue
    }
    if IsTrue((value is IDictionary<string, object>)) {
        return value
    }
    return defaultValue
}
func  (this *Exchange) safeDict(dictionary interface{}, key interface{}, defaultValue interface{})  {
    /**
     * @ignore
     * @method
     * @description safely extract a dictionary from dictionary or list
     * @returns {object | undefined}
     */
    return this.safeDictN(dictionary, []interface{}{key}, defaultValue)
}
func  (this *Exchange) safeDict2(dictionary interface{}, key1 interface{}, key2 string, defaultValue interface{})  {
    /**
     * @ignore
     * @method
     * @description safely extract a dictionary from dictionary or list
     * @returns {object | undefined}
     */
    return this.safeDictN(dictionary, []interface{}{key1, key2}, defaultValue)
}
func  (this *Exchange) safeListN(dictionaryOrList interface{}, keys interface{}, defaultValue interface{})  {
    /**
     * @ignore
     * @method
     * @description safely extract an Array from dictionary or list
     * @returns {Array | undefined}
     */
    value := this.safeValueN(dictionaryOrList, keys, defaultValue)
    if IsTrue(helpers.IsEqual(value, null)) {
        return defaultValue
    }
    if IsTrue(((value is IList<object>) || (value.GetType().IsGenericType && value.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))) {
        return value
    }
    return defaultValue
}
func  (this *Exchange) safeList2(dictionaryOrList interface{}, key1 interface{}, key2 string, defaultValue interface{})  {
    /**
     * @ignore
     * @method
     * @description safely extract an Array from dictionary or list
     * @returns {Array | undefined}
     */
    return this.safeListN(dictionaryOrList, []interface{}{key1, key2}, defaultValue)
}
func  (this *Exchange) safeList(dictionaryOrList interface{}, key interface{}, defaultValue interface{})  {
    /**
     * @ignore
     * @method
     * @description safely extract an Array from dictionary or list
     * @returns {Array | undefined}
     */
    return this.safeListN(dictionaryOrList, []interface{}{key}, defaultValue)
}
func  (this *Exchange) handleDeltas(orderbook interface{}, deltas interface{})  {
    for i := 0; IsLessThan(i, GetArrayLength(deltas)); i++ {
        this.handleDelta(orderbook, deltas[i])
    }
}
func  (this *Exchange) handleDelta(bookside interface{}, delta interface{})  {
    throw new NotSupported ((string)Add(this.id, " handleDelta not supported yet")) 
}
func  (this *Exchange) getCacheIndex(orderbook interface{}, deltas interface{})  {
    // return the first index of the cache that can be applied to the orderbook or -1 if not possible
    return -1
}
func  (this *Exchange) findTimeframe(timeframe interface{}, timeframes interface{})  {
    if IsTrue(IsEqual(timeframes, null)) {
        timeframes = this.timeframes
    }
    keys := new List<object>(((IDictionary<string,object>)timeframes).Keys)
    for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
        key := keys[i]
        if IsTrue(helpers.IsEqual(timeframes[key], timeframe)) {
            return key
        }
    }
    return null
}
func  (this *Exchange) checkProxyUrlSettings(url interface{}, method interface{}, headers interface{}, body interface{})  {
    usedProxies := []interface{}{}
    proxyUrl := null
    if IsTrue(!IsEqual(this.proxyUrl, null)) {
        usedProxies = appendToArray(usedProxies,"proxyUrl").([]interface{})
        proxyUrl = this.proxyUrl
    }
    if IsTrue(!IsEqual(this.proxy_url, null)) {
        usedProxies = appendToArray(usedProxies,"proxy_url").([]interface{})
        proxyUrl = this.proxy_url
    }
    if IsTrue(!IsEqual(this.proxyUrlCallback, null)) {
        usedProxies = appendToArray(usedProxies,"proxyUrlCallback").([]interface{})
        proxyUrl = callDynamically(this, "proxyUrlCallback", new object[] { url, method, headers, body })
    }
    if IsTrue(!IsEqual(this.proxy_url_callback, null)) {
        usedProxies = appendToArray(usedProxies,"proxy_url_callback").([]interface{})
        proxyUrl = callDynamically(this, "proxy_url_callback", new object[] { url, method, headers, body })
    }
    // backwards-compatibility
    if IsTrue(!IsEqual(this.proxy, null)) {
        usedProxies = appendToArray(usedProxies,"proxy").([]interface{})
        if IsTrue((this.proxy is Delegate)) {
            proxyUrl = callDynamically(this, "proxy", new object[] { url, method, headers, body })
        } else {
            proxyUrl = this.proxy
        }
    }
    length := GetArrayLength(usedProxies)
    if IsTrue(IsGreaterThan(length, 1)) {
        joinedProxyNames := String.Join(",", ((IList<object>)usedProxies).ToArray())
        throw new ProxyError ((string)Add(Add(Add(this.id, " you have multiple conflicting proxy settings ("), joinedProxyNames), "), please use only one from : proxyUrl, proxy_url, proxyUrlCallback, proxy_url_callback")) 
    }
    return proxyUrl
}
func  (this *Exchange) checkProxySettings(url interface{}, method interface{}, headers interface{}, body interface{})  {
    usedProxies := []interface{}{}
    httpProxy := null
    httpsProxy := null
    socksProxy := null
    // httpProxy
    if IsTrue(this.valueIsDefined(this.httpProxy)) {
        usedProxies = appendToArray(usedProxies,"httpProxy").([]interface{})
        httpProxy = this.httpProxy
    }
    if IsTrue(this.valueIsDefined(this.http_proxy)) {
        usedProxies = appendToArray(usedProxies,"http_proxy").([]interface{})
        httpProxy = this.http_proxy
    }
    if IsTrue(!IsEqual(this.httpProxyCallback, null)) {
        usedProxies = appendToArray(usedProxies,"httpProxyCallback").([]interface{})
        httpProxy = callDynamically(this, "httpProxyCallback", new object[] { url, method, headers, body })
    }
    if IsTrue(!IsEqual(this.http_proxy_callback, null)) {
        usedProxies = appendToArray(usedProxies,"http_proxy_callback").([]interface{})
        httpProxy = callDynamically(this, "http_proxy_callback", new object[] { url, method, headers, body })
    }
    // httpsProxy
    if IsTrue(this.valueIsDefined(this.httpsProxy)) {
        usedProxies = appendToArray(usedProxies,"httpsProxy").([]interface{})
        httpsProxy = this.httpsProxy
    }
    if IsTrue(this.valueIsDefined(this.https_proxy)) {
        usedProxies = appendToArray(usedProxies,"https_proxy").([]interface{})
        httpsProxy = this.https_proxy
    }
    if IsTrue(!IsEqual(this.httpsProxyCallback, null)) {
        usedProxies = appendToArray(usedProxies,"httpsProxyCallback").([]interface{})
        httpsProxy = callDynamically(this, "httpsProxyCallback", new object[] { url, method, headers, body })
    }
    if IsTrue(!IsEqual(this.https_proxy_callback, null)) {
        usedProxies = appendToArray(usedProxies,"https_proxy_callback").([]interface{})
        httpsProxy = callDynamically(this, "https_proxy_callback", new object[] { url, method, headers, body })
    }
    // socksProxy
    if IsTrue(this.valueIsDefined(this.socksProxy)) {
        usedProxies = appendToArray(usedProxies,"socksProxy").([]interface{})
        socksProxy = this.socksProxy
    }
    if IsTrue(this.valueIsDefined(this.socks_proxy)) {
        usedProxies = appendToArray(usedProxies,"socks_proxy").([]interface{})
        socksProxy = this.socks_proxy
    }
    if IsTrue(!IsEqual(this.socksProxyCallback, null)) {
        usedProxies = appendToArray(usedProxies,"socksProxyCallback").([]interface{})
        socksProxy = callDynamically(this, "socksProxyCallback", new object[] { url, method, headers, body })
    }
    if IsTrue(!IsEqual(this.socks_proxy_callback, null)) {
        usedProxies = appendToArray(usedProxies,"socks_proxy_callback").([]interface{})
        socksProxy = callDynamically(this, "socks_proxy_callback", new object[] { url, method, headers, body })
    }
    // check
    length := GetArrayLength(usedProxies)
    if IsTrue(IsGreaterThan(length, 1)) {
        joinedProxyNames := String.Join(",", ((IList<object>)usedProxies).ToArray())
        throw new ProxyError ((string)Add(Add(Add(this.id, " you have multiple conflicting proxy settings ("), joinedProxyNames), "), please use only one from: httpProxy, httpsProxy, httpProxyCallback, httpsProxyCallback, socksProxy, socksProxyCallback")) 
    }
    return []interface{}{httpProxy, httpsProxy, socksProxy}
}
func  (this *Exchange) checkWsProxySettings()  {
    usedProxies := []interface{}{}
    wsProxy := null
    wssProxy := null
    wsSocksProxy := null
    // ws proxy
    if IsTrue(this.valueIsDefined(this.wsProxy)) {
        usedProxies = appendToArray(usedProxies,"wsProxy").([]interface{})
        wsProxy = this.wsProxy
    }
    if IsTrue(this.valueIsDefined(this.ws_proxy)) {
        usedProxies = appendToArray(usedProxies,"ws_proxy").([]interface{})
        wsProxy = this.ws_proxy
    }
    // wss proxy
    if IsTrue(this.valueIsDefined(this.wssProxy)) {
        usedProxies = appendToArray(usedProxies,"wssProxy").([]interface{})
        wssProxy = this.wssProxy
    }
    if IsTrue(this.valueIsDefined(this.wss_proxy)) {
        usedProxies = appendToArray(usedProxies,"wss_proxy").([]interface{})
        wssProxy = this.wss_proxy
    }
    // ws socks proxy
    if IsTrue(this.valueIsDefined(this.wsSocksProxy)) {
        usedProxies = appendToArray(usedProxies,"wsSocksProxy").([]interface{})
        wsSocksProxy = this.wsSocksProxy
    }
    if IsTrue(this.valueIsDefined(this.ws_socks_proxy)) {
        usedProxies = appendToArray(usedProxies,"ws_socks_proxy").([]interface{})
        wsSocksProxy = this.ws_socks_proxy
    }
    // check
    length := GetArrayLength(usedProxies)
    if IsTrue(IsGreaterThan(length, 1)) {
        joinedProxyNames := String.Join(",", ((IList<object>)usedProxies).ToArray())
        throw new ProxyError ((string)Add(Add(Add(this.id, " you have multiple conflicting proxy settings ("), joinedProxyNames), "), please use only one from: wsProxy, wssProxy, wsSocksProxy")) 
    }
    return []interface{}{wsProxy, wssProxy, wsSocksProxy}
}
func  (this *Exchange) checkConflictingProxies(proxyAgentSet interface{}, proxyUrlSet interface{})  {
    if IsTrue(IsTrue(proxyAgentSet) && IsTrue(proxyUrlSet)) {
        throw new ProxyError ((string)Add(this.id, " you have multiple conflicting proxy settings, please use only one from : proxyUrl, httpProxy, httpsProxy, socksProxy")) 
    }
}
func  (this *Exchange) findMessageHashes(client interface{}, element string)  {
    result := []interface{}{}
    messageHashes := new List<object>(((IDictionary<string,object>)client.futures).Keys)
    for i := 0; IsLessThan(i, GetArrayLength(messageHashes)); i++ {
        messageHash := messageHashes[i]
        if IsTrue(IsGreaterThanOrEqual(GetIndexOf(messageHash, element), 0)) {
            result = appendToArray(result,messageHash).([]interface{})
        }
    }
    return result
}
func  (this *Exchange) filterByLimit(array interface{}, limit interface{}, key interface{}, fromStart bool)  {
    if IsTrue(this.valueIsDefined(limit)) {
        arrayLength := GetArrayLength(array)
        if IsTrue(IsGreaterThan(arrayLength, 0)) {
            ascending := true
            if IsTrue((inOp(array[0], key))) {
                first := array[0][key]
                last := array[Subtract(arrayLength, 1)][key]
                if IsTrue(IsTrue(!IsEqual(first, null)) && IsTrue(!IsEqual(last, null))) {
                    ascending = IsLessThanOrEqual(first, last) // true if array is sorted in ascending order based on 'timestamp'
                }
            }
            if IsTrue(fromStart) {
                if IsTrue(IsGreaterThan(limit, arrayLength)) {
                    limit = arrayLength
                }
                array = ((bool) IsTrue(ascending)) ? this.arraySlice(array, 0, limit) : this.arraySlice(array, -limit)
            } else {
                array = ((bool) IsTrue(ascending)) ? this.arraySlice(array, -limit) : this.arraySlice(array, 0, limit)
            }
        }
    }
    return array
}
func  (this *Exchange) filterBySinceLimit(array interface{}, since interface{}, limit interface{}, key interface{}, tail bool)  {
    sinceIsDefined := this.valueIsDefined(since)
    parsedArray := ((object)this.toArray(array))
    result := parsedArray
    if IsTrue(sinceIsDefined) {
        result = []interface{}{}
        for i := 0; IsLessThan(i, GetArrayLength(parsedArray)); i++ {
            entry := parsedArray[i]
            value := this.safeValue(entry, key)
            if IsTrue(IsTrue(value) && IsTrue((IsGreaterThanOrEqual(value, since)))) {
                result = appendToArray(result,entry).([]interface{})
            }
        }
    }
    if IsTrue(IsTrue(tail) && IsTrue(!IsEqual(limit, null))) {
        return this.arraySlice(result, -limit)
    }
    // if the user provided a 'since' argument
    // we want to limit the result starting from the 'since'
    shouldFilterFromStart := !IsTrue(tail) && IsTrue(sinceIsDefined)
    return this.filterByLimit(result, limit, key, shouldFilterFromStart)
}
func  (this *Exchange) filterByValueSinceLimit(array interface{}, field interface{}, value interface{}, since interface{}, limit interface{}, key string, tail bool)  {
    valueIsDefined := this.valueIsDefined(value)
    sinceIsDefined := this.valueIsDefined(since)
    parsedArray := ((object)this.toArray(array))
    result := parsedArray
    // single-pass filter for both symbol and since
    if IsTrue(IsTrue(valueIsDefined) || IsTrue(sinceIsDefined)) {
        result = []interface{}{}
        for i := 0; IsLessThan(i, GetArrayLength(parsedArray)); i++ {
            entry := parsedArray[i]
            entryFiledEqualValue := IsEqual(entry[field], value)
            firstCondition := ((bool) IsTrue(valueIsDefined)) ? entryFiledEqualValue : true
            entryKeyValue := this.safeValue(entry, key)
            entryKeyGESince := IsTrue(IsTrue((entryKeyValue)) && IsTrue(since)) && IsTrue((IsGreaterThanOrEqual(entryKeyValue, since)))
            secondCondition := ((bool) IsTrue(sinceIsDefined)) ? entryKeyGESince : true
            if IsTrue(IsTrue(firstCondition) && IsTrue(secondCondition)) {
                result = appendToArray(result,entry).([]interface{})
            }
        }
    }
    if IsTrue(IsTrue(tail) && IsTrue(!IsEqual(limit, null))) {
        return this.arraySlice(result, -limit)
    }
    return this.filterByLimit(result, limit, key, sinceIsDefined)
}
func  (this *Exchange) setSandboxMode(enabled bool)  {
    if IsTrue(enabled) {
        if IsTrue(inOp(this.urls, "test")) {
            if IsTrue((this.urls["api"] is string)) {
                addElementToObject(this.urls, "apiBackup", this.urls["api"])
                addElementToObject(this.urls, "api", this.urls["test"])
            } else {
                addElementToObject(this.urls, "apiBackup", this.clone(this.urls["api"]))
                addElementToObject(this.urls, "api", this.clone(this.urls["test"]))
            }
        } else {
            throw new NotSupported ((string)Add(this.id, " does not have a sandbox URL")) 
        }
    } else if IsTrue(inOp(this.urls, "apiBackup")) {
        if IsTrue((this.urls["api"] is string)) {
            addElementToObject(this.urls, "api", ((object)this.urls["apiBackup"]))
        } else {
            addElementToObject(this.urls, "api", this.clone(this.urls["apiBackup"]))
        }
        newUrls := this.omit(this.urls, "apiBackup")
        this.urls = newUrls
    }
}
func  (this *Exchange) sign(path interface{}, api string, method string, parameters interface{}, headers interface{}, body interface{})  {
    return make(map[string]interface{}) {}
}
func  (this *Exchange) fetchAccounts(parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchAccounts() is not supported yet")) 
}
func  (this *Exchange) fetchTrades(symbol string, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchTrades() is not supported yet")) 
}
func  (this *Exchange) fetchTradesWs(symbol string, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchTradesWs() is not supported yet")) 
}
func  (this *Exchange) watchLiquidations(symbol string, since interface{}, limit interface{}, parameters interface{})  {
    if IsTrue(this.has["watchLiquidationsForSymbols"]) {
        return this.watchLiquidationsForSymbols([]interface{}{symbol}, since, limit, parameters)
    }
    throw new NotSupported ((string)Add(this.id, " watchLiquidations() is not supported yet")) 
}
func  (this *Exchange) watchLiquidationsForSymbols(symbols interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " watchLiquidationsForSymbols() is not supported yet")) 
}
func  (this *Exchange) watchMyLiquidations(symbol string, since interface{}, limit interface{}, parameters interface{})  {
    if IsTrue(this.has["watchMyLiquidationsForSymbols"]) {
        return this.watchMyLiquidationsForSymbols([]interface{}{symbol}, since, limit, parameters)
    }
    throw new NotSupported ((string)Add(this.id, " watchMyLiquidations() is not supported yet")) 
}
func  (this *Exchange) watchMyLiquidationsForSymbols(symbols interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " watchMyLiquidationsForSymbols() is not supported yet")) 
}
func  (this *Exchange) watchTrades(symbol string, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " watchTrades() is not supported yet")) 
}
func  (this *Exchange) watchTradesForSymbols(symbols interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " watchTradesForSymbols() is not supported yet")) 
}
func  (this *Exchange) watchMyTradesForSymbols(symbols interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " watchMyTradesForSymbols() is not supported yet")) 
}
func  (this *Exchange) watchOrdersForSymbols(symbols interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " watchOrdersForSymbols() is not supported yet")) 
}
func  (this *Exchange) watchOHLCVForSymbols(symbolsAndTimeframes interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " watchOHLCVForSymbols() is not supported yet")) 
}
func  (this *Exchange) watchOrderBookForSymbols(symbols interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " watchOrderBookForSymbols() is not supported yet")) 
}
func  (this *Exchange) fetchDepositAddresses(codes interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchDepositAddresses() is not supported yet")) 
}
func  (this *Exchange) fetchOrderBook(symbol string, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchOrderBook() is not supported yet")) 
}
func  (this *Exchange) fetchMarginMode(symbol string, parameters interface{})  {
    if IsTrue(this.has["fetchMarginModes"]) {
        marginModes := await this.fetchMarginModes([]interface{}{symbol}, parameters)
        return this.safeDict(marginModes, symbol)
    } else {
        throw new NotSupported ((string)Add(this.id, " fetchMarginMode() is not supported yet")) 
    }
}
func  (this *Exchange) fetchMarginModes(symbols interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchMarginModes () is not supported yet")) 
}
func  (this *Exchange) fetchRestOrderBookSafe(symbol interface{}, limit interface{}, parameters interface{})  {
    fetchSnapshotMaxRetries := this.handleOption("watchOrderBook", "maxRetries", 3)
    for i := 0; IsLessThan(i, fetchSnapshotMaxRetries); i++ {
        try {
            orderBook := await this.fetchOrderBook(symbol, limit, parameters)
            return orderBook
        } catch Exception e {
            if IsTrue(IsEqual((Add(i, 1)), fetchSnapshotMaxRetries)) {
                throw e
            }
        }
    }
    return null
}
func  (this *Exchange) watchOrderBook(symbol string, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " watchOrderBook() is not supported yet")) 
}
func  (this *Exchange) fetchTime(parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchTime() is not supported yet")) 
}
func  (this *Exchange) fetchTradingLimits(symbols interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchTradingLimits() is not supported yet")) 
}
func  (this *Exchange) parseMarket(market interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseMarket() is not supported yet")) 
}
func  (this *Exchange) parseMarkets(markets interface{})  {
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
        result = appendToArray(result,this.parseMarket(markets[i])).([]interface{})
    }
    return result
}
func  (this *Exchange) parseTicker(ticker interface{}, market interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseTicker() is not supported yet")) 
}
func  (this *Exchange) parseDepositAddress(depositAddress interface{}, currency interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseDepositAddress() is not supported yet")) 
}
func  (this *Exchange) parseTrade(trade interface{}, market interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseTrade() is not supported yet")) 
}
func  (this *Exchange) parseTransaction(transaction interface{}, currency interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseTransaction() is not supported yet")) 
}
func  (this *Exchange) parseTransfer(transfer interface{}, currency interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseTransfer() is not supported yet")) 
}
func  (this *Exchange) parseAccount(account interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseAccount() is not supported yet")) 
}
func  (this *Exchange) parseLedgerEntry(item interface{}, currency interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseLedgerEntry() is not supported yet")) 
}
func  (this *Exchange) parseOrder(order interface{}, market interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseOrder() is not supported yet")) 
}
func  (this *Exchange) fetchCrossBorrowRates(parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchCrossBorrowRates() is not supported yet")) 
}
func  (this *Exchange) fetchIsolatedBorrowRates(parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchIsolatedBorrowRates() is not supported yet")) 
}
func  (this *Exchange) parseMarketLeverageTiers(info interface{}, market interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseMarketLeverageTiers() is not supported yet")) 
}
func  (this *Exchange) fetchLeverageTiers(symbols interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchLeverageTiers() is not supported yet")) 
}
func  (this *Exchange) parsePosition(position interface{}, market interface{})  {
    throw new NotSupported ((string)Add(this.id, " parsePosition() is not supported yet")) 
}
func  (this *Exchange) parseFundingRateHistory(info interface{}, market interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseFundingRateHistory() is not supported yet")) 
}
func  (this *Exchange) parseBorrowInterest(info interface{}, market interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseBorrowInterest() is not supported yet")) 
}
func  (this *Exchange) parseIsolatedBorrowRate(info interface{}, market interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseIsolatedBorrowRate() is not supported yet")) 
}
func  (this *Exchange) parseWsTrade(trade interface{}, market interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseWsTrade() is not supported yet")) 
}
func  (this *Exchange) parseWsOrder(order interface{}, market interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseWsOrder() is not supported yet")) 
}
func  (this *Exchange) parseWsOrderTrade(trade interface{}, market interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseWsOrderTrade() is not supported yet")) 
}
func  (this *Exchange) parseWsOHLCV(ohlcv interface{}, market interface{})  {
    return this.parseOHLCV(ohlcv, market)
}
func  (this *Exchange) fetchFundingRates(symbols interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchFundingRates() is not supported yet")) 
}
func  (this *Exchange) watchFundingRate(symbol string, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " watchFundingRate() is not supported yet")) 
}
func  (this *Exchange) watchFundingRates(symbols interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " watchFundingRates() is not supported yet")) 
}
func  (this *Exchange) watchFundingRatesForSymbols(symbols interface{}, parameters interface{})  {
    return await this.watchFundingRates(symbols, parameters)
}
func  (this *Exchange) transfer(code string, amount interface{}, fromAccount string, toAccount string, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " transfer() is not supported yet")) 
}
func  (this *Exchange) withdraw(code string, amount interface{}, address string, tag interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " withdraw() is not supported yet")) 
}
func  (this *Exchange) createDepositAddress(code string, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " createDepositAddress() is not supported yet")) 
}
func  (this *Exchange) setLeverage(leverage interface{}, symbol interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " setLeverage() is not supported yet")) 
}
func  (this *Exchange) fetchLeverage(symbol string, parameters interface{})  {
    if IsTrue(this.has["fetchLeverages"]) {
        leverages := await this.fetchLeverages([]interface{}{symbol}, parameters)
        return this.safeDict(leverages, symbol)
    } else {
        throw new NotSupported ((string)Add(this.id, " fetchLeverage() is not supported yet")) 
    }
}
func  (this *Exchange) fetchLeverages(symbols interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchLeverages() is not supported yet")) 
}
func  (this *Exchange) setPositionMode(hedged bool, symbol interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " setPositionMode() is not supported yet")) 
}
func  (this *Exchange) addMargin(symbol string, amount interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " addMargin() is not supported yet")) 
}
func  (this *Exchange) reduceMargin(symbol string, amount interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " reduceMargin() is not supported yet")) 
}
func  (this *Exchange) setMargin(symbol string, amount interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " setMargin() is not supported yet")) 
}
func  (this *Exchange) fetchMarginAdjustmentHistory(symbol interface{}, type interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchMarginAdjustmentHistory() is not supported yet")) 
}
func  (this *Exchange) setMarginMode(marginMode string, symbol interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " setMarginMode() is not supported yet")) 
}
func  (this *Exchange) fetchDepositAddressesByNetwork(code string, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchDepositAddressesByNetwork() is not supported yet")) 
}
func  (this *Exchange) fetchOpenInterestHistory(symbol string, timeframe string, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchOpenInterestHistory() is not supported yet")) 
}
func  (this *Exchange) fetchOpenInterest(symbol string, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchOpenInterest() is not supported yet")) 
}
func  (this *Exchange) signIn(parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " signIn() is not supported yet")) 
}
func  (this *Exchange) fetchPaymentMethods(parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchPaymentMethods() is not supported yet")) 
}
func  (this *Exchange) parseToInt(number interface{})  {
    // Solve Common parseInt misuse ex: parseInt ((since / 1000).toString ())
    // using a number as parameter which is not valid in ts
    stringifiedNumber := this.numberToString(number)
    convertedNumber := ((object)parseFloat(stringifiedNumber))
    return parseInt(convertedNumber)
}
func  (this *Exchange) parseToNumeric(number interface{})  {
    stringVersion := this.numberToString(number) // this will convert 1.0 and 1 to "1" and 1.1 to "1.1"
    // keep this in mind:
    // in JS: 1 == 1.0 is true;  1 === 1.0 is true
    // in Python: 1 == 1.0 is true
    // in PHP 1 == 1.0 is true, but 1 === 1.0 is false
    if IsTrue(IsGreaterThanOrEqual(GetIndexOf(stringVersion, "."), 0)) {
        return parseFloat(stringVersion)
    }
    return parseInt(stringVersion)
}
func  (this *Exchange) isRoundNumber(value interface{})  {
    // this method is similar to isInteger, but this is more loyal and does not check for types.
    // i.e. isRoundNumber(1.000) returns true, while isInteger(1.000) returns false
    res := this.parseToNumeric((Mod(value, 1)))
    return IsEqual(res, 0)
}
func  (this *Exchange) safeIntegerOmitZero(obj interface{}, key interface{}, defaultValue interface{})  {
    timestamp := this.safeInteger(obj, key, defaultValue)
    if IsTrue(IsTrue(IsEqual(timestamp, null)) || IsTrue(IsEqual(timestamp, 0))) {
        return null
    }
    return timestamp
}
func  (this *Exchange) afterConstruct()  {
    this.createNetworksByIdObject()
}
func  (this *Exchange) createNetworksByIdObject()  {
    // automatically generate network-id-to-code mappings
    networkIdsToCodesGenerated := this.invertFlatStringDictionary(this.safeValue(this.options, "networks", make(map[string]interface{}) {})) // invert defined networks dictionary
    addElementToObject(this.options, "networksById", this.extend(networkIdsToCodesGenerated, this.safeValue(this.options, "networksById", make(map[string]interface{}) {}))) // support manually overriden "networksById" dictionary too
}
func  (this *Exchange) getDefaultOptions()  {
    return make(map[string]interface{}) {
        "defaultNetworkCodeReplacements", make(map[string]interface{}) {
            "ETH", make(map[string]interface{}) {
                "ERC20", "ETH",
            },
            "TRX", make(map[string]interface{}) {
                "TRC20", "TRX",
            },
            "CRO", make(map[string]interface{}) {
                "CRC20", "CRONOS",
            },
        },
    }
}
func  (this *Exchange) safeLedgerEntry(entry interface{}, currency interface{})  {
    currency = this.safeCurrency(null, currency)
    direction := this.safeString(entry, "direction")
    before := this.safeString(entry, "before")
    after := this.safeString(entry, "after")
    amount := this.safeString(entry, "amount")
    if IsTrue(!IsEqual(amount, null)) {
        if IsTrue(IsTrue(IsEqual(before, null)) && IsTrue(!IsEqual(after, null))) {
            before = Precise.stringSub(after, amount)
        } else if IsTrue(IsTrue(!IsEqual(before, null)) && IsTrue(IsEqual(after, null))) {
            after = Precise.stringAdd(before, amount)
        }
    }
    if IsTrue(IsTrue(!IsEqual(before, null)) && IsTrue(!IsEqual(after, null))) {
        if IsTrue(IsEqual(direction, null)) {
            if IsTrue(Precise.stringGt(before, after)) {
                direction = "out"
            }
            if IsTrue(Precise.stringGt(after, before)) {
                direction = "in"
            }
        }
    }
    fee := this.safeValue(entry, "fee")
    if IsTrue(!IsEqual(fee, null)) {
        addElementToObject(fee, "cost", this.safeNumber(fee, "cost"))
    }
    timestamp := this.safeInteger(entry, "timestamp")
    info := this.safeDict(entry, "info", make(map[string]interface{}) {})
    return make(map[string]interface{}) {
        "id", this.safeString(entry, "id"),
        "timestamp", timestamp,
        "datetime", this.iso8601(timestamp),
        "direction", direction,
        "account", this.safeString(entry, "account"),
        "referenceId", this.safeString(entry, "referenceId"),
        "referenceAccount", this.safeString(entry, "referenceAccount"),
        "type", this.safeString(entry, "type"),
        "currency", currency["code"],
        "amount", this.parseNumber(amount),
        "before", this.parseNumber(before),
        "after", this.parseNumber(after),
        "status", this.safeString(entry, "status"),
        "fee", fee,
        "info", info,
    }
}
func  (this *Exchange) safeCurrencyStructure(currency interface{})  {
    return this.extend(make(map[string]interface{}) {
        "info", null,
        "id", null,
        "numericId", null,
        "code", null,
        "precision", null,
        "type", null,
        "name", null,
        "active", null,
        "deposit", null,
        "withdraw", null,
        "fee", null,
        "fees", make(map[string]interface{}) {},
        "networks", make(map[string]interface{}) {},
        "limits", make(map[string]interface{}) {
            "deposit", make(map[string]interface{}) {
                "min", null,
                "max", null,
            },
            "withdraw", make(map[string]interface{}) {
                "min", null,
                "max", null,
            },
        },
    }, currency)
}
func  (this *Exchange) safeMarketStructure(market interface{})  {
    cleanStructure := make(map[string]interface{}) {
        "id", null,
        "lowercaseId", null,
        "symbol", null,
        "base", null,
        "quote", null,
        "settle", null,
        "baseId", null,
        "quoteId", null,
        "settleId", null,
        "type", null,
        "spot", null,
        "margin", null,
        "swap", null,
        "future", null,
        "option", null,
        "index", null,
        "active", null,
        "contract", null,
        "linear", null,
        "inverse", null,
        "subType", null,
        "taker", null,
        "maker", null,
        "contractSize", null,
        "expiry", null,
        "expiryDatetime", null,
        "strike", null,
        "optionType", null,
        "precision", make(map[string]interface{}) {
            "amount", null,
            "price", null,
            "cost", null,
            "base", null,
            "quote", null,
        },
        "limits", make(map[string]interface{}) {
            "leverage", make(map[string]interface{}) {
                "min", null,
                "max", null,
            },
            "amount", make(map[string]interface{}) {
                "min", null,
                "max", null,
            },
            "price", make(map[string]interface{}) {
                "min", null,
                "max", null,
            },
            "cost", make(map[string]interface{}) {
                "min", null,
                "max", null,
            },
        },
        "created", null,
        "info", null,
    }
    if IsTrue(!IsEqual(market, null)) {
        result := this.extend(cleanStructure, market)
        // set undefined swap/future/etc
        if IsTrue(result["spot"]) {
            if IsTrue(IsEqual(result["contract"], null)) {
                addElementToObject(result, "contract", false)
            }
            if IsTrue(IsEqual(result["swap"], null)) {
                addElementToObject(result, "swap", false)
            }
            if IsTrue(IsEqual(result["future"], null)) {
                addElementToObject(result, "future", false)
            }
            if IsTrue(IsEqual(result["option"], null)) {
                addElementToObject(result, "option", false)
            }
            if IsTrue(IsEqual(result["index"], null)) {
                addElementToObject(result, "index", false)
            }
        }
        return result
    }
    return cleanStructure
}
func  (this *Exchange) setMarkets(markets interface{}, currencies interface{})  {
    values := []interface{}{}
    this.markets_by_id = make(map[string]interface{}) {}
    // handle marketId conflicts
    // we insert spot markets first
    marketValues := this.sortBy(this.toArray(markets), "spot", true, true)
    for i := 0; IsLessThan(i, GetArrayLength(marketValues)); i++ {
        value := marketValues[i]
        if IsTrue(inOp(this.markets_by_id, value["id"])) {
            ((object)this.markets_by_id[value["id"]]) = appendToArray(((object)this.markets_by_id[value["id"]]),value).([]interface{})
        } else {
            addElementToObject(this.markets_by_id, value["id"], ((object)[]interface{}{value}))
        }
        market := this.deepExtend(this.safeMarketStructure(), make(map[string]interface{}) {
            "precision", this.precision,
            "limits", this.limits,
        }, this.fees["trading"], value)
        if IsTrue(market["linear"]) {
            addElementToObject(market, "subType", "linear")
        } else if IsTrue(market["inverse"]) {
            addElementToObject(market, "subType", "inverse")
        } else {
            addElementToObject(market, "subType", null)
        }
        values = appendToArray(values,market).([]interface{})
    }
    this.markets = ((object)this.indexBy(values, "symbol"))
    marketsSortedBySymbol := this.keysort(this.markets)
    marketsSortedById := this.keysort(this.markets_by_id)
    this.symbols = new List<object>(((IDictionary<string,object>)marketsSortedBySymbol).Keys)
    this.ids = new List<object>(((IDictionary<string,object>)marketsSortedById).Keys)
    if IsTrue(!IsEqual(currencies, null)) {
        // currencies is always undefined when called in constructor but not when called from loadMarkets
        this.currencies = this.deepExtend(this.currencies, currencies)
    } else {
        baseCurrencies := []interface{}{}
        quoteCurrencies := []interface{}{}
        for i := 0; IsLessThan(i, GetArrayLength(values)); i++ {
            market := values[i]
            defaultCurrencyPrecision := ((bool) IsTrue((IsEqual(this.precisionMode, DECIMAL_PLACES)))) ? 8 : this.parseNumber("1e-8")
            marketPrecision := this.safeDict(market, "precision", make(map[string]interface{}) {})
            if IsTrue(inOp(market, "base")) {
                currency := this.safeCurrencyStructure(make(map[string]interface{}) {
                    "id", this.safeString2(market, "baseId", "base"),
                    "numericId", this.safeInteger(market, "baseNumericId"),
                    "code", this.safeString(market, "base"),
                    "precision", this.safeValue2(marketPrecision, "base", "amount", defaultCurrencyPrecision),
                })
                baseCurrencies = appendToArray(baseCurrencies,currency).([]interface{})
            }
            if IsTrue(inOp(market, "quote")) {
                currency := this.safeCurrencyStructure(make(map[string]interface{}) {
                    "id", this.safeString2(market, "quoteId", "quote"),
                    "numericId", this.safeInteger(market, "quoteNumericId"),
                    "code", this.safeString(market, "quote"),
                    "precision", this.safeValue2(marketPrecision, "quote", "price", defaultCurrencyPrecision),
                })
                quoteCurrencies = appendToArray(quoteCurrencies,currency).([]interface{})
            }
        }
        baseCurrencies = this.sortBy(baseCurrencies, "code", false, "")
        quoteCurrencies = this.sortBy(quoteCurrencies, "code", false, "")
        this.baseCurrencies = this.indexBy(baseCurrencies, "code")
        this.quoteCurrencies = this.indexBy(quoteCurrencies, "code")
        allCurrencies := this.arrayConcat(baseCurrencies, quoteCurrencies)
        groupedCurrencies := this.groupBy(allCurrencies, "code")
        codes := new List<object>(((IDictionary<string,object>)groupedCurrencies).Keys)
        resultingCurrencies := []interface{}{}
        for i := 0; IsLessThan(i, GetArrayLength(codes)); i++ {
            code := codes[i]
            groupedCurrenciesCode := this.safeList(groupedCurrencies, code, []interface{}{})
            highestPrecisionCurrency := this.safeValue(groupedCurrenciesCode, 0)
            for j := 1; IsLessThan(j, GetArrayLength(groupedCurrenciesCode)); j++ {
                currentCurrency := groupedCurrenciesCode[j]
                if IsTrue(IsEqual(this.precisionMode, TICK_SIZE)) {
                    highestPrecisionCurrency = ((bool) IsTrue((IsLessThan(currentCurrency["precision"], highestPrecisionCurrency["precision"])))) ? currentCurrency : highestPrecisionCurrency
                } else {
                    highestPrecisionCurrency = ((bool) IsTrue((IsGreaterThan(currentCurrency["precision"], highestPrecisionCurrency["precision"])))) ? currentCurrency : highestPrecisionCurrency
                }
            }
            resultingCurrencies = appendToArray(resultingCurrencies,highestPrecisionCurrency).([]interface{})
        }
        sortedCurrencies := this.sortBy(resultingCurrencies, "code")
        this.currencies = this.deepExtend(this.currencies, this.indexBy(sortedCurrencies, "code"))
    }
    this.currencies_by_id = this.indexBy(this.currencies, "id")
    currenciesSortedByCode := this.keysort(this.currencies)
    this.codes = new List<object>(((IDictionary<string,object>)currenciesSortedByCode).Keys)
    return this.markets
}
func  (this *Exchange) getDescribeForExtendedWsExchange(currentRestInstance interface{}, parentRestInstance interface{}, wsBaseDescribe interface{})  {
    extendedRestDescribe := this.deepExtend(parentRestInstance.describe(), currentRestInstance.describe())
    superWithRestDescribe := this.deepExtend(extendedRestDescribe, wsBaseDescribe)
    return superWithRestDescribe
}
func  (this *Exchange) safeBalance(balance interface{})  {
    balances := this.omit(balance, []interface{}{"info", "timestamp", "datetime", "free", "used", "total"})
    codes := new List<object>(((IDictionary<string,object>)balances).Keys)
    addElementToObject(balance, "free", make(map[string]interface{}) {})
    addElementToObject(balance, "used", make(map[string]interface{}) {})
    addElementToObject(balance, "total", make(map[string]interface{}) {})
    debtBalance := make(map[string]interface{}) {}
    for i := 0; IsLessThan(i, GetArrayLength(codes)); i++ {
        code := codes[i]
        total := this.safeString(balance[code], "total")
        free := this.safeString(balance[code], "free")
        used := this.safeString(balance[code], "used")
        debt := this.safeString(balance[code], "debt")
        if IsTrue(IsTrue(IsTrue((IsEqual(total, null))) && IsTrue((!IsEqual(free, null)))) && IsTrue((!IsEqual(used, null)))) {
            total = Precise.stringAdd(free, used)
        }
        if IsTrue(IsTrue(IsTrue((IsEqual(free, null))) && IsTrue((!IsEqual(total, null)))) && IsTrue((!IsEqual(used, null)))) {
            free = Precise.stringSub(total, used)
        }
        if IsTrue(IsTrue(IsTrue((IsEqual(used, null))) && IsTrue((!IsEqual(total, null)))) && IsTrue((!IsEqual(free, null)))) {
            used = Precise.stringSub(total, free)
        }
        addElementToObject(balance[code], "free", this.parseNumber(free))
        addElementToObject(balance[code], "used", this.parseNumber(used))
        addElementToObject(balance[code], "total", this.parseNumber(total))
        addElementToObject(balance["free"], code, balance[code]["free"])
        addElementToObject(balance["used"], code, balance[code]["used"])
        addElementToObject(balance["total"], code, balance[code]["total"])
        if IsTrue(!IsEqual(debt, null)) {
            addElementToObject(balance[code], "debt", this.parseNumber(debt))
            addElementToObject(debtBalance, code, balance[code]["debt"])
        }
    }
    debtBalanceArray := new List<object>(((IDictionary<string,object>)debtBalance).Keys)
    length := GetArrayLength(debtBalanceArray)
    if IsTrue(length) {
        addElementToObject(balance, "debt", debtBalance)
    }
    return ((object)balance)
}
func  (this *Exchange) safeOrder(order interface{}, market interface{})  {
    // parses numbers as strings
    // * it is important pass the trades as unparsed rawTrades
    amount := this.omitZero(this.safeString(order, "amount"))
    remaining := this.safeString(order, "remaining")
    filled := this.safeString(order, "filled")
    cost := this.safeString(order, "cost")
    average := this.omitZero(this.safeString(order, "average"))
    price := this.omitZero(this.safeString(order, "price"))
    lastTradeTimeTimestamp := this.safeInteger(order, "lastTradeTimestamp")
    symbol := this.safeString(order, "symbol")
    side := this.safeString(order, "side")
    status := this.safeString(order, "status")
    parseFilled := (IsEqual(filled, null))
    parseCost := (IsEqual(cost, null))
    parseLastTradeTimeTimestamp := (IsEqual(lastTradeTimeTimestamp, null))
    fee := this.safeValue(order, "fee")
    parseFee := (IsEqual(fee, null))
    parseFees := IsEqual(this.safeValue(order, "fees"), null)
    parseSymbol := IsEqual(symbol, null)
    parseSide := IsEqual(side, null)
    shouldParseFees := IsTrue(parseFee) || IsTrue(parseFees)
    fees := this.safeList(order, "fees", []interface{}{})
    trades := []interface{}{}
    isTriggerOrSLTpOrder := (IsTrue((IsTrue(!IsEqual(this.safeString(order, "triggerPrice"), null)) || IsTrue((!IsEqual(this.safeString(order, "stopLossPrice"), null))))) || IsTrue((!IsEqual(this.safeString(order, "takeProfitPrice"), null))))
    if IsTrue(IsTrue(IsTrue(parseFilled) || IsTrue(parseCost)) || IsTrue(shouldParseFees)) {
        rawTrades := this.safeValue(order, "trades", trades)
        oldNumber := this.number
        // we parse trades as strings here!
        ((object)this).number = String
        firstTrade := this.safeValue(rawTrades, 0)
        // parse trades if they haven't already been parsed
        tradesAreParsed := (IsTrue(IsTrue((!IsEqual(firstTrade, null))) && IsTrue((inOp(firstTrade, "info")))) && IsTrue((inOp(firstTrade, "id"))))
        if !IsTrue(tradesAreParsed) {
            trades = this.parseTrades(rawTrades, market)
        } else {
            trades = rawTrades
        }
        this.number = oldNumber
        tradesLength := 0
        isArray := ((trades is IList<object>) || (trades.GetType().IsGenericType && trades.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))
        if IsTrue(isArray) {
            tradesLength = GetArrayLength(trades)
        }
        if IsTrue(IsTrue(isArray) && IsTrue((IsGreaterThan(tradesLength, 0)))) {
            // move properties that are defined in trades up into the order
            if IsTrue(IsEqual(order["symbol"], null)) {
                addElementToObject(order, "symbol", trades[0]["symbol"])
            }
            if IsTrue(IsEqual(order["side"], null)) {
                addElementToObject(order, "side", trades[0]["side"])
            }
            if IsTrue(IsEqual(order["type"], null)) {
                addElementToObject(order, "type", trades[0]["type"])
            }
            if IsTrue(IsEqual(order["id"], null)) {
                addElementToObject(order, "id", trades[0]["order"])
            }
            if IsTrue(parseFilled) {
                filled = "0"
            }
            if IsTrue(parseCost) {
                cost = "0"
            }
            for i := 0; IsLessThan(i, GetArrayLength(trades)); i++ {
                trade := trades[i]
                tradeAmount := this.safeString(trade, "amount")
                if IsTrue(IsTrue(parseFilled) && IsTrue((!IsEqual(tradeAmount, null)))) {
                    filled = Precise.stringAdd(filled, tradeAmount)
                }
                tradeCost := this.safeString(trade, "cost")
                if IsTrue(IsTrue(parseCost) && IsTrue((!IsEqual(tradeCost, null)))) {
                    cost = Precise.stringAdd(cost, tradeCost)
                }
                if IsTrue(parseSymbol) {
                    symbol = this.safeString(trade, "symbol")
                }
                if IsTrue(parseSide) {
                    side = this.safeString(trade, "side")
                }
                tradeTimestamp := this.safeValue(trade, "timestamp")
                if IsTrue(IsTrue(parseLastTradeTimeTimestamp) && IsTrue((!IsEqual(tradeTimestamp, null)))) {
                    if IsTrue(IsEqual(lastTradeTimeTimestamp, null)) {
                        lastTradeTimeTimestamp = tradeTimestamp
                    } else {
                        lastTradeTimeTimestamp = mathMax(lastTradeTimeTimestamp, tradeTimestamp)
                    }
                }
                if IsTrue(shouldParseFees) {
                    tradeFees := this.safeValue(trade, "fees")
                    if IsTrue(!IsEqual(tradeFees, null)) {
                        for j := 0; IsLessThan(j, GetArrayLength(tradeFees)); j++ {
                            tradeFee := tradeFees[j]
                            fees = appendToArray(fees,this.extend(make(map[string]interface{}) {}, tradeFee)).([]interface{})
                        }
                    } else {
                        tradeFee := this.safeValue(trade, "fee")
                        if IsTrue(!IsEqual(tradeFee, null)) {
                            fees = appendToArray(fees,this.extend(make(map[string]interface{}) {}, tradeFee)).([]interface{})
                        }
                    }
                }
            }
        }
    }
    if IsTrue(shouldParseFees) {
        reducedFees := ((bool) IsTrue(this.reduceFees)) ? this.reduceFeesByCurrency(fees) : fees
        reducedLength := GetArrayLength(reducedFees)
        for i := 0; IsLessThan(i, reducedLength); i++ {
            addElementToObject(reducedFees[i], "cost", this.safeNumber(reducedFees[i], "cost"))
            if IsTrue(inOp(reducedFees[i], "rate")) {
                addElementToObject(reducedFees[i], "rate", this.safeNumber(reducedFees[i], "rate"))
            }
        }
        if IsTrue(!IsTrue(parseFee) && IsTrue((IsEqual(reducedLength, 0)))) {
            // copy fee to avoid modification by reference
            feeCopy := this.deepExtend(fee)
            addElementToObject(feeCopy, "cost", this.safeNumber(feeCopy, "cost"))
            if IsTrue(inOp(feeCopy, "rate")) {
                addElementToObject(feeCopy, "rate", this.safeNumber(feeCopy, "rate"))
            }
            reducedFees = appendToArray(reducedFees,feeCopy).([]interface{})
        }
        addElementToObject(order, "fees", reducedFees)
        if IsTrue(IsTrue(parseFee) && IsTrue((IsEqual(reducedLength, 1)))) {
            addElementToObject(order, "fee", reducedFees[0])
        }
    }
    if IsTrue(IsEqual(amount, null)) {
        // ensure amount = filled + remaining
        if IsTrue(IsTrue(!IsEqual(filled, null)) && IsTrue(!IsEqual(remaining, null))) {
            amount = Precise.stringAdd(filled, remaining)
        } else if IsTrue(IsEqual(status, "closed")) {
            amount = filled
        }
    }
    if IsTrue(IsEqual(filled, null)) {
        if IsTrue(IsTrue(!IsEqual(amount, null)) && IsTrue(!IsEqual(remaining, null))) {
            filled = Precise.stringSub(amount, remaining)
        } else if IsTrue(IsTrue(IsEqual(status, "closed")) && IsTrue(!IsEqual(amount, null))) {
            filled = amount
        }
    }
    if IsTrue(IsEqual(remaining, null)) {
        if IsTrue(IsTrue(!IsEqual(amount, null)) && IsTrue(!IsEqual(filled, null))) {
            remaining = Precise.stringSub(amount, filled)
        } else if IsTrue(IsEqual(status, "closed")) {
            remaining = "0"
        }
    }
    // ensure that the average field is calculated correctly
    inverse := this.safeBool(market, "inverse", false)
    contractSize := this.numberToString(this.safeValue(market, "contractSize", 1))
    // inverse
    // price = filled * contract size / cost
    //
    // linear
    // price = cost / (filled * contract size)
    if IsTrue(IsEqual(average, null)) {
        if IsTrue(IsTrue(IsTrue((!IsEqual(filled, null))) && IsTrue((!IsEqual(cost, null)))) && IsTrue(Precise.stringGt(filled, "0"))) {
            filledTimesContractSize := Precise.stringMul(filled, contractSize)
            if IsTrue(inverse) {
                average = Precise.stringDiv(filledTimesContractSize, cost)
            } else {
                average = Precise.stringDiv(cost, filledTimesContractSize)
            }
        }
    }
    // similarly
    // inverse
    // cost = filled * contract size / price
    //
    // linear
    // cost = filled * contract size * price
    costPriceExists := IsTrue((!IsEqual(average, null))) || IsTrue((!IsEqual(price, null)))
    if IsTrue(IsTrue(IsTrue(parseCost) && IsTrue((!IsEqual(filled, null)))) && IsTrue(costPriceExists)) {
        multiplyPrice := null
        if IsTrue(IsEqual(average, null)) {
            multiplyPrice = price
        } else {
            multiplyPrice = average
        }
        // contract trading
        filledTimesContractSize := Precise.stringMul(filled, contractSize)
        if IsTrue(inverse) {
            cost = Precise.stringDiv(filledTimesContractSize, multiplyPrice)
        } else {
            cost = Precise.stringMul(filledTimesContractSize, multiplyPrice)
        }
    }
    // support for market orders
    orderType := this.safeValue(order, "type")
    emptyPrice := IsTrue((IsEqual(price, null))) || IsTrue(Precise.stringEquals(price, "0"))
    if IsTrue(IsTrue(emptyPrice) && IsTrue((IsEqual(orderType, "market")))) {
        price = average
    }
    // we have trades with string values at this point so we will mutate them
    for i := 0; IsLessThan(i, GetArrayLength(trades)); i++ {
        entry := trades[i]
        addElementToObject(entry, "amount", this.safeNumber(entry, "amount"))
        addElementToObject(entry, "price", this.safeNumber(entry, "price"))
        addElementToObject(entry, "cost", this.safeNumber(entry, "cost"))
        tradeFee := this.safeDict(entry, "fee", make(map[string]interface{}) {})
        addElementToObject(tradeFee, "cost", this.safeNumber(tradeFee, "cost"))
        if IsTrue(inOp(tradeFee, "rate")) {
            addElementToObject(tradeFee, "rate", this.safeNumber(tradeFee, "rate"))
        }
        entryFees := this.safeList(entry, "fees", []interface{}{})
        for j := 0; IsLessThan(j, GetArrayLength(entryFees)); j++ {
            addElementToObject(entryFees[j], "cost", this.safeNumber(entryFees[j], "cost"))
        }
        addElementToObject(entry, "fees", entryFees)
        addElementToObject(entry, "fee", tradeFee)
    }
    timeInForce := this.safeString(order, "timeInForce")
    postOnly := this.safeValue(order, "postOnly")
    // timeInForceHandling
    if IsTrue(IsEqual(timeInForce, null)) {
        if IsTrue(!IsTrue(isTriggerOrSLTpOrder) && IsTrue((IsEqual(this.safeString(order, "type"), "market")))) {
            timeInForce = "IOC"
        }
        // allow postOnly override
        if IsTrue(postOnly) {
            timeInForce = "PO"
        }
    } else if IsTrue(IsEqual(postOnly, null)) {
        // timeInForce is not undefined here
        postOnly = IsEqual(timeInForce, "PO")
    }
    timestamp := this.safeInteger(order, "timestamp")
    lastUpdateTimestamp := this.safeInteger(order, "lastUpdateTimestamp")
    datetime := this.safeString(order, "datetime")
    if IsTrue(IsEqual(datetime, null)) {
        datetime = this.iso8601(timestamp)
    }
    triggerPrice := this.parseNumber(this.safeString2(order, "triggerPrice", "stopPrice"))
    takeProfitPrice := this.parseNumber(this.safeString(order, "takeProfitPrice"))
    stopLossPrice := this.parseNumber(this.safeString(order, "stopLossPrice"))
    return this.extend(order, make(map[string]interface{}) {
        "id", this.safeString(order, "id"),
        "clientOrderId", this.safeString(order, "clientOrderId"),
        "timestamp", timestamp,
        "datetime", datetime,
        "symbol", symbol,
        "type", this.safeString(order, "type"),
        "side", side,
        "lastTradeTimestamp", lastTradeTimeTimestamp,
        "lastUpdateTimestamp", lastUpdateTimestamp,
        "price", this.parseNumber(price),
        "amount", this.parseNumber(amount),
        "cost", this.parseNumber(cost),
        "average", this.parseNumber(average),
        "filled", this.parseNumber(filled),
        "remaining", this.parseNumber(remaining),
        "timeInForce", timeInForce,
        "postOnly", postOnly,
        "trades", trades,
        "reduceOnly", this.safeValue(order, "reduceOnly"),
        "stopPrice", triggerPrice,
        "triggerPrice", triggerPrice,
        "takeProfitPrice", takeProfitPrice,
        "stopLossPrice", stopLossPrice,
        "status", status,
        "fee", this.safeValue(order, "fee"),
    })
}
func  (this *Exchange) parseOrders(orders interface{}, market interface{}, since interface{}, limit interface{}, parameters interface{})  {
    //
    // the value of orders is either a dict or a list
    //
    // dict
    //
    //     {
    //         'id1': { ... },
    //         'id2': { ... },
    //         'id3': { ... },
    //         ...
    //     }
    //
    // list
    //
    //     [
    //         { 'id': 'id1', ... },
    //         { 'id': 'id2', ... },
    //         { 'id': 'id3', ... },
    //         ...
    //     ]
    //
    results := []interface{}{}
    if IsTrue(((orders is IList<object>) || (orders.GetType().IsGenericType && orders.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))) {
        for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
            order := this.extend(this.parseOrder(orders[i], market), parameters)
            results = appendToArray(results,order).([]interface{})
        }
    } else {
        ids := new List<object>(((IDictionary<string,object>)orders).Keys)
        for i := 0; IsLessThan(i, GetArrayLength(ids)); i++ {
            id := ids[i]
            order := this.extend(this.parseOrder(this.extend(make(map[string]interface{}) {
                "id", id,
            }, orders[id]), market), parameters)
            results = appendToArray(results,order).([]interface{})
        }
    }
    results = this.sortBy(results, "timestamp")
    symbol := ((bool) IsTrue((!IsEqual(market, null)))) ? market["symbol"] : null
    return this.filterBySymbolSinceLimit(results, symbol, since, limit)
}
func  (this *Exchange) calculateFee(symbol string, type string, side string, amount interface{}, price interface{}, takerOrMaker string, parameters interface{})  {
    /**
     * @method
     * @description calculates the presumptive fee that would be charged for an order
     * @param {string} symbol unified market symbol
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much you want to trade, in units of the base currency on most exchanges, or number of contracts
     * @param {float} price the price for the order to be filled at, in units of the quote currency
     * @param {string} takerOrMaker 'taker' or 'maker'
     * @param {object} params
     * @returns {object} contains the rate, the percentage multiplied to the order amount to obtain the fee amount, and cost, the total value of the fee in units of the quote currency, for the order
     */
    if IsTrue(IsTrue(IsEqual(type, "market")) && IsTrue(IsEqual(takerOrMaker, "maker"))) {
        throw new ArgumentsRequired ((string)Add(this.id, " calculateFee() - you have provided incompatible arguments - \"market\" type order can not be \"maker\". Change either the \"type\" or the \"takerOrMaker\" argument to calculate the fee.")) 
    }
    market := this.markets[symbol]
    feeSide := this.safeString(market, "feeSide", "quote")
    useQuote := null
    if IsTrue(IsEqual(feeSide, "get")) {
        // the fee is always in the currency you get
        useQuote = IsEqual(side, "sell")
    } else if IsTrue(IsEqual(feeSide, "give")) {
        // the fee is always in the currency you give
        useQuote = IsEqual(side, "buy")
    } else {
        // the fee is always in feeSide currency
        useQuote = IsEqual(feeSide, "quote")
    }
    cost := this.numberToString(amount)
    key := null
    if IsTrue(useQuote) {
        priceString := this.numberToString(price)
        cost = Precise.stringMul(cost, priceString)
        key = "quote"
    } else {
        key = "base"
    }
    // for derivatives, the fee is in 'settle' currency
    if !IsTrue(market["spot"]) {
        key = "settle"
    }
    // even if `takerOrMaker` argument was set to 'maker', for 'market' orders we should forcefully override it to 'taker'
    if IsTrue(IsEqual(type, "market")) {
        takerOrMaker = "taker"
    }
    rate := this.safeString(market, takerOrMaker)
    cost = Precise.stringMul(cost, rate)
    return make(map[string]interface{}) {
        "type", takerOrMaker,
        "currency", market[key],
        "rate", this.parseNumber(rate),
        "cost", this.parseNumber(cost),
    }
}
func  (this *Exchange) safeLiquidation(liquidation interface{}, market interface{})  {
    contracts := this.safeString(liquidation, "contracts")
    contractSize := this.safeString(market, "contractSize")
    price := this.safeString(liquidation, "price")
    baseValue := this.safeString(liquidation, "baseValue")
    quoteValue := this.safeString(liquidation, "quoteValue")
    if IsTrue(IsTrue(IsTrue(IsTrue((IsEqual(baseValue, null))) && IsTrue((!IsEqual(contracts, null)))) && IsTrue((!IsEqual(contractSize, null)))) && IsTrue((!IsEqual(price, null)))) {
        baseValue = Precise.stringMul(contracts, contractSize)
    }
    if IsTrue(IsTrue(IsTrue((IsEqual(quoteValue, null))) && IsTrue((!IsEqual(baseValue, null)))) && IsTrue((!IsEqual(price, null)))) {
        quoteValue = Precise.stringMul(baseValue, price)
    }
    addElementToObject(liquidation, "contracts", this.parseNumber(contracts))
    addElementToObject(liquidation, "contractSize", this.parseNumber(contractSize))
    addElementToObject(liquidation, "price", this.parseNumber(price))
    addElementToObject(liquidation, "baseValue", this.parseNumber(baseValue))
    addElementToObject(liquidation, "quoteValue", this.parseNumber(quoteValue))
    return liquidation
}
func  (this *Exchange) safeTrade(trade interface{}, market interface{})  {
    amount := this.safeString(trade, "amount")
    price := this.safeString(trade, "price")
    cost := this.safeString(trade, "cost")
    if IsTrue(IsEqual(cost, null)) {
        // contract trading
        contractSize := this.safeString(market, "contractSize")
        multiplyPrice := price
        if IsTrue(!IsEqual(contractSize, null)) {
            inverse := this.safeBool(market, "inverse", false)
            if IsTrue(inverse) {
                multiplyPrice = Precise.stringDiv("1", price)
            }
            multiplyPrice = Precise.stringMul(multiplyPrice, contractSize)
        }
        cost = Precise.stringMul(multiplyPrice, amount)
    }
    parseFee := IsEqual(this.safeValue(trade, "fee"), null)
    parseFees := IsEqual(this.safeValue(trade, "fees"), null)
    shouldParseFees := IsTrue(parseFee) || IsTrue(parseFees)
    fees := []interface{}{}
    fee := this.safeValue(trade, "fee")
    if IsTrue(shouldParseFees) {
        reducedFees := ((bool) IsTrue(this.reduceFees)) ? this.reduceFeesByCurrency(fees) : fees
        reducedLength := GetArrayLength(reducedFees)
        for i := 0; IsLessThan(i, reducedLength); i++ {
            addElementToObject(reducedFees[i], "cost", this.safeNumber(reducedFees[i], "cost"))
            if IsTrue(inOp(reducedFees[i], "rate")) {
                addElementToObject(reducedFees[i], "rate", this.safeNumber(reducedFees[i], "rate"))
            }
        }
        if IsTrue(!IsTrue(parseFee) && IsTrue((IsEqual(reducedLength, 0)))) {
            // copy fee to avoid modification by reference
            feeCopy := this.deepExtend(fee)
            addElementToObject(feeCopy, "cost", this.safeNumber(feeCopy, "cost"))
            if IsTrue(inOp(feeCopy, "rate")) {
                addElementToObject(feeCopy, "rate", this.safeNumber(feeCopy, "rate"))
            }
            reducedFees = appendToArray(reducedFees,feeCopy).([]interface{})
        }
        if IsTrue(parseFees) {
            addElementToObject(trade, "fees", reducedFees)
        }
        if IsTrue(IsTrue(parseFee) && IsTrue((IsEqual(reducedLength, 1)))) {
            addElementToObject(trade, "fee", reducedFees[0])
        }
        tradeFee := this.safeValue(trade, "fee")
        if IsTrue(!IsEqual(tradeFee, null)) {
            addElementToObject(tradeFee, "cost", this.safeNumber(tradeFee, "cost"))
            if IsTrue(inOp(tradeFee, "rate")) {
                addElementToObject(tradeFee, "rate", this.safeNumber(tradeFee, "rate"))
            }
            addElementToObject(trade, "fee", tradeFee)
        }
    }
    addElementToObject(trade, "amount", this.parseNumber(amount))
    addElementToObject(trade, "price", this.parseNumber(price))
    addElementToObject(trade, "cost", this.parseNumber(cost))
    return trade
}
func  (this *Exchange) findNearestCeiling(arr interface{}, providedValue interface{})  {
    //  i.e. findNearestCeiling ([ 10, 30, 50],  23) returns 30
    length := GetArrayLength(arr)
    for i := 0; IsLessThan(i, length); i++ {
        current := arr[i]
        if IsTrue(IsLessThanOrEqual(providedValue, current)) {
            return current
        }
    }
    return arr[Subtract(length, 1)]
}
func  (this *Exchange) invertFlatStringDictionary(dict interface{})  {
    reversed := make(map[string]interface{}) {}
    keys := new List<object>(((IDictionary<string,object>)dict).Keys)
    for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
        key := keys[i]
        value := dict[key]
        if IsTrue((value is string)) {
            addElementToObject(reversed, value, key)
        }
    }
    return reversed
}
func  (this *Exchange) reduceFeesByCurrency(fees interface{})  {
    //
    // this function takes a list of fee structures having the following format
    //
    //     string = true
    //
    //     [
    //         { 'currency': 'BTC', 'cost': '0.1' },
    //         { 'currency': 'BTC', 'cost': '0.2'  },
    //         { 'currency': 'BTC', 'cost': '0.2', 'rate': '0.00123' },
    //         { 'currency': 'BTC', 'cost': '0.4', 'rate': '0.00123' },
    //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
    //         { 'currency': 'USDT', 'cost': '12.3456' },
    //     ]
    //
    //     string = false
    //
    //     [
    //         { 'currency': 'BTC', 'cost': 0.1 },
    //         { 'currency': 'BTC', 'cost': 0.2 },
    //         { 'currency': 'BTC', 'cost': 0.2, 'rate': 0.00123 },
    //         { 'currency': 'BTC', 'cost': 0.4, 'rate': 0.00123 },
    //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
    //         { 'currency': 'USDT', 'cost': 12.3456 },
    //     ]
    //
    // and returns a reduced fee list, where fees are summed per currency and rate (if any)
    //
    //     string = true
    //
    //     [
    //         { 'currency': 'BTC', 'cost': '0.4'  },
    //         { 'currency': 'BTC', 'cost': '0.6', 'rate': '0.00123' },
    //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
    //         { 'currency': 'USDT', 'cost': '12.3456' },
    //     ]
    //
    //     string  = false
    //
    //     [
    //         { 'currency': 'BTC', 'cost': 0.3  },
    //         { 'currency': 'BTC', 'cost': 0.6, 'rate': 0.00123 },
    //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
    //         { 'currency': 'USDT', 'cost': 12.3456 },
    //     ]
    //
    reduced := make(map[string]interface{}) {}
    for i := 0; IsLessThan(i, GetArrayLength(fees)); i++ {
        fee := fees[i]
        feeCurrencyCode := this.safeString(fee, "currency")
        if IsTrue(!IsEqual(feeCurrencyCode, null)) {
            rate := this.safeString(fee, "rate")
            cost := this.safeValue(fee, "cost")
            if IsTrue(Precise.stringEq(cost, "0")) {
                continue
            }
            if !IsTrue((inOp(reduced, feeCurrencyCode))) {
                addElementToObject(reduced, feeCurrencyCode, make(map[string]interface{}) {})
            }
            rateKey := ((bool) IsTrue((IsEqual(rate, null)))) ? "" : rate
            if IsTrue(inOp(reduced[feeCurrencyCode], rateKey)) {
                addElementToObject(reduced[feeCurrencyCode][rateKey], "cost", Precise.stringAdd(reduced[feeCurrencyCode][rateKey]["cost"], cost))
            } else {
                addElementToObject(reduced[feeCurrencyCode], rateKey, make(map[string]interface{}) {
    "currency", feeCurrencyCode,
    "cost", cost,
})
                if IsTrue(!IsEqual(rate, null)) {
                    addElementToObject(reduced[feeCurrencyCode][rateKey], "rate", rate)
                }
            }
        }
    }
    result := []interface{}{}
    feeValues := new List<object>(((IDictionary<string,object>)reduced).Values)
    for i := 0; IsLessThan(i, GetArrayLength(feeValues)); i++ {
        reducedFeeValues := new List<object>(((IDictionary<string,object>)feeValues[i]).Values)
        result = this.arrayConcat(result, reducedFeeValues)
    }
    return result
}
func  (this *Exchange) safeTicker(ticker interface{}, market interface{})  {
    open := this.omitZero(this.safeString(ticker, "open"))
    close := this.omitZero(this.safeString(ticker, "close"))
    last := this.omitZero(this.safeString(ticker, "last"))
    change := this.omitZero(this.safeString(ticker, "change"))
    percentage := this.omitZero(this.safeString(ticker, "percentage"))
    average := this.omitZero(this.safeString(ticker, "average"))
    vwap := this.omitZero(this.safeString(ticker, "vwap"))
    baseVolume := this.safeString(ticker, "baseVolume")
    quoteVolume := this.safeString(ticker, "quoteVolume")
    if IsTrue(IsEqual(vwap, null)) {
        vwap = Precise.stringDiv(this.omitZero(quoteVolume), baseVolume)
    }
    if IsTrue(IsTrue((!IsEqual(last, null))) && IsTrue((IsEqual(close, null)))) {
        close = last
    } else if IsTrue(IsTrue((IsEqual(last, null))) && IsTrue((!IsEqual(close, null)))) {
        last = close
    }
    if IsTrue(IsTrue((!IsEqual(last, null))) && IsTrue((!IsEqual(open, null)))) {
        if IsTrue(IsEqual(change, null)) {
            change = Precise.stringSub(last, open)
        }
        if IsTrue(IsEqual(average, null)) {
            average = Precise.stringDiv(Precise.stringAdd(last, open), "2")
        }
    }
    if IsTrue(IsTrue(IsTrue(IsTrue((IsEqual(percentage, null))) && IsTrue((!IsEqual(change, null)))) && IsTrue((!IsEqual(open, null)))) && IsTrue(Precise.stringGt(open, "0"))) {
        percentage = Precise.stringMul(Precise.stringDiv(change, open), "100")
    }
    if IsTrue(IsTrue(IsTrue((IsEqual(change, null))) && IsTrue((!IsEqual(percentage, null)))) && IsTrue((!IsEqual(open, null)))) {
        change = Precise.stringDiv(Precise.stringMul(percentage, open), "100")
    }
    if IsTrue(IsTrue(IsTrue((IsEqual(open, null))) && IsTrue((!IsEqual(last, null)))) && IsTrue((!IsEqual(change, null)))) {
        open = Precise.stringSub(last, change)
    }
    // timestamp and symbol operations don't belong in safeTicker
    // they should be done in the derived classes
    return this.extend(ticker, make(map[string]interface{}) {
        "bid", this.parseNumber(this.omitZero(this.safeString(ticker, "bid"))),
        "bidVolume", this.safeNumber(ticker, "bidVolume"),
        "ask", this.parseNumber(this.omitZero(this.safeString(ticker, "ask"))),
        "askVolume", this.safeNumber(ticker, "askVolume"),
        "high", this.parseNumber(this.omitZero(this.safeString(ticker, "high"))),
        "low", this.parseNumber(this.omitZero(this.safeString(ticker, "low"))),
        "open", this.parseNumber(this.omitZero(open)),
        "close", this.parseNumber(this.omitZero(close)),
        "last", this.parseNumber(this.omitZero(last)),
        "change", this.parseNumber(change),
        "percentage", this.parseNumber(percentage),
        "average", this.parseNumber(average),
        "vwap", this.parseNumber(vwap),
        "baseVolume", this.parseNumber(baseVolume),
        "quoteVolume", this.parseNumber(quoteVolume),
        "previousClose", this.safeNumber(ticker, "previousClose"),
    })
}
func  (this *Exchange) fetchBorrowRate(code string, amount interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchBorrowRate is deprecated, please use fetchCrossBorrowRate or fetchIsolatedBorrowRate instead")) 
}
func  (this *Exchange) repayCrossMargin(code string, amount interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " repayCrossMargin is not support yet")) 
}
func  (this *Exchange) repayIsolatedMargin(symbol string, code string, amount interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " repayIsolatedMargin is not support yet")) 
}
func  (this *Exchange) borrowCrossMargin(code string, amount interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " borrowCrossMargin is not support yet")) 
}
func  (this *Exchange) borrowIsolatedMargin(symbol string, code string, amount interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " borrowIsolatedMargin is not support yet")) 
}
func  (this *Exchange) borrowMargin(code string, amount interface{}, symbol interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " borrowMargin is deprecated, please use borrowCrossMargin or borrowIsolatedMargin instead")) 
}
func  (this *Exchange) repayMargin(code string, amount interface{}, symbol interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " repayMargin is deprecated, please use repayCrossMargin or repayIsolatedMargin instead")) 
}
func  (this *Exchange) fetchOHLCV(symbol string, timeframe string, since interface{}, limit interface{}, parameters interface{})  {
    message := ""
    if IsTrue(this.has["fetchTrades"]) {
        message = ". If you want to build OHLCV candles from trade executions data, visit https://github.com/ccxt/ccxt/tree/master/examples/ and see \"build-ohlcv-bars\" file"
    }
    throw new NotSupported ((string)Add(Add(this.id, " fetchOHLCV() is not supported yet"), message)) 
}
func  (this *Exchange) fetchOHLCVWs(symbol string, timeframe string, since interface{}, limit interface{}, parameters interface{})  {
    message := ""
    if IsTrue(this.has["fetchTradesWs"]) {
        message = ". If you want to build OHLCV candles from trade executions data, visit https://github.com/ccxt/ccxt/tree/master/examples/ and see \"build-ohlcv-bars\" file"
    }
    throw new NotSupported ((string)Add(Add(this.id, " fetchOHLCVWs() is not supported yet. Try using fetchOHLCV instead."), message)) 
}
func  (this *Exchange) watchOHLCV(symbol string, timeframe string, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " watchOHLCV() is not supported yet")) 
}
func  (this *Exchange) convertTradingViewToOHLCV(ohlcvs interface{}, timestamp string, open string, high string, low string, close string, volume string, ms bool)  {
    result := []interface{}{}
    timestamps := this.safeList(ohlcvs, timestamp, []interface{}{})
    opens := this.safeList(ohlcvs, open, []interface{}{})
    highs := this.safeList(ohlcvs, high, []interface{}{})
    lows := this.safeList(ohlcvs, low, []interface{}{})
    closes := this.safeList(ohlcvs, close, []interface{}{})
    volumes := this.safeList(ohlcvs, volume, []interface{}{})
    for i := 0; IsLessThan(i, GetArrayLength(timestamps)); i++ {
        result = appendToArray(result,[]interface{}{((bool) IsTrue(ms)) ? this.safeInteger(timestamps, i) : this.safeTimestamp(timestamps, i), this.safeValue(opens, i), this.safeValue(highs, i), this.safeValue(lows, i), this.safeValue(closes, i), this.safeValue(volumes, i)}).([]interface{})
    }
    return result
}
func  (this *Exchange) convertOHLCVToTradingView(ohlcvs interface{}, timestamp string, open string, high string, low string, close string, volume string, ms bool)  {
    result := make(map[string]interface{}) {}
    addElementToObject(result, timestamp, []interface{}{})
    addElementToObject(result, open, []interface{}{})
    addElementToObject(result, high, []interface{}{})
    addElementToObject(result, low, []interface{}{})
    addElementToObject(result, close, []interface{}{})
    addElementToObject(result, volume, []interface{}{})
    for i := 0; IsLessThan(i, GetArrayLength(ohlcvs)); i++ {
        ts := ((bool) IsTrue(ms)) ? ohlcvs[i][0] : this.parseToInt(Divide(ohlcvs[i][0], 1000))
        result[timestamp] = appendToArray(result[timestamp],ts).([]interface{})
        result[open] = appendToArray(result[open],ohlcvs[i][1]).([]interface{})
        result[high] = appendToArray(result[high],ohlcvs[i][2]).([]interface{})
        result[low] = appendToArray(result[low],ohlcvs[i][3]).([]interface{})
        result[close] = appendToArray(result[close],ohlcvs[i][4]).([]interface{})
        result[volume] = appendToArray(result[volume],ohlcvs[i][5]).([]interface{})
    }
    return result
}
func  (this *Exchange) fetchWebEndpoint(method interface{}, endpointMethod interface{}, returnAsJson interface{}, startRegex interface{}, endRegex interface{})  {
    errorMessage := ""
    options := this.safeValue(this.options, method, make(map[string]interface{}) {})
    muteOnFailure := this.safeBool(options, "webApiMuteFailure", true)
    try {
        // if it was not explicitly disabled, then don't fetch
        if IsTrue(!IsEqual(this.safeBool(options, "webApiEnable", true), true)) {
            return null
        }
        maxRetries := this.safeValue(options, "webApiRetries", 10)
        response := null
        retry := 0
        while IsLessThan(retry, maxRetries) {
            try {
                response = await ((Task<object>)callDynamically(this, endpointMethod, new object[] { make(map[string]interface{}) {} }))
                break
            } catch Exception e {
                retry = Add(retry, 1)
                if IsTrue(IsEqual(retry, maxRetries)) {
                    throw e
                }
            }
        }
        content := response
        if IsTrue(!IsEqual(startRegex, null)) {
            splitted_by_start := ((string)content).Split(new [] {((string)startRegex)}, StringSplitOptions.None).ToList<object>()
            content = splitted_by_start[1] // we need second part after start
        }
        if IsTrue(!IsEqual(endRegex, null)) {
            splitted_by_end := ((string)content).Split(new [] {((string)endRegex)}, StringSplitOptions.None).ToList<object>()
            content = splitted_by_end[0] // we need first part after start
        }
        if IsTrue(IsTrue(returnAsJson) && IsTrue(((content is string)))) {
            jsoned := this.parseJson(((string)content).Trim()) // content should be trimmed before json parsing
            if IsTrue(jsoned) {
                return jsoned  // if parsing was not successfull, exception should be thrown
            } else {
                throw new BadResponse ((string)"could not parse the response into json") 
            }
        } else {
            return content
        }
    } catch Exception e {
        errorMessage = Add(Add(Add(this.id, " "), method), "() failed to fetch correct data from website. Probably webpage markup has been changed, breaking the page custom parser.")
    }
    if IsTrue(muteOnFailure) {
        return null
    } else {
        throw new BadResponse ((string)errorMessage) 
    }
}
func  (this *Exchange) marketIds(symbols interface{})  {
    if IsTrue(IsEqual(symbols, null)) {
        return symbols
    }
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
        result = appendToArray(result,this.marketId(symbols[i])).([]interface{})
    }
    return result
}
func  (this *Exchange) marketsForSymbols(symbols interface{})  {
    if IsTrue(IsEqual(symbols, null)) {
        return symbols
    }
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
        result = appendToArray(result,this.market(symbols[i])).([]interface{})
    }
    return result
}
func  (this *Exchange) marketSymbols(symbols interface{}, type interface{}, allowEmpty bool, sameTypeOnly bool, sameSubTypeOnly bool)  {
    if IsTrue(IsEqual(symbols, null)) {
        if !IsTrue(allowEmpty) {
            throw new ArgumentsRequired ((string)Add(this.id, " empty list of symbols is not supported")) 
        }
        return symbols
    }
    symbolsLength := GetArrayLength(symbols)
    if IsTrue(IsEqual(symbolsLength, 0)) {
        if !IsTrue(allowEmpty) {
            throw new ArgumentsRequired ((string)Add(this.id, " empty list of symbols is not supported")) 
        }
        return symbols
    }
    result := []interface{}{}
    marketType := null
    isLinearSubType := null
    for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
        market := this.market(symbols[i])
        if IsTrue(IsTrue(sameTypeOnly) && IsTrue((!IsEqual(marketType, null)))) {
            if IsTrue(!IsEqual(market["type"], marketType)) {
                throw new BadRequest ((string)Add(Add(Add(Add(Add(this.id, " symbols must be of the same type, either "), marketType), " or "), market["type"]), ".")) 
            }
        }
        if IsTrue(IsTrue(sameSubTypeOnly) && IsTrue((!IsEqual(isLinearSubType, null)))) {
            if IsTrue(!IsEqual(market["linear"], isLinearSubType)) {
                throw new BadRequest ((string)Add(this.id, " symbols must be of the same subType, either linear or inverse.")) 
            }
        }
        if IsTrue(IsTrue(!IsEqual(type, null)) && IsTrue(!IsEqual(market["type"], type))) {
            throw new BadRequest ((string)Add(Add(Add(this.id, " symbols must be of the same type "), type), ". If the type is incorrect you can change it in options or the params of the request")) 
        }
        marketType = market["type"]
        if !IsTrue(market["spot"]) {
            isLinearSubType = market["linear"]
        }
        symbol := this.safeString(market, "symbol", symbols[i])
        result = appendToArray(result,symbol).([]interface{})
    }
    return result
}
func  (this *Exchange) marketCodes(codes interface{})  {
    if IsTrue(IsEqual(codes, null)) {
        return codes
    }
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(codes)); i++ {
        result = appendToArray(result,this.commonCurrencyCode(codes[i])).([]interface{})
    }
    return result
}
func  (this *Exchange) parseBidsAsks(bidasks interface{}, priceKey interface{}, amountKey interface{}, countOrIdKey interface{})  {
    bidasks = this.toArray(bidasks)
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(bidasks)); i++ {
        result = appendToArray(result,this.parseBidAsk(bidasks[i], priceKey, amountKey, countOrIdKey)).([]interface{})
    }
    return result
}
func  (this *Exchange) fetchL2OrderBook(symbol string, limit interface{}, parameters interface{})  {
    orderbook := await this.fetchOrderBook(symbol, limit, parameters)
    return this.extend(orderbook, make(map[string]interface{}) {
        "asks", this.sortBy(this.aggregate(orderbook["asks"]), 0),
        "bids", this.sortBy(this.aggregate(orderbook["bids"]), 0, true),
    })
}
func  (this *Exchange) filterBySymbol(objects interface{}, symbol interface{})  {
    if IsTrue(IsEqual(symbol, null)) {
        return objects
    }
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(objects)); i++ {
        objectSymbol := this.safeString(objects[i], "symbol")
        if IsTrue(IsEqual(objectSymbol, symbol)) {
            result = appendToArray(result,objects[i]).([]interface{})
        }
    }
    return result
}
func  (this *Exchange) parseOHLCV(ohlcv interface{}, market interface{})  {
    if IsTrue(((ohlcv is IList<object>) || (ohlcv.GetType().IsGenericType && ohlcv.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))) {
        return new List<object> {this.safeInteger(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 5)}
    }
    return ohlcv
}
func  (this *Exchange) networkCodeToId(networkCode string, currencyCode interface{})  {
    /**
     * @ignore
     * @method
     * @name exchange#networkCodeToId
     * @description tries to convert the provided networkCode (which is expected to be an unified network code) to a network id. In order to achieve this, derived class needs to have 'options->networks' defined.
     * @param {string} networkCode unified network code
     * @param {string} currencyCode unified currency code, but this argument is not required by default, unless there is an exchange (like huobi) that needs an override of the method to be able to pass currencyCode argument additionally
     * @returns {string|undefined} exchange-specific network id
     */
    if IsTrue(IsEqual(networkCode, null)) {
        return null
    }
    networkIdsByCodes := this.safeValue(this.options, "networks", make(map[string]interface{}) {})
    networkId := this.safeString(networkIdsByCodes, networkCode)
    // for example, if 'ETH' is passed for networkCode, but 'ETH' key not defined in `options->networks` object
    if IsTrue(IsEqual(networkId, null)) {
        if IsTrue(IsEqual(currencyCode, null)) {
            currencies := new List<object>(((IDictionary<string,object>)this.currencies).Values)
            for i := 0; IsLessThan(i, GetArrayLength(currencies)); i++ {
                currency := []interface{}{i}
                networks := this.safeDict(currency, "networks")
                network := this.safeDict(networks, networkCode)
                networkId = this.safeString(network, "id")
                if IsTrue(!IsEqual(networkId, null)) {
                    break
                }
            }
        } else {
            // if currencyCode was provided, then we try to find if that currencyCode has a replacement (i.e. ERC20 for ETH) or is in the currency
            defaultNetworkCodeReplacements := this.safeValue(this.options, "defaultNetworkCodeReplacements", make(map[string]interface{}) {})
            if IsTrue(inOp(defaultNetworkCodeReplacements, currencyCode)) {
                // if there is a replacement for the passed networkCode, then we use it to find network-id in `options->networks` object
                replacementObject := defaultNetworkCodeReplacements[currencyCode] // i.e. { 'ERC20': 'ETH' }
                keys := new List<object>(((IDictionary<string,object>)replacementObject).Keys)
                for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
                    key := keys[i]
                    value := replacementObject[key]
                    // if value matches to provided unified networkCode, then we use it's key to find network-id in `options->networks` object
                    if IsTrue(IsEqual(value, networkCode)) {
                        networkId = this.safeString(networkIdsByCodes, key)
                        break
                    }
                }
            } else {
                // serach for network inside currency
                currency := this.safeDict(this.currencies, currencyCode)
                networks := this.safeDict(currency, "networks")
                network := this.safeDict(networks, networkCode)
                networkId = this.safeString(network, "id")
            }
        }
        // if it wasn't found, we just set the provided value to network-id
        if IsTrue(IsEqual(networkId, null)) {
            networkId = networkCode
        }
    }
    return networkId
}
func  (this *Exchange) networkIdToCode(networkId interface{}, currencyCode interface{})  {
    /**
     * @ignore
     * @method
     * @name exchange#networkIdToCode
     * @description tries to convert the provided exchange-specific networkId to an unified network Code. In order to achieve this, derived class needs to have "options['networksById']" defined.
     * @param {string} networkId exchange specific network id/title, like: TRON, Trc-20, usdt-erc20, etc
     * @param {string|undefined} currencyCode unified currency code, but this argument is not required by default, unless there is an exchange (like huobi) that needs an override of the method to be able to pass currencyCode argument additionally
     * @returns {string|undefined} unified network code
     */
    if IsTrue(IsEqual(networkId, null)) {
        return null
    }
    networkCodesByIds := this.safeDict(this.options, "networksById", make(map[string]interface{}) {})
    networkCode := this.safeString(networkCodesByIds, networkId, networkId)
    // replace mainnet network-codes (i.e. ERC20->ETH)
    if IsTrue(!IsEqual(currencyCode, null)) {
        defaultNetworkCodeReplacements := this.safeDict(this.options, "defaultNetworkCodeReplacements", make(map[string]interface{}) {})
        if IsTrue(inOp(defaultNetworkCodeReplacements, currencyCode)) {
            replacementObject := this.safeDict(defaultNetworkCodeReplacements, currencyCode, make(map[string]interface{}) {})
            networkCode = this.safeString(replacementObject, networkCode, networkCode)
        }
    }
    return networkCode
}
func  (this *Exchange) handleNetworkCodeAndParams(parameters interface{})  {
    networkCodeInParams := this.safeString2(parameters, "networkCode", "network")
    if IsTrue(!IsEqual(networkCodeInParams, null)) {
        parameters = this.omit(parameters, []interface{}{"networkCode", "network"})
    }
    // if it was not defined by user, we should not set it from 'defaultNetworks', because handleNetworkCodeAndParams is for only request-side and thus we do not fill it with anything. We can only use 'defaultNetworks' after parsing response-side
    return []interface{}{networkCodeInParams, parameters}
}
func  (this *Exchange) defaultNetworkCode(currencyCode string)  {
    defaultNetworkCode := null
    defaultNetworks := this.safeDict(this.options, "defaultNetworks", make(map[string]interface{}) {})
    if IsTrue(inOp(defaultNetworks, currencyCode)) {
        // if currency had set its network in "defaultNetworks", use it
        defaultNetworkCode = defaultNetworks[currencyCode]
    } else {
        // otherwise, try to use the global-scope 'defaultNetwork' value (even if that network is not supported by currency, it doesn't make any problem, this will be just used "at first" if currency supports this network at all)
        defaultNetwork := this.safeDict(this.options, "defaultNetwork")
        if IsTrue(!IsEqual(defaultNetwork, null)) {
            defaultNetworkCode = defaultNetwork
        }
    }
    return defaultNetworkCode
}
func  (this *Exchange) selectNetworkCodeFromUnifiedNetworks(currencyCode interface{}, networkCode interface{}, indexedNetworkEntries interface{})  {
    return this.selectNetworkKeyFromNetworks(currencyCode, networkCode, indexedNetworkEntries, true)
}
func  (this *Exchange) selectNetworkIdFromRawNetworks(currencyCode interface{}, networkCode interface{}, indexedNetworkEntries interface{})  {
    return this.selectNetworkKeyFromNetworks(currencyCode, networkCode, indexedNetworkEntries, false)
}
func  (this *Exchange) selectNetworkKeyFromNetworks(currencyCode interface{}, networkCode interface{}, indexedNetworkEntries interface{}, isIndexedByUnifiedNetworkCode bool)  {
    // this method is used against raw & unparse network entries, which are just indexed by network id
    chosenNetworkId := null
    availableNetworkIds := new List<object>(((IDictionary<string,object>)indexedNetworkEntries).Keys)
    responseNetworksLength := GetArrayLength(availableNetworkIds)
    if IsTrue(!IsEqual(networkCode, null)) {
        if IsTrue(IsEqual(responseNetworksLength, 0)) {
            throw new NotSupported ((string)Add(Add(Add(Add(this.id, " - "), networkCode), " network did not return any result for "), currencyCode)) 
        } else {
            // if networkCode was provided by user, we should check it after response, as the referenced exchange doesn't support network-code during request
            networkId := ((bool) IsTrue(isIndexedByUnifiedNetworkCode)) ? networkCode : this.networkCodeToId(networkCode, currencyCode)
            if IsTrue(inOp(indexedNetworkEntries, networkId)) {
                chosenNetworkId = networkId
            } else {
                throw new NotSupported ((string)Add(Add(Add(Add(Add(Add(this.id, " - "), networkId), " network was not found for "), currencyCode), ", use one of "), String.Join(", ", ((IList<object>)availableNetworkIds).ToArray()))) 
            }
        }
    } else {
        if IsTrue(IsEqual(responseNetworksLength, 0)) {
            throw new NotSupported ((string)Add(Add(this.id, " - no networks were returned for "), currencyCode)) 
        } else {
            // if networkCode was not provided by user, then we try to use the default network (if it was defined in "defaultNetworks"), otherwise, we just return the first network entry
            defaultNetworkCode := this.defaultNetworkCode(currencyCode)
            defaultNetworkId := ((bool) IsTrue(isIndexedByUnifiedNetworkCode)) ? defaultNetworkCode : this.networkCodeToId(defaultNetworkCode, currencyCode)
            chosenNetworkId = ((bool) IsTrue((inOp(indexedNetworkEntries, defaultNetworkId)))) ? defaultNetworkId : availableNetworkIds[0]
        }
    }
    return chosenNetworkId
}
func  (this *Exchange) safeNumber2(dictionary interface{}, key1 interface{}, key2 interface{}, d interface{})  {
    value := this.safeString2(dictionary, key1, key2)
    return this.parseNumber(value, d)
}
func  (this *Exchange) parseOrderBook(orderbook interface{}, symbol string, timestamp interface{}, bidsKey string, asksKey string, priceKey interface{}, amountKey interface{}, countOrIdKey interface{})  {
    bids := this.parseBidsAsks(this.safeValue(orderbook, bidsKey, []interface{}{}), priceKey, amountKey, countOrIdKey)
    asks := this.parseBidsAsks(this.safeValue(orderbook, asksKey, []interface{}{}), priceKey, amountKey, countOrIdKey)
    return ((object)make(map[string]interface{}) {
        "symbol", symbol,
        "bids", this.sortBy(bids, 0, true),
        "asks", this.sortBy(asks, 0),
        "timestamp", timestamp,
        "datetime", this.iso8601(timestamp),
        "nonce", null,
    })
}
func  (this *Exchange) parseOHLCVs(ohlcvs interface{}, market interface{}, timeframe string, since interface{}, limit interface{})  {
    results := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(ohlcvs)); i++ {
        results = appendToArray(results,this.parseOHLCV(ohlcvs[i], market)).([]interface{})
    }
    sorted := this.sortBy(results, 0)
    return ((object)this.filterBySinceLimit(sorted, since, limit, 0))
}
func  (this *Exchange) parseLeverageTiers(response interface{}, symbols interface{}, marketIdKey interface{})  {
    // marketIdKey should only be undefined when response is a dictionary
    symbols = this.marketSymbols(symbols)
    tiers := make(map[string]interface{}) {}
    symbolsLength := 0
    if IsTrue(!IsEqual(symbols, null)) {
        symbolsLength = GetArrayLength(symbols)
    }
    noSymbols := IsTrue((IsEqual(symbols, null))) || IsTrue((IsEqual(symbolsLength, 0)))
    if IsTrue(((response is IList<object>) || (response.GetType().IsGenericType && response.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))) {
        for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
            item := response[i]
            id := this.safeString(item, marketIdKey)
            market := this.safeMarket(id, null, null, "swap")
            symbol := market["symbol"]
            contract := this.safeBool(market, "contract", false)
            if IsTrue(IsTrue(contract) && IsTrue((IsTrue(noSymbols) || IsTrue(this.inArray(symbol, symbols))))) {
                addElementToObject(tiers, symbol, this.parseMarketLeverageTiers(item, market))
            }
        }
    } else {
        keys := new List<object>(((IDictionary<string,object>)response).Keys)
        for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
            marketId := keys[i]
            item := response[marketId]
            market := this.safeMarket(marketId, null, null, "swap")
            symbol := market["symbol"]
            contract := this.safeBool(market, "contract", false)
            if IsTrue(IsTrue(contract) && IsTrue((IsTrue(noSymbols) || IsTrue(this.inArray(symbol, symbols))))) {
                addElementToObject(tiers, symbol, this.parseMarketLeverageTiers(item, market))
            }
        }
    }
    return tiers
}
func  (this *Exchange) loadTradingLimits(symbols interface{}, reload bool, parameters interface{})  {
    if IsTrue(this.has["fetchTradingLimits"]) {
        if IsTrue(IsTrue(reload) || !IsTrue((inOp(this.options, "limitsLoaded")))) {
            response := await this.fetchTradingLimits(symbols)
            for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
                symbol := symbols[i]
                addElementToObject(this.markets, symbol, this.deepExtend(this.markets[symbol], response[symbol]))
            }
            addElementToObject(this.options, "limitsLoaded", this.milliseconds())
        }
    }
    return this.markets
}
func  (this *Exchange) safePosition(position interface{})  {
    // simplified version of: /pull/12765/
    unrealizedPnlString := this.safeString(position, "unrealisedPnl")
    initialMarginString := this.safeString(position, "initialMargin")
    //
    // PERCENTAGE
    //
    percentage := this.safeValue(position, "percentage")
    if IsTrue(IsTrue(IsTrue((IsEqual(percentage, null))) && IsTrue((!IsEqual(unrealizedPnlString, null)))) && IsTrue((!IsEqual(initialMarginString, null)))) {
        // as it was done in all implementations ( aax, btcex, bybit, deribit, ftx, gate, kucoinfutures, phemex )
        percentageString := Precise.stringMul(Precise.stringDiv(unrealizedPnlString, initialMarginString, 4), "100")
        addElementToObject(position, "percentage", this.parseNumber(percentageString))
    }
    // if contractSize is undefined get from market
    contractSize := this.safeNumber(position, "contractSize")
    symbol := this.safeString(position, "symbol")
    market := null
    if IsTrue(!IsEqual(symbol, null)) {
        market = this.safeValue(this.markets, symbol)
    }
    if IsTrue(IsTrue(IsEqual(contractSize, null)) && IsTrue(!IsEqual(market, null))) {
        contractSize = this.safeNumber(market, "contractSize")
        addElementToObject(position, "contractSize", contractSize)
    }
    return position
}
func  (this *Exchange) parsePositions(positions interface{}, symbols interface{}, parameters interface{})  {
    symbols = this.marketSymbols(symbols)
    positions = this.toArray(positions)
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(positions)); i++ {
        position := this.extend(this.parsePosition(positions[i], null), parameters)
        result = appendToArray(result,position).([]interface{})
    }
    return this.filterByArrayPositions(result, "symbol", symbols, false)
}
func  (this *Exchange) parseAccounts(accounts interface{}, parameters interface{})  {
    accounts = this.toArray(accounts)
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(accounts)); i++ {
        account := this.extend(this.parseAccount(accounts[i]), parameters)
        result = appendToArray(result,account).([]interface{})
    }
    return result
}
func  (this *Exchange) parseTrades(trades interface{}, market interface{}, since interface{}, limit interface{}, parameters interface{})  {
    trades = this.toArray(trades)
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(trades)); i++ {
        trade := this.extend(this.parseTrade(trades[i], market), parameters)
        result = appendToArray(result,trade).([]interface{})
    }
    result = this.sortBy2(result, "timestamp", "id")
    symbol := ((bool) IsTrue((!IsEqual(market, null)))) ? market["symbol"] : null
    return this.filterBySymbolSinceLimit(result, symbol, since, limit)
}
func  (this *Exchange) parseTransactions(transactions interface{}, currency interface{}, since interface{}, limit interface{}, parameters interface{})  {
    transactions = this.toArray(transactions)
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(transactions)); i++ {
        transaction := this.extend(this.parseTransaction(transactions[i], currency), parameters)
        result = appendToArray(result,transaction).([]interface{})
    }
    result = this.sortBy(result, "timestamp")
    code := ((bool) IsTrue((!IsEqual(currency, null)))) ? currency["code"] : null
    return this.filterByCurrencySinceLimit(result, code, since, limit)
}
func  (this *Exchange) parseTransfers(transfers interface{}, currency interface{}, since interface{}, limit interface{}, parameters interface{})  {
    transfers = this.toArray(transfers)
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(transfers)); i++ {
        transfer := this.extend(this.parseTransfer(transfers[i], currency), parameters)
        result = appendToArray(result,transfer).([]interface{})
    }
    result = this.sortBy(result, "timestamp")
    code := ((bool) IsTrue((!IsEqual(currency, null)))) ? currency["code"] : null
    return this.filterByCurrencySinceLimit(result, code, since, limit)
}
func  (this *Exchange) parseLedger(data interface{}, currency interface{}, since interface{}, limit interface{}, parameters interface{})  {
    result := []interface{}{}
    arrayData := this.toArray(data)
    for i := 0; IsLessThan(i, GetArrayLength(arrayData)); i++ {
        itemOrItems := this.parseLedgerEntry(arrayData[i], currency)
        if IsTrue(((itemOrItems is IList<object>) || (itemOrItems.GetType().IsGenericType && itemOrItems.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))) {
            for j := 0; IsLessThan(j, GetArrayLength(itemOrItems)); j++ {
                result = appendToArray(result,this.extend(itemOrItems[j], parameters)).([]interface{})
            }
        } else {
            result = appendToArray(result,this.extend(itemOrItems, parameters)).([]interface{})
        }
    }
    result = this.sortBy(result, "timestamp")
    code := ((bool) IsTrue((!IsEqual(currency, null)))) ? currency["code"] : null
    return this.filterByCurrencySinceLimit(result, code, since, limit)
}
func  (this *Exchange) nonce()  {
    return this.seconds()
}
func  (this *Exchange) setHeaders(headers interface{})  {
    return headers
}
func  (this *Exchange) marketId(symbol string)  {
    market := this.market(symbol)
    if IsTrue(!IsEqual(market, null)) {
        return market["id"]
    }
    return symbol
}
func  (this *Exchange) symbol(symbol string)  {
    market := this.market(symbol)
    return this.safeString(market, "symbol", symbol)
}
func  (this *Exchange) handleParamString(parameters interface{}, paramName string, defaultValue interface{})  {
    value := this.safeString(parameters, paramName, defaultValue)
    if IsTrue(!IsEqual(value, null)) {
        parameters = this.omit(parameters, paramName)
    }
    return []interface{}{value, parameters}
}
func  (this *Exchange) handleParamString2(parameters interface{}, paramName1 string, paramName2 string, defaultValue interface{})  {
    value := this.safeString2(parameters, paramName1, paramName2, defaultValue)
    if IsTrue(!IsEqual(value, null)) {
        parameters = this.omit(parameters, []interface{}{paramName1, paramName2})
    }
    return []interface{}{value, parameters}
}
func  (this *Exchange) handleParamInteger(parameters interface{}, paramName string, defaultValue interface{})  {
    value := this.safeInteger(parameters, paramName, defaultValue)
    if IsTrue(!IsEqual(value, null)) {
        parameters = this.omit(parameters, paramName)
    }
    return []interface{}{value, parameters}
}
func  (this *Exchange) handleParamInteger2(parameters interface{}, paramName1 string, paramName2 string, defaultValue interface{})  {
    value := this.safeInteger2(parameters, paramName1, paramName2, defaultValue)
    if IsTrue(!IsEqual(value, null)) {
        parameters = this.omit(parameters, []interface{}{paramName1, paramName2})
    }
    return []interface{}{value, parameters}
}
func  (this *Exchange) handleParamBool(parameters interface{}, paramName string, defaultValue interface{})  {
    value := this.safeBool(parameters, paramName, defaultValue)
    if IsTrue(!IsEqual(value, null)) {
        parameters = this.omit(parameters, paramName)
    }
    return []interface{}{value, parameters}
}
func  (this *Exchange) handleParamBool2(parameters interface{}, paramName1 string, paramName2 string, defaultValue interface{})  {
    value := this.safeBool2(parameters, paramName1, paramName2, defaultValue)
    if IsTrue(!IsEqual(value, null)) {
        parameters = this.omit(parameters, []interface{}{paramName1, paramName2})
    }
    return []interface{}{value, parameters}
}
func  (this *Exchange) resolvePath(path interface{}, parameters interface{})  {
    return new List<object> {this.implodeParams(path, parameters), this.omit(parameters, this.extractParams(path))}
}
func  (this *Exchange) getListFromObjectValues(objects interface{}, key interface{})  {
    newArray := this.toArray(objects)
    results := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(newArray)); i++ {
        results = appendToArray(results,newArray[i][key]).([]interface{})
    }
    return results
}
func  (this *Exchange) getSymbolsForMarketType(marketType interface{}, subType interface{}, symbolWithActiveStatus bool, symbolWithUnknownStatus bool)  {
    filteredMarkets := this.markets
    if IsTrue(!IsEqual(marketType, null)) {
        filteredMarkets = this.filterBy(filteredMarkets, "type", marketType)
    }
    if IsTrue(!IsEqual(subType, null)) {
        this.checkRequiredArgument("getSymbolsForMarketType", subType, "subType", []interface{}{"linear", "inverse", "quanto"})
        filteredMarkets = this.filterBy(filteredMarkets, "subType", subType)
    }
    activeStatuses := []interface{}{}
    if IsTrue(symbolWithActiveStatus) {
        activeStatuses = appendToArray(activeStatuses,true).([]interface{})
    }
    if IsTrue(symbolWithUnknownStatus) {
        activeStatuses = appendToArray(activeStatuses,null).([]interface{})
    }
    filteredMarkets = this.filterByArray(filteredMarkets, "active", activeStatuses, false)
    return this.getListFromObjectValues(filteredMarkets, "symbol")
}
func  (this *Exchange) filterByArray(objects interface{}, key interface{}, values interface{}, indexed bool)  {
    objects = this.toArray(objects)
    // return all of them if no values were passed
    if IsTrue(IsTrue(IsEqual(values, null)) || !IsTrue(values)) {
        return ((bool) IsTrue(indexed)) ? this.indexBy(objects, key) : objects
    }
    results := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(objects)); i++ {
        if IsTrue(this.inArray(objects[i][key], values)) {
            results = appendToArray(results,objects[i]).([]interface{})
        }
    }
    return ((bool) IsTrue(indexed)) ? this.indexBy(results, key) : results
}
func  (this *Exchange) fetch2(path interface{}, api string, method string, parameters interface{}, headers interface{}, body interface{}, config interface{})  {
    if IsTrue(this.enableRateLimit) {
        cost := this.calculateRateLimiterCost(api, method, path, parameters, config)
        await this.throttle(cost)
    }
    this.lastRestRequestTimestamp = this.milliseconds()
    request := this.sign(path, api, method, parameters, headers, body)
    this.last_request_headers = request["headers"]
    this.last_request_body = request["body"]
    this.last_request_url = request["url"]
    return await this.fetch(request["url"], request["method"], request["headers"], request["body"])
}
func  (this *Exchange) request(path interface{}, api string, method string, parameters interface{}, headers interface{}, body interface{}, config interface{})  {
    return await this.fetch2(path, api, method, parameters, headers, body, config)
}
func  (this *Exchange) loadAccounts(reload bool, parameters interface{})  {
    if IsTrue(reload) {
        this.accounts = await this.fetchAccounts(parameters)
    } else {
        if IsTrue(this.accounts) {
            return this.accounts
        } else {
            this.accounts = await this.fetchAccounts(parameters)
        }
    }
    this.accountsById = ((object)this.indexBy(this.accounts, "id"))
    return this.accounts
}
func  (this *Exchange) buildOHLCVC(trades interface{}, timeframe string, since interface{}, limit interface{})  {
    // given a sorted arrays of trades (recent last) and a timeframe builds an array of OHLCV candles
    // note, default limit value (2147483647) is max int32 value
    ms := Multiply(this.parseTimeframe(timeframe), 1000)
    ohlcvs := []interface{}{}
    i_timestamp := 0
    // const open = 1;
    i_high := 2
    i_low := 3
    i_close := 4
    i_volume := 5
    i_count := 6
    tradesLength := GetArrayLength(trades)
    oldest := mathMin(tradesLength, limit)
    for i := 0; IsLessThan(i, oldest); i++ {
        trade := trades[i]
        ts := trade["timestamp"]
        if IsTrue(IsLessThan(ts, since)) {
            continue
        }
        openingTime := Multiply((Math.Floor(Double.Parse((Divide(ts, ms)).ToString()))), ms) // shift to the edge of m/h/d (but not M)
        if IsTrue(IsLessThan(openingTime, since)) {
            continue
        }
        ohlcv_length := GetArrayLength(ohlcvs)
        candle := Subtract(ohlcv_length, 1)
        if IsTrue(IsTrue((IsEqual(candle, -1))) || IsTrue((IsGreaterThanOrEqual(openingTime, this.sum(ohlcvs[candle][i_timestamp], ms))))) {
            // moved to a new timeframe -> create a new candle from opening trade
            ohlcvs = appendToArray(ohlcvs,[]interface{}{openingTime, trade["price"], trade["price"], trade["price"], trade["price"], trade["amount"], 1}).([]interface{})
        } else {
            // still processing the same timeframe -> update opening trade
            addElementToObject(ohlcvs[candle], i_high, mathMax(ohlcvs[candle][i_high], trade["price"]))
            addElementToObject(ohlcvs[candle], i_low, mathMin(ohlcvs[candle][i_low], trade["price"]))
            addElementToObject(ohlcvs[candle], i_close, trade["price"])
            addElementToObject(ohlcvs[candle], i_volume, this.sum(ohlcvs[candle][i_volume], trade["amount"]))
            addElementToObject(ohlcvs[candle], i_count, this.sum(ohlcvs[candle][i_count], 1))
        }
    }
    return ohlcvs
}
func  (this *Exchange) parseTradingViewOHLCV(ohlcvs interface{}, market interface{}, timeframe string, since interface{}, limit interface{})  {
    result := this.convertTradingViewToOHLCV(ohlcvs)
    return this.parseOHLCVs(result, market, timeframe, since, limit)
}
func  (this *Exchange) editLimitBuyOrder(id string, symbol string, amount interface{}, price interface{}, parameters interface{})  {
    return await this.editLimitOrder(id, symbol, "buy", amount, price, parameters)
}
func  (this *Exchange) editLimitSellOrder(id string, symbol string, amount interface{}, price interface{}, parameters interface{})  {
    return await this.editLimitOrder(id, symbol, "sell", amount, price, parameters)
}
func  (this *Exchange) editLimitOrder(id string, symbol string, side interface{}, amount interface{}, price interface{}, parameters interface{})  {
    return await this.editOrder(id, symbol, "limit", side, amount, price, parameters)
}
func  (this *Exchange) editOrder(id string, symbol string, type interface{}, side interface{}, amount interface{}, price interface{}, parameters interface{})  {
    await this.cancelOrder(id, symbol)
    return await this.createOrder(symbol, type, side, amount, price, parameters)
}
func  (this *Exchange) editOrderWs(id string, symbol string, type interface{}, side interface{}, amount interface{}, price interface{}, parameters interface{})  {
    await this.cancelOrderWs(id, symbol)
    return await this.createOrderWs(symbol, type, side, amount, price, parameters)
}
func  (this *Exchange) fetchPermissions(parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchPermissions() is not supported yet")) 
}
func  (this *Exchange) fetchPosition(symbol string, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchPosition() is not supported yet")) 
}
func  (this *Exchange) fetchPositionWs(symbol string, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchPositionWs() is not supported yet")) 
}
func  (this *Exchange) watchPosition(symbol interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " watchPosition() is not supported yet")) 
}
func  (this *Exchange) watchPositions(symbols interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " watchPositions() is not supported yet")) 
}
func  (this *Exchange) watchPositionForSymbols(symbols interface{}, since interface{}, limit interface{}, parameters interface{})  {
    return await this.watchPositions(symbols, since, limit, parameters)
}
func  (this *Exchange) fetchPositionsForSymbol(symbol string, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchPositionsForSymbol() is not supported yet")) 
}
func  (this *Exchange) fetchPositionsForSymbolWs(symbol string, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchPositionsForSymbol() is not supported yet")) 
}
func  (this *Exchange) fetchPositions(symbols interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchPositions() is not supported yet")) 
}
func  (this *Exchange) fetchPositionsWs(symbols interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchPositions() is not supported yet")) 
}
func  (this *Exchange) fetchPositionsRisk(symbols interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchPositionsRisk() is not supported yet")) 
}
func  (this *Exchange) fetchBidsAsks(symbols interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchBidsAsks() is not supported yet")) 
}
func  (this *Exchange) fetchBorrowInterest(code interface{}, symbol interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchBorrowInterest() is not supported yet")) 
}
func  (this *Exchange) fetchLedger(code interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchLedger() is not supported yet")) 
}
func  (this *Exchange) fetchLedgerEntry(id string, code interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchLedgerEntry() is not supported yet")) 
}
func  (this *Exchange) parseBidAsk(bidask interface{}, priceKey interface{}, amountKey interface{}, countOrIdKey interface{})  {
    price := this.safeNumber(bidask, priceKey)
    amount := this.safeNumber(bidask, amountKey)
    countOrId := this.safeInteger(bidask, countOrIdKey)
    bidAsk := []interface{}{price, amount}
    if IsTrue(!IsEqual(countOrId, null)) {
        bidAsk = appendToArray(bidAsk,countOrId).([]interface{})
    }
    return bidAsk
}
func  (this *Exchange) safeCurrency(currencyId interface{}, currency interface{})  {
    if IsTrue(IsTrue((IsEqual(currencyId, null))) && IsTrue((!IsEqual(currency, null)))) {
        return currency
    }
    if IsTrue(IsTrue(IsTrue((!IsEqual(this.currencies_by_id, null))) && IsTrue((inOp(this.currencies_by_id, currencyId)))) && IsTrue((!IsEqual(this.currencies_by_id[currencyId], null)))) {
        return this.currencies_by_id[currencyId]
    }
    code := currencyId
    if IsTrue(!IsEqual(currencyId, null)) {
        code = this.commonCurrencyCode(((string)currencyId).ToUpper())
    }
    return this.safeCurrencyStructure(make(map[string]interface{}) {
        "id", currencyId,
        "code", code,
        "precision", null,
    })
}
func  (this *Exchange) safeMarket(marketId interface{}, market interface{}, delimiter interface{}, marketType interface{})  {
    result := this.safeMarketStructure(make(map[string]interface{}) {
        "symbol", marketId,
        "marketId", marketId,
    })
    if IsTrue(!IsEqual(marketId, null)) {
        if IsTrue(IsTrue((!IsEqual(this.markets_by_id, null))) && IsTrue((inOp(this.markets_by_id, marketId)))) {
            markets := this.markets_by_id[marketId]
            numMarkets := GetArrayLength(markets)
            if IsTrue(IsEqual(numMarkets, 1)) {
                return markets[0]
            } else {
                if IsTrue(IsEqual(marketType, null)) {
                    if IsTrue(IsEqual(market, null)) {
                        throw new ArgumentsRequired ((string)Add(Add(Add(this.id, " safeMarket() requires a fourth argument for "), marketId), " to disambiguate between different markets with the same market id")) 
                    } else {
                        marketType = market["type"]
                    }
                }
                for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
                    currentMarket := markets[i]
                    if IsTrue(currentMarket[marketType]) {
                        return currentMarket
                    }
                }
            }
        } else if IsTrue(IsTrue(!IsEqual(delimiter, null)) && IsTrue(!IsEqual(delimiter, ""))) {
            parts := ((string)marketId).Split(new [] {((string)delimiter)}, StringSplitOptions.None).ToList<object>()
            partsLength := GetArrayLength(parts)
            if IsTrue(IsEqual(partsLength, 2)) {
                addElementToObject(result, "baseId", this.safeString(parts, 0))
                addElementToObject(result, "quoteId", this.safeString(parts, 1))
                addElementToObject(result, "base", this.safeCurrencyCode(result["baseId"]))
                addElementToObject(result, "quote", this.safeCurrencyCode(result["quoteId"]))
                addElementToObject(result, "symbol", Add(Add(result["base"], "/"), result["quote"]))
                return result
            } else {
                return result
            }
        }
    }
    if IsTrue(!IsEqual(market, null)) {
        return market
    }
    return result
}
func  (this *Exchange) checkRequiredCredentials(error bool)  {
    /**
     * @ignore
     * @method
     * @param {boolean} error throw an error that a credential is required if true
     * @returns {boolean} true if all required credentials have been set, otherwise false or an error is thrown is param error=true
     */
    keys := new List<object>(((IDictionary<string,object>)this.requiredCredentials).Keys)
    for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
        key := keys[i]
        if IsTrue(IsTrue(this.requiredCredentials[key]) && !IsTrue(this[key])) {
            if IsTrue(error) {
                throw new AuthenticationError ((string)Add(Add(Add(this.id, " requires \""), key), "\" credential")) 
            } else {
                return false
            }
        }
    }
    return true
}
func  (this *Exchange) oath()  {
    if IsTrue(!IsEqual(this.twofa, null)) {
        return totp(this.twofa)
    } else {
        throw new ExchangeError ((string)Add(this.id, " exchange.twofa has not been set for 2FA Two-Factor Authentication")) 
    }
}
func  (this *Exchange) fetchBalance(parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchBalance() is not supported yet")) 
}
func  (this *Exchange) fetchBalanceWs(parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchBalanceWs() is not supported yet")) 
}
func  (this *Exchange) parseBalance(response interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseBalance() is not supported yet")) 
}
func  (this *Exchange) watchBalance(parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " watchBalance() is not supported yet")) 
}
func  (this *Exchange) fetchPartialBalance(part interface{}, parameters interface{})  {
    balance := await this.fetchBalance(parameters)
    return balance[part]
}
func  (this *Exchange) fetchFreeBalance(parameters interface{})  {
    return await this.fetchPartialBalance("free", parameters)
}
func  (this *Exchange) fetchUsedBalance(parameters interface{})  {
    return await this.fetchPartialBalance("used", parameters)
}
func  (this *Exchange) fetchTotalBalance(parameters interface{})  {
    return await this.fetchPartialBalance("total", parameters)
}
func  (this *Exchange) fetchStatus(parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchStatus() is not supported yet")) 
}
func  (this *Exchange) fetchTransactionFee(code string, parameters interface{})  {
    if !IsTrue(this.has["fetchTransactionFees"]) {
        throw new NotSupported ((string)Add(this.id, " fetchTransactionFee() is not supported yet")) 
    }
    return await this.fetchTransactionFees([]interface{}{code}, parameters)
}
func  (this *Exchange) fetchTransactionFees(codes interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchTransactionFees() is not supported yet")) 
}
func  (this *Exchange) fetchDepositWithdrawFees(codes interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchDepositWithdrawFees() is not supported yet")) 
}
func  (this *Exchange) fetchDepositWithdrawFee(code string, parameters interface{})  {
    if !IsTrue(this.has["fetchDepositWithdrawFees"]) {
        throw new NotSupported ((string)Add(this.id, " fetchDepositWithdrawFee() is not supported yet")) 
    }
    fees := await this.fetchDepositWithdrawFees([]interface{}{code}, parameters)
    return this.safeValue(fees, code)
}
func  (this *Exchange) getSupportedMapping(key interface{}, mapping interface{})  {
    if IsTrue(inOp(mapping, key)) {
        return mapping[key]
    } else {
        throw new NotSupported ((string)Add(Add(Add(this.id, " "), key), " does not have a value in mapping")) 
    }
}
func  (this *Exchange) fetchCrossBorrowRate(code string, parameters interface{})  {
    await this.loadMarkets()
    if !IsTrue(this.has["fetchBorrowRates"]) {
        throw new NotSupported ((string)Add(this.id, " fetchCrossBorrowRate() is not supported yet")) 
    }
    borrowRates := await this.fetchCrossBorrowRates(parameters)
    rate := this.safeValue(borrowRates, code)
    if IsTrue(IsEqual(rate, null)) {
        throw new ExchangeError ((string)Add(Add(this.id, " fetchCrossBorrowRate() could not find the borrow rate for currency code "), code)) 
    }
    return rate
}
func  (this *Exchange) fetchIsolatedBorrowRate(symbol string, parameters interface{})  {
    await this.loadMarkets()
    if !IsTrue(this.has["fetchBorrowRates"]) {
        throw new NotSupported ((string)Add(this.id, " fetchIsolatedBorrowRate() is not supported yet")) 
    }
    borrowRates := await this.fetchIsolatedBorrowRates(parameters)
    rate := this.safeDict(borrowRates, symbol)
    if IsTrue(IsEqual(rate, null)) {
        throw new ExchangeError ((string)Add(Add(this.id, " fetchIsolatedBorrowRate() could not find the borrow rate for market symbol "), symbol)) 
    }
    return rate
}
func  (this *Exchange) handleOptionAndParams(parameters interface{}, methodName string, optionName string, defaultValue interface{})  {
    // This method can be used to obtain method specific properties, i.e: this.handleOptionAndParams (params, 'fetchPosition', 'marginMode', 'isolated')
    defaultOptionName := Add("default", this.capitalize(optionName)) // we also need to check the 'defaultXyzWhatever'
    // check if params contain the key
    value := this.safeValue2(parameters, optionName, defaultOptionName)
    if IsTrue(!IsEqual(value, null)) {
        parameters = this.omit(parameters, []interface{}{optionName, defaultOptionName})
    } else {
        // handle routed methods like "watchTrades > watchTradesForSymbols" (or "watchTicker > watchTickers")
        var methodNameparametersVariable = this.handleParamString(parameters, "callerMethodName", methodName);
        methodName = ((IList<object>)methodNameparametersVariable)[0];
        parameters = ((IList<object>)methodNameparametersVariable)[1]
        // check if exchange has properties for this method
        exchangeWideMethodOptions := this.safeValue(this.options, methodName)
        if IsTrue(!IsEqual(exchangeWideMethodOptions, null)) {
            // check if the option is defined inside this method's props
            value = this.safeValue2(exchangeWideMethodOptions, optionName, defaultOptionName)
        }
        if IsTrue(IsEqual(value, null)) {
            // if it's still undefined, check if global exchange-wide option exists
            value = this.safeValue2(this.options, optionName, defaultOptionName)
        }
        // if it's still undefined, use the default value
        value = ((bool) IsTrue((!IsEqual(value, null)))) ? value : defaultValue
    }
    return []interface{}{value, parameters}
}
func  (this *Exchange) handleOptionAndParams2(parameters interface{}, methodName1 string, optionName1 string, optionName2 string, defaultValue interface{})  {
    value := null
    var valueparametersVariable = this.handleOptionAndParams(parameters, methodName1, optionName1, defaultValue);
    value = ((IList<object>)valueparametersVariable)[0];
    parameters = ((IList<object>)valueparametersVariable)[1]
    // if still undefined, try optionName2
    value2 := null
    var value2parametersVariable = this.handleOptionAndParams(parameters, methodName1, optionName2, value);
    value2 = ((IList<object>)value2parametersVariable)[0];
    parameters = ((IList<object>)value2parametersVariable)[1]
    return []interface{}{value2, parameters}
}
func  (this *Exchange) handleOption(methodName string, optionName string, defaultValue interface{})  {
    // eslint-disable-next-line no-unused-vars
    []interface{}{result, empty} := this.handleOptionAndParams(make(map[string]interface{}) {}, methodName, optionName, defaultValue)
    return result
}
func  (this *Exchange) handleMarketTypeAndParams(methodName string, market interface{}, parameters interface{}, defaultValue interface{})  {
    /**
     * @ignore
     * @method
     * @name exchange#handleMarketTypeAndParams
     * @param methodName the method calling handleMarketTypeAndParams
     * @param {Market} market
     * @param {object} params
     * @param {string} [params.type] type assigned by user
     * @param {string} [params.defaultType] same as params.type
     * @param {string} [defaultValue] assigned programatically in the method calling handleMarketTypeAndParams
     * @returns {[string, object]} the market type and params with type and defaultType omitted
     */
    defaultType := this.safeString2(this.options, "defaultType", "type", "spot")
    if IsTrue(IsEqual(defaultValue, null)) {
        defaultValue = defaultType
    }
    methodOptions := this.safeDict(this.options, methodName)
    methodType := defaultValue
    if IsTrue(!IsEqual(methodOptions, null)) {
        if IsTrue((methodOptions is string)) {
            methodType = methodOptions
        } else {
            methodType = this.safeString2(methodOptions, "defaultType", "type", methodType)
        }
    }
    marketType := ((bool) IsTrue((IsEqual(market, null)))) ? methodType : market["type"]
    type := this.safeString2(parameters, "defaultType", "type", marketType)
    parameters = this.omit(parameters, []interface{}{"defaultType", "type"})
    return []interface{}{type, parameters}
}
func  (this *Exchange) handleSubTypeAndParams(methodName string, market interface{}, parameters interface{}, defaultValue interface{})  {
    subType := null
    // if set in params, it takes precedence
    subTypeInParams := this.safeString2(parameters, "subType", "defaultSubType")
    // avoid omitting if it's not present
    if IsTrue(!IsEqual(subTypeInParams, null)) {
        subType = subTypeInParams
        parameters = this.omit(parameters, []interface{}{"subType", "defaultSubType"})
    } else {
        // at first, check from market object
        if IsTrue(!IsEqual(market, null)) {
            if IsTrue(market["linear"]) {
                subType = "linear"
            } else if IsTrue(market["inverse"]) {
                subType = "inverse"
            }
        }
        // if it was not defined in market object
        if IsTrue(IsEqual(subType, null)) {
            values := this.handleOptionAndParams(make(map[string]interface{}) {}, methodName, "subType", defaultValue) // no need to re-test params here
            subType = values[0]
        }
    }
    return []interface{}{subType, parameters}
}
func  (this *Exchange) handleMarginModeAndParams(methodName string, parameters interface{}, defaultValue interface{})  {
    /**
     * @ignore
     * @method
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Array} the marginMode in lowercase as specified by params["marginMode"], params["defaultMarginMode"] this.options["marginMode"] or this.options["defaultMarginMode"]
     */
    return this.handleOptionAndParams(parameters, methodName, "marginMode", defaultValue)
}
func  (this *Exchange) throwExactlyMatchedException(exact interface{}, str interface{}, message interface{})  {
    if IsTrue(IsEqual(str, null)) {
        return
    }
    if IsTrue(inOp(exact, str)) {
        throwDynamicException(exact[str], message);
    }
}
func  (this *Exchange) throwBroadlyMatchedException(broad interface{}, str interface{}, message interface{})  {
    broadKey := this.findBroadlyMatchedKey(broad, str)
    if IsTrue(!IsEqual(broadKey, null)) {
        throwDynamicException(broad[broadKey], message);
    }
}
func  (this *Exchange) findBroadlyMatchedKey(broad interface{}, str interface{})  {
    // a helper for matching error strings exactly vs broadly
    keys := new List<object>(((IDictionary<string,object>)broad).Keys)
    for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
        key := keys[i]
        if IsTrue(!IsEqual(str, null)) {
            if IsTrue(IsGreaterThanOrEqual(GetIndexOf(str, key), 0)) {
                return key
            }
        }
    }
    return null
}
func  (this *Exchange) handleErrors(statusCode interface{}, statusText string, url string, method string, responseHeaders interface{}, responseBody string, response interface{}, requestHeaders interface{}, requestBody interface{})  {
    // it is a stub method that must be overrided in the derived exchange classes
    // throw new NotSupported (this.id + ' handleErrors() not implemented yet');
    return null
}
func  (this *Exchange) calculateRateLimiterCost(api interface{}, method interface{}, path interface{}, parameters interface{}, config interface{})  {
    return this.safeValue(config, "cost", 1)
}
func  (this *Exchange) fetchTicker(symbol string, parameters interface{})  {
    if IsTrue(this.has["fetchTickers"]) {
        await this.loadMarkets()
        market := this.market(symbol)
        symbol = market["symbol"]
        tickers := await this.fetchTickers([]interface{}{symbol}, parameters)
        ticker := this.safeDict(tickers, symbol)
        if IsTrue(IsEqual(ticker, null)) {
            throw new NullResponse ((string)Add(Add(this.id, " fetchTickers() could not find a ticker for "), symbol)) 
        } else {
            return ticker
        }
    } else {
        throw new NotSupported ((string)Add(this.id, " fetchTicker() is not supported yet")) 
    }
}
func  (this *Exchange) fetchTickerWs(symbol string, parameters interface{})  {
    if IsTrue(this.has["fetchTickersWs"]) {
        await this.loadMarkets()
        market := this.market(symbol)
        symbol = market["symbol"]
        tickers := await this.fetchTickerWs(symbol, parameters)
        ticker := this.safeDict(tickers, symbol)
        if IsTrue(IsEqual(ticker, null)) {
            throw new NullResponse ((string)Add(Add(this.id, " fetchTickers() could not find a ticker for "), symbol)) 
        } else {
            return ticker
        }
    } else {
        throw new NotSupported ((string)Add(this.id, " fetchTicker() is not supported yet")) 
    }
}
func  (this *Exchange) watchTicker(symbol string, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " watchTicker() is not supported yet")) 
}
func  (this *Exchange) fetchTickers(symbols interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchTickers() is not supported yet")) 
}
func  (this *Exchange) fetchTickersWs(symbols interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchTickers() is not supported yet")) 
}
func  (this *Exchange) fetchOrderBooks(symbols interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchOrderBooks() is not supported yet")) 
}
func  (this *Exchange) watchBidsAsks(symbols interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " watchBidsAsks() is not supported yet")) 
}
func  (this *Exchange) watchTickers(symbols interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " watchTickers() is not supported yet")) 
}
func  (this *Exchange) fetchOrder(id string, symbol interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchOrder() is not supported yet")) 
}
func  (this *Exchange) fetchOrderWs(id string, symbol interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchOrderWs() is not supported yet")) 
}
func  (this *Exchange) fetchOrderStatus(id string, symbol interface{}, parameters interface{})  {
    // TODO: TypeScript: change method signature by replacing
    // Promise<string> with Promise<Order['status']>.
    order := await this.fetchOrder(id, symbol, parameters)
    return order["status"]
}
func  (this *Exchange) fetchUnifiedOrder(order interface{}, parameters interface{})  {
    return await this.fetchOrder(this.safeString(order, "id"), this.safeString(order, "symbol"), parameters)
}
func  (this *Exchange) createOrder(symbol string, type interface{}, side interface{}, amount interface{}, price interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " createOrder() is not supported yet")) 
}
func  (this *Exchange) createTrailingAmountOrder(symbol string, type interface{}, side interface{}, amount interface{}, price interface{}, trailingAmount interface{}, trailingTriggerPrice interface{}, parameters interface{})  {
    /**
     * @method
     * @name createTrailingAmountOrder
     * @description create a trailing order by providing the symbol, type, side, amount, price and trailingAmount
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much you want to trade in units of the base currency, or number of contracts
     * @param {float} [price] the price for the order to be filled at, in units of the quote currency, ignored in market orders
     * @param {float} trailingAmount the quote amount to trail away from the current market price
     * @param {float} [trailingTriggerPrice] the price to activate a trailing order, default uses the price argument
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    if IsTrue(IsEqual(trailingAmount, null)) {
        throw new ArgumentsRequired ((string)Add(this.id, " createTrailingAmountOrder() requires a trailingAmount argument")) 
    }
    addElementToObject(parameters, "trailingAmount", trailingAmount)
    if IsTrue(!IsEqual(trailingTriggerPrice, null)) {
        addElementToObject(parameters, "trailingTriggerPrice", trailingTriggerPrice)
    }
    if IsTrue(this.has["createTrailingAmountOrder"]) {
        return await this.createOrder(symbol, type, side, amount, price, parameters)
    }
    throw new NotSupported ((string)Add(this.id, " createTrailingAmountOrder() is not supported yet")) 
}
func  (this *Exchange) createTrailingAmountOrderWs(symbol string, type interface{}, side interface{}, amount interface{}, price interface{}, trailingAmount interface{}, trailingTriggerPrice interface{}, parameters interface{})  {
    /**
     * @method
     * @name createTrailingAmountOrderWs
     * @description create a trailing order by providing the symbol, type, side, amount, price and trailingAmount
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much you want to trade in units of the base currency, or number of contracts
     * @param {float} [price] the price for the order to be filled at, in units of the quote currency, ignored in market orders
     * @param {float} trailingAmount the quote amount to trail away from the current market price
     * @param {float} [trailingTriggerPrice] the price to activate a trailing order, default uses the price argument
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    if IsTrue(IsEqual(trailingAmount, null)) {
        throw new ArgumentsRequired ((string)Add(this.id, " createTrailingAmountOrderWs() requires a trailingAmount argument")) 
    }
    addElementToObject(parameters, "trailingAmount", trailingAmount)
    if IsTrue(!IsEqual(trailingTriggerPrice, null)) {
        addElementToObject(parameters, "trailingTriggerPrice", trailingTriggerPrice)
    }
    if IsTrue(this.has["createTrailingAmountOrderWs"]) {
        return await this.createOrderWs(symbol, type, side, amount, price, parameters)
    }
    throw new NotSupported ((string)Add(this.id, " createTrailingAmountOrderWs() is not supported yet")) 
}
func  (this *Exchange) createTrailingPercentOrder(symbol string, type interface{}, side interface{}, amount interface{}, price interface{}, trailingPercent interface{}, trailingTriggerPrice interface{}, parameters interface{})  {
    /**
     * @method
     * @name createTrailingPercentOrder
     * @description create a trailing order by providing the symbol, type, side, amount, price and trailingPercent
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much you want to trade in units of the base currency, or number of contracts
     * @param {float} [price] the price for the order to be filled at, in units of the quote currency, ignored in market orders
     * @param {float} trailingPercent the percent to trail away from the current market price
     * @param {float} [trailingTriggerPrice] the price to activate a trailing order, default uses the price argument
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    if IsTrue(IsEqual(trailingPercent, null)) {
        throw new ArgumentsRequired ((string)Add(this.id, " createTrailingPercentOrder() requires a trailingPercent argument")) 
    }
    addElementToObject(parameters, "trailingPercent", trailingPercent)
    if IsTrue(!IsEqual(trailingTriggerPrice, null)) {
        addElementToObject(parameters, "trailingTriggerPrice", trailingTriggerPrice)
    }
    if IsTrue(this.has["createTrailingPercentOrder"]) {
        return await this.createOrder(symbol, type, side, amount, price, parameters)
    }
    throw new NotSupported ((string)Add(this.id, " createTrailingPercentOrder() is not supported yet")) 
}
func  (this *Exchange) createTrailingPercentOrderWs(symbol string, type interface{}, side interface{}, amount interface{}, price interface{}, trailingPercent interface{}, trailingTriggerPrice interface{}, parameters interface{})  {
    /**
     * @method
     * @name createTrailingPercentOrderWs
     * @description create a trailing order by providing the symbol, type, side, amount, price and trailingPercent
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much you want to trade in units of the base currency, or number of contracts
     * @param {float} [price] the price for the order to be filled at, in units of the quote currency, ignored in market orders
     * @param {float} trailingPercent the percent to trail away from the current market price
     * @param {float} [trailingTriggerPrice] the price to activate a trailing order, default uses the price argument
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    if IsTrue(IsEqual(trailingPercent, null)) {
        throw new ArgumentsRequired ((string)Add(this.id, " createTrailingPercentOrderWs() requires a trailingPercent argument")) 
    }
    addElementToObject(parameters, "trailingPercent", trailingPercent)
    if IsTrue(!IsEqual(trailingTriggerPrice, null)) {
        addElementToObject(parameters, "trailingTriggerPrice", trailingTriggerPrice)
    }
    if IsTrue(this.has["createTrailingPercentOrderWs"]) {
        return await this.createOrderWs(symbol, type, side, amount, price, parameters)
    }
    throw new NotSupported ((string)Add(this.id, " createTrailingPercentOrderWs() is not supported yet")) 
}
func  (this *Exchange) createMarketOrderWithCost(symbol string, side interface{}, cost interface{}, parameters interface{})  {
    /**
     * @method
     * @name createMarketOrderWithCost
     * @description create a market order by providing the symbol, side and cost
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} side 'buy' or 'sell'
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    if IsTrue(IsTrue(this.has["createMarketOrderWithCost"]) || IsTrue((IsTrue(this.has["createMarketBuyOrderWithCost"]) && IsTrue(this.has["createMarketSellOrderWithCost"])))) {
        return await this.createOrder(symbol, "market", side, cost, 1, parameters)
    }
    throw new NotSupported ((string)Add(this.id, " createMarketOrderWithCost() is not supported yet")) 
}
func  (this *Exchange) createMarketBuyOrderWithCost(symbol string, cost interface{}, parameters interface{})  {
    /**
     * @method
     * @name createMarketBuyOrderWithCost
     * @description create a market buy order by providing the symbol and cost
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    if IsTrue(IsTrue(this.options["createMarketBuyOrderRequiresPrice"]) || IsTrue(this.has["createMarketBuyOrderWithCost"])) {
        return await this.createOrder(symbol, "market", "buy", cost, 1, parameters)
    }
    throw new NotSupported ((string)Add(this.id, " createMarketBuyOrderWithCost() is not supported yet")) 
}
func  (this *Exchange) createMarketSellOrderWithCost(symbol string, cost interface{}, parameters interface{})  {
    /**
     * @method
     * @name createMarketSellOrderWithCost
     * @description create a market sell order by providing the symbol and cost
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    if IsTrue(IsTrue(this.options["createMarketSellOrderRequiresPrice"]) || IsTrue(this.has["createMarketSellOrderWithCost"])) {
        return await this.createOrder(symbol, "market", "sell", cost, 1, parameters)
    }
    throw new NotSupported ((string)Add(this.id, " createMarketSellOrderWithCost() is not supported yet")) 
}
func  (this *Exchange) createMarketOrderWithCostWs(symbol string, side interface{}, cost interface{}, parameters interface{})  {
    /**
     * @method
     * @name createMarketOrderWithCostWs
     * @description create a market order by providing the symbol, side and cost
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} side 'buy' or 'sell'
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    if IsTrue(IsTrue(this.has["createMarketOrderWithCostWs"]) || IsTrue((IsTrue(this.has["createMarketBuyOrderWithCostWs"]) && IsTrue(this.has["createMarketSellOrderWithCostWs"])))) {
        return await this.createOrderWs(symbol, "market", side, cost, 1, parameters)
    }
    throw new NotSupported ((string)Add(this.id, " createMarketOrderWithCostWs() is not supported yet")) 
}
func  (this *Exchange) createTriggerOrder(symbol string, type interface{}, side interface{}, amount interface{}, price interface{}, triggerPrice interface{}, parameters interface{})  {
    /**
     * @method
     * @name createTriggerOrder
     * @description create a trigger stop order (type 1)
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much you want to trade in units of the base currency or the number of contracts
     * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
     * @param {float} triggerPrice the price to trigger the stop order, in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    if IsTrue(IsEqual(triggerPrice, null)) {
        throw new ArgumentsRequired ((string)Add(this.id, " createTriggerOrder() requires a triggerPrice argument")) 
    }
    addElementToObject(parameters, "triggerPrice", triggerPrice)
    if IsTrue(this.has["createTriggerOrder"]) {
        return await this.createOrder(symbol, type, side, amount, price, parameters)
    }
    throw new NotSupported ((string)Add(this.id, " createTriggerOrder() is not supported yet")) 
}
func  (this *Exchange) createTriggerOrderWs(symbol string, type interface{}, side interface{}, amount interface{}, price interface{}, triggerPrice interface{}, parameters interface{})  {
    /**
     * @method
     * @name createTriggerOrderWs
     * @description create a trigger stop order (type 1)
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much you want to trade in units of the base currency or the number of contracts
     * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
     * @param {float} triggerPrice the price to trigger the stop order, in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    if IsTrue(IsEqual(triggerPrice, null)) {
        throw new ArgumentsRequired ((string)Add(this.id, " createTriggerOrderWs() requires a triggerPrice argument")) 
    }
    addElementToObject(parameters, "triggerPrice", triggerPrice)
    if IsTrue(this.has["createTriggerOrderWs"]) {
        return await this.createOrderWs(symbol, type, side, amount, price, parameters)
    }
    throw new NotSupported ((string)Add(this.id, " createTriggerOrderWs() is not supported yet")) 
}
func  (this *Exchange) createStopLossOrder(symbol string, type interface{}, side interface{}, amount interface{}, price interface{}, stopLossPrice interface{}, parameters interface{})  {
    /**
     * @method
     * @name createStopLossOrder
     * @description create a trigger stop loss order (type 2)
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much you want to trade in units of the base currency or the number of contracts
     * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
     * @param {float} stopLossPrice the price to trigger the stop loss order, in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    if IsTrue(IsEqual(stopLossPrice, null)) {
        throw new ArgumentsRequired ((string)Add(this.id, " createStopLossOrder() requires a stopLossPrice argument")) 
    }
    addElementToObject(parameters, "stopLossPrice", stopLossPrice)
    if IsTrue(this.has["createStopLossOrder"]) {
        return await this.createOrder(symbol, type, side, amount, price, parameters)
    }
    throw new NotSupported ((string)Add(this.id, " createStopLossOrder() is not supported yet")) 
}
func  (this *Exchange) createStopLossOrderWs(symbol string, type interface{}, side interface{}, amount interface{}, price interface{}, stopLossPrice interface{}, parameters interface{})  {
    /**
     * @method
     * @name createStopLossOrderWs
     * @description create a trigger stop loss order (type 2)
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much you want to trade in units of the base currency or the number of contracts
     * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
     * @param {float} stopLossPrice the price to trigger the stop loss order, in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    if IsTrue(IsEqual(stopLossPrice, null)) {
        throw new ArgumentsRequired ((string)Add(this.id, " createStopLossOrderWs() requires a stopLossPrice argument")) 
    }
    addElementToObject(parameters, "stopLossPrice", stopLossPrice)
    if IsTrue(this.has["createStopLossOrderWs"]) {
        return await this.createOrderWs(symbol, type, side, amount, price, parameters)
    }
    throw new NotSupported ((string)Add(this.id, " createStopLossOrderWs() is not supported yet")) 
}
func  (this *Exchange) createTakeProfitOrder(symbol string, type interface{}, side interface{}, amount interface{}, price interface{}, takeProfitPrice interface{}, parameters interface{})  {
    /**
     * @method
     * @name createTakeProfitOrder
     * @description create a trigger take profit order (type 2)
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much you want to trade in units of the base currency or the number of contracts
     * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
     * @param {float} takeProfitPrice the price to trigger the take profit order, in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    if IsTrue(IsEqual(takeProfitPrice, null)) {
        throw new ArgumentsRequired ((string)Add(this.id, " createTakeProfitOrder() requires a takeProfitPrice argument")) 
    }
    addElementToObject(parameters, "takeProfitPrice", takeProfitPrice)
    if IsTrue(this.has["createTakeProfitOrder"]) {
        return await this.createOrder(symbol, type, side, amount, price, parameters)
    }
    throw new NotSupported ((string)Add(this.id, " createTakeProfitOrder() is not supported yet")) 
}
func  (this *Exchange) createTakeProfitOrderWs(symbol string, type interface{}, side interface{}, amount interface{}, price interface{}, takeProfitPrice interface{}, parameters interface{})  {
    /**
     * @method
     * @name createTakeProfitOrderWs
     * @description create a trigger take profit order (type 2)
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much you want to trade in units of the base currency or the number of contracts
     * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
     * @param {float} takeProfitPrice the price to trigger the take profit order, in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    if IsTrue(IsEqual(takeProfitPrice, null)) {
        throw new ArgumentsRequired ((string)Add(this.id, " createTakeProfitOrderWs() requires a takeProfitPrice argument")) 
    }
    addElementToObject(parameters, "takeProfitPrice", takeProfitPrice)
    if IsTrue(this.has["createTakeProfitOrderWs"]) {
        return await this.createOrderWs(symbol, type, side, amount, price, parameters)
    }
    throw new NotSupported ((string)Add(this.id, " createTakeProfitOrderWs() is not supported yet")) 
}
func  (this *Exchange) createOrderWithTakeProfitAndStopLoss(symbol string, type interface{}, side interface{}, amount interface{}, price interface{}, takeProfit interface{}, stopLoss interface{}, parameters interface{})  {
    /**
     * @method
     * @name createOrderWithTakeProfitAndStopLoss
     * @description create an order with a stop loss or take profit attached (type 3)
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much you want to trade in units of the base currency or the number of contracts
     * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
     * @param {float} [takeProfit] the take profit price, in units of the quote currency
     * @param {float} [stopLoss] the stop loss price, in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.takeProfitType] *not available on all exchanges* 'limit' or 'market'
     * @param {string} [params.stopLossType] *not available on all exchanges* 'limit' or 'market'
     * @param {string} [params.takeProfitPriceType] *not available on all exchanges* 'last', 'mark' or 'index'
     * @param {string} [params.stopLossPriceType] *not available on all exchanges* 'last', 'mark' or 'index'
     * @param {float} [params.takeProfitLimitPrice] *not available on all exchanges* limit price for a limit take profit order
     * @param {float} [params.stopLossLimitPrice] *not available on all exchanges* stop loss for a limit stop loss order
     * @param {float} [params.takeProfitAmount] *not available on all exchanges* the amount for a take profit
     * @param {float} [params.stopLossAmount] *not available on all exchanges* the amount for a stop loss
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    parameters = this.setTakeProfitAndStopLossParams(symbol, type, side, amount, price, takeProfit, stopLoss, parameters)
    if IsTrue(this.has["createOrderWithTakeProfitAndStopLoss"]) {
        return await this.createOrder(symbol, type, side, amount, price, parameters)
    }
    throw new NotSupported ((string)Add(this.id, " createOrderWithTakeProfitAndStopLoss() is not supported yet")) 
}
func  (this *Exchange) setTakeProfitAndStopLossParams(symbol string, type interface{}, side interface{}, amount interface{}, price interface{}, takeProfit interface{}, stopLoss interface{}, parameters interface{})  {
    if IsTrue(IsTrue((IsEqual(takeProfit, null))) && IsTrue((IsEqual(stopLoss, null)))) {
        throw new ArgumentsRequired ((string)Add(this.id, " createOrderWithTakeProfitAndStopLoss() requires either a takeProfit or stopLoss argument")) 
    }
    if IsTrue(!IsEqual(takeProfit, null)) {
        addElementToObject(parameters, "takeProfit", make(map[string]interface{}) {
    "triggerPrice", takeProfit,
})
    }
    if IsTrue(!IsEqual(stopLoss, null)) {
        addElementToObject(parameters, "stopLoss", make(map[string]interface{}) {
    "triggerPrice", stopLoss,
})
    }
    takeProfitType := this.safeString(parameters, "takeProfitType")
    takeProfitPriceType := this.safeString(parameters, "takeProfitPriceType")
    takeProfitLimitPrice := this.safeString(parameters, "takeProfitLimitPrice")
    takeProfitAmount := this.safeString(parameters, "takeProfitAmount")
    stopLossType := this.safeString(parameters, "stopLossType")
    stopLossPriceType := this.safeString(parameters, "stopLossPriceType")
    stopLossLimitPrice := this.safeString(parameters, "stopLossLimitPrice")
    stopLossAmount := this.safeString(parameters, "stopLossAmount")
    if IsTrue(!IsEqual(takeProfitType, null)) {
        addElementToObject(parameters["takeProfit"], "type", takeProfitType)
    }
    if IsTrue(!IsEqual(takeProfitPriceType, null)) {
        addElementToObject(parameters["takeProfit"], "priceType", takeProfitPriceType)
    }
    if IsTrue(!IsEqual(takeProfitLimitPrice, null)) {
        addElementToObject(parameters["takeProfit"], "price", this.parseToNumeric(takeProfitLimitPrice))
    }
    if IsTrue(!IsEqual(takeProfitAmount, null)) {
        addElementToObject(parameters["takeProfit"], "amount", this.parseToNumeric(takeProfitAmount))
    }
    if IsTrue(!IsEqual(stopLossType, null)) {
        addElementToObject(parameters["stopLoss"], "type", stopLossType)
    }
    if IsTrue(!IsEqual(stopLossPriceType, null)) {
        addElementToObject(parameters["stopLoss"], "priceType", stopLossPriceType)
    }
    if IsTrue(!IsEqual(stopLossLimitPrice, null)) {
        addElementToObject(parameters["stopLoss"], "price", this.parseToNumeric(stopLossLimitPrice))
    }
    if IsTrue(!IsEqual(stopLossAmount, null)) {
        addElementToObject(parameters["stopLoss"], "amount", this.parseToNumeric(stopLossAmount))
    }
    parameters = this.omit(parameters, []interface{}{"takeProfitType", "takeProfitPriceType", "takeProfitLimitPrice", "takeProfitAmount", "stopLossType", "stopLossPriceType", "stopLossLimitPrice", "stopLossAmount"})
    return parameters
}
func  (this *Exchange) createOrderWithTakeProfitAndStopLossWs(symbol string, type interface{}, side interface{}, amount interface{}, price interface{}, takeProfit interface{}, stopLoss interface{}, parameters interface{})  {
    /**
     * @method
     * @name createOrderWithTakeProfitAndStopLossWs
     * @description create an order with a stop loss or take profit attached (type 3)
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much you want to trade in units of the base currency or the number of contracts
     * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
     * @param {float} [takeProfit] the take profit price, in units of the quote currency
     * @param {float} [stopLoss] the stop loss price, in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.takeProfitType] *not available on all exchanges* 'limit' or 'market'
     * @param {string} [params.stopLossType] *not available on all exchanges* 'limit' or 'market'
     * @param {string} [params.takeProfitPriceType] *not available on all exchanges* 'last', 'mark' or 'index'
     * @param {string} [params.stopLossPriceType] *not available on all exchanges* 'last', 'mark' or 'index'
     * @param {float} [params.takeProfitLimitPrice] *not available on all exchanges* limit price for a limit take profit order
     * @param {float} [params.stopLossLimitPrice] *not available on all exchanges* stop loss for a limit stop loss order
     * @param {float} [params.takeProfitAmount] *not available on all exchanges* the amount for a take profit
     * @param {float} [params.stopLossAmount] *not available on all exchanges* the amount for a stop loss
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    parameters = this.setTakeProfitAndStopLossParams(symbol, type, side, amount, price, takeProfit, stopLoss, parameters)
    if IsTrue(this.has["createOrderWithTakeProfitAndStopLossWs"]) {
        return await this.createOrderWs(symbol, type, side, amount, price, parameters)
    }
    throw new NotSupported ((string)Add(this.id, " createOrderWithTakeProfitAndStopLossWs() is not supported yet")) 
}
func  (this *Exchange) createOrders(orders interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " createOrders() is not supported yet")) 
}
func  (this *Exchange) createOrderWs(symbol string, type interface{}, side interface{}, amount interface{}, price interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " createOrderWs() is not supported yet")) 
}
func  (this *Exchange) cancelOrder(id string, symbol interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " cancelOrder() is not supported yet")) 
}
func  (this *Exchange) cancelOrderWs(id string, symbol interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " cancelOrderWs() is not supported yet")) 
}
func  (this *Exchange) cancelOrdersWs(ids interface{}, symbol interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " cancelOrdersWs() is not supported yet")) 
}
func  (this *Exchange) cancelAllOrders(symbol interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " cancelAllOrders() is not supported yet")) 
}
func  (this *Exchange) cancelAllOrdersAfter(timeout interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " cancelAllOrdersAfter() is not supported yet")) 
}
func  (this *Exchange) cancelOrdersForSymbols(orders interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " cancelOrdersForSymbols() is not supported yet")) 
}
func  (this *Exchange) cancelAllOrdersWs(symbol interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " cancelAllOrdersWs() is not supported yet")) 
}
func  (this *Exchange) cancelUnifiedOrder(order interface{}, parameters interface{})  {
    return this.cancelOrder(this.safeString(order, "id"), this.safeString(order, "symbol"), parameters)
}
func  (this *Exchange) fetchOrders(symbol interface{}, since interface{}, limit interface{}, parameters interface{})  {
    if IsTrue(IsTrue(this.has["fetchOpenOrders"]) && IsTrue(this.has["fetchClosedOrders"])) {
        throw new NotSupported ((string)Add(this.id, " fetchOrders() is not supported yet, consider using fetchOpenOrders() and fetchClosedOrders() instead")) 
    }
    throw new NotSupported ((string)Add(this.id, " fetchOrders() is not supported yet")) 
}
func  (this *Exchange) fetchOrdersWs(symbol interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchOrdersWs() is not supported yet")) 
}
func  (this *Exchange) fetchOrderTrades(id string, symbol interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchOrderTrades() is not supported yet")) 
}
func  (this *Exchange) watchOrders(symbol interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " watchOrders() is not supported yet")) 
}
func  (this *Exchange) fetchOpenOrders(symbol interface{}, since interface{}, limit interface{}, parameters interface{})  {
    if IsTrue(this.has["fetchOrders"]) {
        orders := await this.fetchOrders(symbol, since, limit, parameters)
        return this.filterBy(orders, "status", "open")
    }
    throw new NotSupported ((string)Add(this.id, " fetchOpenOrders() is not supported yet")) 
}
func  (this *Exchange) fetchOpenOrdersWs(symbol interface{}, since interface{}, limit interface{}, parameters interface{})  {
    if IsTrue(this.has["fetchOrdersWs"]) {
        orders := await this.fetchOrdersWs(symbol, since, limit, parameters)
        return this.filterBy(orders, "status", "open")
    }
    throw new NotSupported ((string)Add(this.id, " fetchOpenOrdersWs() is not supported yet")) 
}
func  (this *Exchange) fetchClosedOrders(symbol interface{}, since interface{}, limit interface{}, parameters interface{})  {
    if IsTrue(this.has["fetchOrders"]) {
        orders := await this.fetchOrders(symbol, since, limit, parameters)
        return this.filterBy(orders, "status", "closed")
    }
    throw new NotSupported ((string)Add(this.id, " fetchClosedOrders() is not supported yet")) 
}
func  (this *Exchange) fetchCanceledAndClosedOrders(symbol interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchCanceledAndClosedOrders() is not supported yet")) 
}
func  (this *Exchange) fetchClosedOrdersWs(symbol interface{}, since interface{}, limit interface{}, parameters interface{})  {
    if IsTrue(this.has["fetchOrdersWs"]) {
        orders := await this.fetchOrdersWs(symbol, since, limit, parameters)
        return this.filterBy(orders, "status", "closed")
    }
    throw new NotSupported ((string)Add(this.id, " fetchClosedOrdersWs() is not supported yet")) 
}
func  (this *Exchange) fetchMyTrades(symbol interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchMyTrades() is not supported yet")) 
}
func  (this *Exchange) fetchMyLiquidations(symbol interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchMyLiquidations() is not supported yet")) 
}
func  (this *Exchange) fetchLiquidations(symbol string, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchLiquidations() is not supported yet")) 
}
func  (this *Exchange) fetchMyTradesWs(symbol interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchMyTradesWs() is not supported yet")) 
}
func  (this *Exchange) watchMyTrades(symbol interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " watchMyTrades() is not supported yet")) 
}
func  (this *Exchange) fetchGreeks(symbol string, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchGreeks() is not supported yet")) 
}
func  (this *Exchange) fetchOptionChain(code string, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchOptionChain() is not supported yet")) 
}
func  (this *Exchange) fetchOption(symbol string, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchOption() is not supported yet")) 
}
func  (this *Exchange) fetchConvertQuote(fromCode string, toCode string, amount interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchConvertQuote() is not supported yet")) 
}
func  (this *Exchange) fetchDepositsWithdrawals(code interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchDepositsWithdrawals() is not supported yet")) 
}
func  (this *Exchange) fetchDeposits(symbol interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchDeposits() is not supported yet")) 
}
func  (this *Exchange) fetchWithdrawals(symbol interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchWithdrawals() is not supported yet")) 
}
func  (this *Exchange) fetchDepositsWs(code interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchDepositsWs() is not supported yet")) 
}
func  (this *Exchange) fetchWithdrawalsWs(code interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchWithdrawalsWs() is not supported yet")) 
}
func  (this *Exchange) fetchFundingRateHistory(symbol interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchFundingRateHistory() is not supported yet")) 
}
func  (this *Exchange) fetchFundingHistory(symbol interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchFundingHistory() is not supported yet")) 
}
func  (this *Exchange) closePosition(symbol string, side interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " closePosition() is not supported yet")) 
}
func  (this *Exchange) closeAllPositions(parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " closeAllPositions() is not supported yet")) 
}
func  (this *Exchange) fetchL3OrderBook(symbol string, limit interface{}, parameters interface{})  {
    throw new BadRequest ((string)Add(this.id, " fetchL3OrderBook() is not supported yet")) 
}
func  (this *Exchange) parseLastPrice(price interface{}, market interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseLastPrice() is not supported yet")) 
}
func  (this *Exchange) fetchDepositAddress(code string, parameters interface{})  {
    if IsTrue(this.has["fetchDepositAddresses"]) {
        depositAddresses := await this.fetchDepositAddresses([]interface{}{code}, parameters)
        depositAddress := this.safeValue(depositAddresses, code)
        if IsTrue(IsEqual(depositAddress, null)) {
            throw new InvalidAddress ((string)Add(Add(Add(this.id, " fetchDepositAddress() could not find a deposit address for "), code), ", make sure you have created a corresponding deposit address in your wallet on the exchange website")) 
        } else {
            return depositAddress
        }
    } else if IsTrue(this.has["fetchDepositAddressesByNetwork"]) {
        network := this.safeString(parameters, "network")
        parameters = this.omit(parameters, "network")
        addressStructures := await this.fetchDepositAddressesByNetwork(code, parameters)
        if IsTrue(!IsEqual(network, null)) {
            return this.safeDict(addressStructures, network)
        } else {
            keys := new List<object>(((IDictionary<string,object>)addressStructures).Keys)
            key := this.safeString(keys, 0)
            return this.safeDict(addressStructures, key)
        }
    } else {
        throw new NotSupported ((string)Add(this.id, " fetchDepositAddress() is not supported yet")) 
    }
}
func  (this *Exchange) account()  {
    return make(map[string]interface{}) {
        "free", null,
        "used", null,
        "total", null,
    }
}
func  (this *Exchange) commonCurrencyCode(code string)  {
    if !IsTrue(this.substituteCommonCurrencyCodes) {
        return code
    }
    return this.safeString(this.commonCurrencies, code, code)
}
func  (this *Exchange) currency(code string)  {
    if IsTrue(IsEqual(this.currencies, null)) {
        throw new ExchangeError ((string)Add(this.id, " currencies not loaded")) 
    }
    if IsTrue((code is string)) {
        if IsTrue(inOp(this.currencies, code)) {
            return this.currencies[code]
        } else if IsTrue(inOp(this.currencies_by_id, code)) {
            return this.currencies_by_id[code]
        }
    }
    throw new ExchangeError ((string)Add(Add(this.id, " does not have currency code "), code)) 
}
func  (this *Exchange) market(symbol string)  {
    if IsTrue(IsEqual(this.markets, null)) {
        throw new ExchangeError ((string)Add(this.id, " markets not loaded")) 
    }
    if IsTrue(inOp(this.markets, symbol)) {
        return this.markets[symbol]
    } else if IsTrue(inOp(this.markets_by_id, symbol)) {
        markets := this.markets_by_id[symbol]
        defaultType := this.safeString2(this.options, "defaultType", "defaultSubType", "spot")
        for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
            market := markets[i]
            if IsTrue(market[defaultType]) {
                return market
            }
        }
        return markets[0]
    } else if IsTrue(IsTrue(IsTrue(IsTrue((((string)symbol).EndsWith(((string)"-C")))) || IsTrue((((string)symbol).EndsWith(((string)"-P"))))) || IsTrue((((string)symbol).StartsWith(((string)"C-"))))) || IsTrue((((string)symbol).StartsWith(((string)"P-"))))) {
        return this.createExpiredOptionMarket(symbol)
    }
    throw new BadSymbol ((string)Add(Add(this.id, " does not have market symbol "), symbol)) 
}
func  (this *Exchange) createExpiredOptionMarket(symbol string)  {
    throw new NotSupported ((string)Add(this.id, " createExpiredOptionMarket () is not supported yet")) 
}
func  (this *Exchange) handleWithdrawTagAndParams(tag interface{}, parameters interface{})  {
    if IsTrue(IsTrue((!IsEqual(tag, null))) && IsTrue(((tag is IDictionary<string, object>)))) {
        parameters = this.extend(tag, parameters)
        tag = null
    }
    if IsTrue(IsEqual(tag, null)) {
        tag = this.safeString(parameters, "tag")
        if IsTrue(!IsEqual(tag, null)) {
            parameters = this.omit(parameters, "tag")
        }
    }
    return []interface{}{tag, parameters}
}
func  (this *Exchange) createLimitOrder(symbol string, side interface{}, amount interface{}, price interface{}, parameters interface{})  {
    return await this.createOrder(symbol, "limit", side, amount, price, parameters)
}
func  (this *Exchange) createLimitOrderWs(symbol string, side interface{}, amount interface{}, price interface{}, parameters interface{})  {
    return await this.createOrderWs(symbol, "limit", side, amount, price, parameters)
}
func  (this *Exchange) createMarketOrder(symbol string, side interface{}, amount interface{}, price interface{}, parameters interface{})  {
    return await this.createOrder(symbol, "market", side, amount, price, parameters)
}
func  (this *Exchange) createMarketOrderWs(symbol string, side interface{}, amount interface{}, price interface{}, parameters interface{})  {
    return await this.createOrderWs(symbol, "market", side, amount, price, parameters)
}
func  (this *Exchange) createLimitBuyOrder(symbol string, amount interface{}, price interface{}, parameters interface{})  {
    return await this.createOrder(symbol, "limit", "buy", amount, price, parameters)
}
func  (this *Exchange) createLimitBuyOrderWs(symbol string, amount interface{}, price interface{}, parameters interface{})  {
    return await this.createOrderWs(symbol, "limit", "buy", amount, price, parameters)
}
func  (this *Exchange) createLimitSellOrder(symbol string, amount interface{}, price interface{}, parameters interface{})  {
    return await this.createOrder(symbol, "limit", "sell", amount, price, parameters)
}
func  (this *Exchange) createLimitSellOrderWs(symbol string, amount interface{}, price interface{}, parameters interface{})  {
    return await this.createOrderWs(symbol, "limit", "sell", amount, price, parameters)
}
func  (this *Exchange) createMarketBuyOrder(symbol string, amount interface{}, parameters interface{})  {
    return await this.createOrder(symbol, "market", "buy", amount, null, parameters)
}
func  (this *Exchange) createMarketBuyOrderWs(symbol string, amount interface{}, parameters interface{})  {
    return await this.createOrderWs(symbol, "market", "buy", amount, null, parameters)
}
func  (this *Exchange) createMarketSellOrder(symbol string, amount interface{}, parameters interface{})  {
    return await this.createOrder(symbol, "market", "sell", amount, null, parameters)
}
func  (this *Exchange) createMarketSellOrderWs(symbol string, amount interface{}, parameters interface{})  {
    return await this.createOrderWs(symbol, "market", "sell", amount, null, parameters)
}
func  (this *Exchange) costToPrecision(symbol string, cost interface{})  {
    market := this.market(symbol)
    return this.decimalToPrecision(cost, TRUNCATE, market["precision"]["price"], this.precisionMode, this.paddingMode)
}
func  (this *Exchange) priceToPrecision(symbol string, price interface{})  {
    market := this.market(symbol)
    result := this.decimalToPrecision(price, ROUND, market["precision"]["price"], this.precisionMode, this.paddingMode)
    if IsTrue(IsEqual(result, "0")) {
        throw new InvalidOrder ((string)Add(Add(Add(Add(this.id, " price of "), market["symbol"]), " must be greater than minimum price precision of "), this.numberToString(market["precision"]["price"]))) 
    }
    return result
}
func  (this *Exchange) amountToPrecision(symbol string, amount interface{})  {
    market := this.market(symbol)
    result := this.decimalToPrecision(amount, TRUNCATE, market["precision"]["amount"], this.precisionMode, this.paddingMode)
    if IsTrue(IsEqual(result, "0")) {
        throw new InvalidOrder ((string)Add(Add(Add(Add(this.id, " amount of "), market["symbol"]), " must be greater than minimum amount precision of "), this.numberToString(market["precision"]["amount"]))) 
    }
    return result
}
func  (this *Exchange) feeToPrecision(symbol string, fee interface{})  {
    market := this.market(symbol)
    return this.decimalToPrecision(fee, ROUND, market["precision"]["price"], this.precisionMode, this.paddingMode)
}
func  (this *Exchange) currencyToPrecision(code string, fee interface{}, networkCode interface{})  {
    currency := this.currencies[code]
    precision := this.safeValue(currency, "precision")
    if IsTrue(!IsEqual(networkCode, null)) {
        networks := this.safeDict(currency, "networks", make(map[string]interface{}) {})
        networkItem := this.safeDict(networks, networkCode, make(map[string]interface{}) {})
        precision = this.safeValue(networkItem, "precision", precision)
    }
    if IsTrue(IsEqual(precision, null)) {
        return this.forceString(fee)
    } else {
        return this.decimalToPrecision(fee, ROUND, precision, this.precisionMode, this.paddingMode)
    }
}
func  (this *Exchange) forceString(value interface{})  {
    if IsTrue(!(value is string)) {
        return this.numberToString(value)
    }
    return value
}
func  (this *Exchange) isTickPrecision()  {
    return IsEqual(this.precisionMode, TICK_SIZE)
}
func  (this *Exchange) isDecimalPrecision()  {
    return IsEqual(this.precisionMode, DECIMAL_PLACES)
}
func  (this *Exchange) isSignificantPrecision()  {
    return IsEqual(this.precisionMode, SIGNIFICANT_DIGITS)
}
func  (this *Exchange) safeNumber(obj interface{}, key interface{}, defaultNumber interface{})  {
    value := this.safeString(obj, key)
    return this.parseNumber(value, defaultNumber)
}
func  (this *Exchange) safeNumberN(obj interface{}, arr interface{}, defaultNumber interface{})  {
    value := this.safeStringN(obj, arr)
    return this.parseNumber(value, defaultNumber)
}
func  (this *Exchange) parsePrecision(precision string)  {
    /**
     * @ignore
     * @method
     * @param {string} precision The number of digits to the right of the decimal
     * @returns {string} a string number equal to 1e-precision
     */
    if IsTrue(IsEqual(precision, null)) {
        return null
    }
    precisionNumber := parseInt(precision)
    if IsTrue(IsEqual(precisionNumber, 0)) {
        return "1"
    }
    parsedPrecision := "0."
    for i := 0; IsLessThan(i, Subtract(precisionNumber, 1)); i++ {
        parsedPrecision = Add(parsedPrecision, "0")
    }
    return Add(parsedPrecision, "1")
}
func  (this *Exchange) integerPrecisionToAmount(precision interface{})  {
    /**
     * @ignore
     * @method
     * @description handles positive & negative numbers too. parsePrecision() does not handle negative numbers, but this method handles
     * @param {string} precision The number of digits to the right of the decimal
     * @returns {string} a string number equal to 1e-precision
     */
    if IsTrue(IsEqual(precision, null)) {
        return null
    }
    if IsTrue(Precise.stringGe(precision, "0")) {
        return this.parsePrecision(precision)
    } else {
        positivePrecisionString := Precise.stringAbs(precision)
        positivePrecision := parseInt(positivePrecisionString)
        parsedPrecision := "1"
        for i := 0; IsLessThan(i, Subtract(positivePrecision, 1)); i++ {
            parsedPrecision = Add(parsedPrecision, "0")
        }
        return Add(parsedPrecision, "0")
    }
}
func  (this *Exchange) loadTimeDifference(parameters interface{})  {
    serverTime := await this.fetchTime(parameters)
    after := this.milliseconds()
    addElementToObject(this.options, "timeDifference", Subtract(after, serverTime))
    return this.options["timeDifference"]
}
func  (this *Exchange) implodeHostname(url string)  {
    return this.implodeParams(url, make(map[string]interface{}) {
        "hostname", this.hostname,
    })
}
func  (this *Exchange) fetchMarketLeverageTiers(symbol string, parameters interface{})  {
    if IsTrue(this.has["fetchLeverageTiers"]) {
        market := this.market(symbol)
        if !IsTrue(market["contract"]) {
            throw new BadSymbol ((string)Add(this.id, " fetchMarketLeverageTiers() supports contract markets only")) 
        }
        tiers := await this.fetchLeverageTiers([]interface{}{symbol})
        return this.safeValue(tiers, symbol)
    } else {
        throw new NotSupported ((string)Add(this.id, " fetchMarketLeverageTiers() is not supported yet")) 
    }
}
func  (this *Exchange) createPostOnlyOrder(symbol string, type interface{}, side interface{}, amount interface{}, price interface{}, parameters interface{})  {
    if !IsTrue(this.has["createPostOnlyOrder"]) {
        throw new NotSupported ((string)Add(this.id, "createPostOnlyOrder() is not supported yet")) 
    }
    query := this.extend(parameters, make(map[string]interface{}) {
        "postOnly", true,
    })
    return await this.createOrder(symbol, type, side, amount, price, query)
}
func  (this *Exchange) createPostOnlyOrderWs(symbol string, type interface{}, side interface{}, amount interface{}, price interface{}, parameters interface{})  {
    if !IsTrue(this.has["createPostOnlyOrderWs"]) {
        throw new NotSupported ((string)Add(this.id, "createPostOnlyOrderWs() is not supported yet")) 
    }
    query := this.extend(parameters, make(map[string]interface{}) {
        "postOnly", true,
    })
    return await this.createOrderWs(symbol, type, side, amount, price, query)
}
func  (this *Exchange) createReduceOnlyOrder(symbol string, type interface{}, side interface{}, amount interface{}, price interface{}, parameters interface{})  {
    if !IsTrue(this.has["createReduceOnlyOrder"]) {
        throw new NotSupported ((string)Add(this.id, "createReduceOnlyOrder() is not supported yet")) 
    }
    query := this.extend(parameters, make(map[string]interface{}) {
        "reduceOnly", true,
    })
    return await this.createOrder(symbol, type, side, amount, price, query)
}
func  (this *Exchange) createReduceOnlyOrderWs(symbol string, type interface{}, side interface{}, amount interface{}, price interface{}, parameters interface{})  {
    if !IsTrue(this.has["createReduceOnlyOrderWs"]) {
        throw new NotSupported ((string)Add(this.id, "createReduceOnlyOrderWs() is not supported yet")) 
    }
    query := this.extend(parameters, make(map[string]interface{}) {
        "reduceOnly", true,
    })
    return await this.createOrderWs(symbol, type, side, amount, price, query)
}
func  (this *Exchange) createStopOrder(symbol string, type interface{}, side interface{}, amount interface{}, price interface{}, stopPrice interface{}, parameters interface{})  {
    if !IsTrue(this.has["createStopOrder"]) {
        throw new NotSupported ((string)Add(this.id, " createStopOrder() is not supported yet")) 
    }
    if IsTrue(IsEqual(stopPrice, null)) {
        throw new ArgumentsRequired ((string)Add(this.id, " create_stop_order() requires a stopPrice argument")) 
    }
    query := this.extend(parameters, make(map[string]interface{}) {
        "stopPrice", stopPrice,
    })
    return await this.createOrder(symbol, type, side, amount, price, query)
}
func  (this *Exchange) createStopOrderWs(symbol string, type interface{}, side interface{}, amount interface{}, price interface{}, stopPrice interface{}, parameters interface{})  {
    if !IsTrue(this.has["createStopOrderWs"]) {
        throw new NotSupported ((string)Add(this.id, " createStopOrderWs() is not supported yet")) 
    }
    if IsTrue(IsEqual(stopPrice, null)) {
        throw new ArgumentsRequired ((string)Add(this.id, " createStopOrderWs() requires a stopPrice argument")) 
    }
    query := this.extend(parameters, make(map[string]interface{}) {
        "stopPrice", stopPrice,
    })
    return await this.createOrderWs(symbol, type, side, amount, price, query)
}
func  (this *Exchange) createStopLimitOrder(symbol string, side interface{}, amount interface{}, price interface{}, stopPrice interface{}, parameters interface{})  {
    if !IsTrue(this.has["createStopLimitOrder"]) {
        throw new NotSupported ((string)Add(this.id, " createStopLimitOrder() is not supported yet")) 
    }
    query := this.extend(parameters, make(map[string]interface{}) {
        "stopPrice", stopPrice,
    })
    return await this.createOrder(symbol, "limit", side, amount, price, query)
}
func  (this *Exchange) createStopLimitOrderWs(symbol string, side interface{}, amount interface{}, price interface{}, stopPrice interface{}, parameters interface{})  {
    if !IsTrue(this.has["createStopLimitOrderWs"]) {
        throw new NotSupported ((string)Add(this.id, " createStopLimitOrderWs() is not supported yet")) 
    }
    query := this.extend(parameters, make(map[string]interface{}) {
        "stopPrice", stopPrice,
    })
    return await this.createOrderWs(symbol, "limit", side, amount, price, query)
}
func  (this *Exchange) createStopMarketOrder(symbol string, side interface{}, amount interface{}, stopPrice interface{}, parameters interface{})  {
    if !IsTrue(this.has["createStopMarketOrder"]) {
        throw new NotSupported ((string)Add(this.id, " createStopMarketOrder() is not supported yet")) 
    }
    query := this.extend(parameters, make(map[string]interface{}) {
        "stopPrice", stopPrice,
    })
    return await this.createOrder(symbol, "market", side, amount, null, query)
}
func  (this *Exchange) createStopMarketOrderWs(symbol string, side interface{}, amount interface{}, stopPrice interface{}, parameters interface{})  {
    if !IsTrue(this.has["createStopMarketOrderWs"]) {
        throw new NotSupported ((string)Add(this.id, " createStopMarketOrderWs() is not supported yet")) 
    }
    query := this.extend(parameters, make(map[string]interface{}) {
        "stopPrice", stopPrice,
    })
    return await this.createOrderWs(symbol, "market", side, amount, null, query)
}
func  (this *Exchange) safeCurrencyCode(currencyId interface{}, currency interface{})  {
    currency = this.safeCurrency(currencyId, currency)
    return currency["code"]
}
func  (this *Exchange) filterBySymbolSinceLimit(array interface{}, symbol interface{}, since interface{}, limit interface{}, tail bool)  {
    return this.filterByValueSinceLimit(array, "symbol", symbol, since, limit, "timestamp", tail)
}
func  (this *Exchange) filterByCurrencySinceLimit(array interface{}, code interface{}, since interface{}, limit interface{}, tail bool)  {
    return this.filterByValueSinceLimit(array, "currency", code, since, limit, "timestamp", tail)
}
func  (this *Exchange) filterBySymbolsSinceLimit(array interface{}, symbols interface{}, since interface{}, limit interface{}, tail bool)  {
    result := this.filterByArray(array, "symbol", symbols, false)
    return this.filterBySinceLimit(result, since, limit, "timestamp", tail)
}
func  (this *Exchange) parseLastPrices(pricesData interface{}, symbols interface{}, parameters interface{})  {
    //
    // the value of tickers is either a dict or a list
    //
    // dict
    //
    //     {
    //         'marketId1': { ... },
    //         'marketId2': { ... },
    //         ...
    //     }
    //
    // list
    //
    //     [
    //         { 'market': 'marketId1', ... },
    //         { 'market': 'marketId2', ... },
    //         ...
    //     ]
    //
    results := []interface{}{}
    if IsTrue(((pricesData is IList<object>) || (pricesData.GetType().IsGenericType && pricesData.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))) {
        for i := 0; IsLessThan(i, GetArrayLength(pricesData)); i++ {
            priceData := this.extend(this.parseLastPrice(pricesData[i]), parameters)
            results = appendToArray(results,priceData).([]interface{})
        }
    } else {
        marketIds := new List<object>(((IDictionary<string,object>)pricesData).Keys)
        for i := 0; IsLessThan(i, GetArrayLength(marketIds)); i++ {
            marketId := marketIds[i]
            market := this.safeMarket(marketId)
            priceData := this.extend(this.parseLastPrice(pricesData[marketId], market), parameters)
            results = appendToArray(results,priceData).([]interface{})
        }
    }
    symbols = this.marketSymbols(symbols)
    return this.filterByArray(results, "symbol", symbols)
}
func  (this *Exchange) parseTickers(tickers interface{}, symbols interface{}, parameters interface{})  {
    //
    // the value of tickers is either a dict or a list
    //
    //
    // dict
    //
    //     {
    //         'marketId1': { ... },
    //         'marketId2': { ... },
    //         'marketId3': { ... },
    //         ...
    //     }
    //
    // list
    //
    //     [
    //         { 'market': 'marketId1', ... },
    //         { 'market': 'marketId2', ... },
    //         { 'market': 'marketId3', ... },
    //         ...
    //     ]
    //
    results := []interface{}{}
    if IsTrue(((tickers is IList<object>) || (tickers.GetType().IsGenericType && tickers.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))) {
        for i := 0; IsLessThan(i, GetArrayLength(tickers)); i++ {
            ticker := this.extend(this.parseTicker(tickers[i]), parameters)
            results = appendToArray(results,ticker).([]interface{})
        }
    } else {
        marketIds := new List<object>(((IDictionary<string,object>)tickers).Keys)
        for i := 0; IsLessThan(i, GetArrayLength(marketIds)); i++ {
            marketId := marketIds[i]
            market := this.safeMarket(marketId)
            ticker := this.extend(this.parseTicker(tickers[marketId], market), parameters)
            results = appendToArray(results,ticker).([]interface{})
        }
    }
    symbols = this.marketSymbols(symbols)
    return this.filterByArray(results, "symbol", symbols)
}
func  (this *Exchange) parseDepositAddresses(addresses interface{}, codes interface{}, indexed bool, parameters interface{})  {
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(addresses)); i++ {
        address := this.extend(this.parseDepositAddress(addresses[i]), parameters)
        result = appendToArray(result,address).([]interface{})
    }
    if IsTrue(!IsEqual(codes, null)) {
        result = this.filterByArray(result, "currency", codes, false)
    }
    if IsTrue(indexed) {
        return this.indexBy(result, "currency")
    }
    return result
}
func  (this *Exchange) parseBorrowInterests(response interface{}, market interface{})  {
    interests := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        row := response[i]
        interests = appendToArray(interests,this.parseBorrowInterest(row, market)).([]interface{})
    }
    return interests
}
func  (this *Exchange) parseIsolatedBorrowRates(info interface{})  {
    result := make(map[string]interface{}) {}
    for i := 0; IsLessThan(i, GetArrayLength(info)); i++ {
        item := info[i]
        borrowRate := this.parseIsolatedBorrowRate(item)
        symbol := this.safeString(borrowRate, "symbol")
        addElementToObject(result, symbol, borrowRate)
    }
    return ((object)result)
}
func  (this *Exchange) parseFundingRateHistories(response interface{}, market interface{}, since interface{}, limit interface{})  {
    rates := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        entry := response[i]
        rates = appendToArray(rates,this.parseFundingRateHistory(entry, market)).([]interface{})
    }
    sorted := this.sortBy(rates, "timestamp")
    symbol := ((bool) IsTrue((IsEqual(market, null)))) ? null : market["symbol"]
    return this.filterBySymbolSinceLimit(sorted, symbol, since, limit)
}
func  (this *Exchange) safeSymbol(marketId interface{}, market interface{}, delimiter interface{}, marketType interface{})  {
    market = this.safeMarket(marketId, market, delimiter, marketType)
    return market["symbol"]
}
func  (this *Exchange) parseFundingRate(contract string, market interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseFundingRate() is not supported yet")) 
}
func  (this *Exchange) parseFundingRates(response interface{}, market interface{})  {
    result := make(map[string]interface{}) {}
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        parsed := this.parseFundingRate(response[i], market)
        addElementToObject(result, parsed["symbol"], parsed)
    }
    return result
}
func  (this *Exchange) handleTriggerAndParams(parameters interface{})  {
    isTrigger := this.safeBool2(parameters, "trigger", "stop")
    if IsTrue(isTrigger) {
        parameters = this.omit(parameters, []interface{}{"trigger", "stop"})
    }
    return []interface{}{isTrigger, parameters}
}
func  (this *Exchange) isTriggerOrder(parameters interface{})  {
    // for backwards compatibility
    return this.handleTriggerAndParams(parameters)
}
func  (this *Exchange) isPostOnly(isMarketOrder bool, exchangeSpecificParam interface{}, parameters interface{})  {
    /**
     * @ignore
     * @method
     * @param {string} type Order type
     * @param {boolean} exchangeSpecificParam exchange specific postOnly
     * @param {object} [params] exchange specific params
     * @returns {boolean} true if a post only order, false otherwise
     */
    timeInForce := this.safeStringUpper(parameters, "timeInForce")
    postOnly := this.safeBool2(parameters, "postOnly", "post_only", false)
    // we assume timeInForce is uppercase from safeStringUpper (params, 'timeInForce')
    ioc := IsEqual(timeInForce, "IOC")
    fok := IsEqual(timeInForce, "FOK")
    timeInForcePostOnly := IsEqual(timeInForce, "PO")
    postOnly = IsTrue(IsTrue(postOnly) || IsTrue(timeInForcePostOnly)) || IsTrue(exchangeSpecificParam)
    if IsTrue(postOnly) {
        if IsTrue(IsTrue(ioc) || IsTrue(fok)) {
            throw new InvalidOrder ((string)Add(Add(this.id, " postOnly orders cannot have timeInForce equal to "), timeInForce)) 
        } else if IsTrue(isMarketOrder) {
            throw new InvalidOrder ((string)Add(this.id, " market orders cannot be postOnly")) 
        } else {
            return true
        }
    } else {
        return false
    }
}
func  (this *Exchange) handlePostOnly(isMarketOrder bool, exchangeSpecificPostOnlyOption bool, parameters interface{})  {
    /**
     * @ignore
     * @method
     * @param {string} type Order type
     * @param {boolean} exchangeSpecificBoolean exchange specific postOnly
     * @param {object} [params] exchange specific params
     * @returns {Array}
     */
    timeInForce := this.safeStringUpper(parameters, "timeInForce")
    postOnly := this.safeBool(parameters, "postOnly", false)
    ioc := IsEqual(timeInForce, "IOC")
    fok := IsEqual(timeInForce, "FOK")
    po := IsEqual(timeInForce, "PO")
    postOnly = IsTrue(IsTrue(postOnly) || IsTrue(po)) || IsTrue(exchangeSpecificPostOnlyOption)
    if IsTrue(postOnly) {
        if IsTrue(IsTrue(ioc) || IsTrue(fok)) {
            throw new InvalidOrder ((string)Add(Add(this.id, " postOnly orders cannot have timeInForce equal to "), timeInForce)) 
        } else if IsTrue(isMarketOrder) {
            throw new InvalidOrder ((string)Add(this.id, " market orders cannot be postOnly")) 
        } else {
            if IsTrue(po) {
                parameters = this.omit(parameters, "timeInForce")
            }
            parameters = this.omit(parameters, "postOnly")
            return []interface{}{true, parameters}
        }
    }
    return []interface{}{false, parameters}
}
func  (this *Exchange) fetchLastPrices(symbols interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchLastPrices() is not supported yet")) 
}
func  (this *Exchange) fetchTradingFees(parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchTradingFees() is not supported yet")) 
}
func  (this *Exchange) fetchTradingFeesWs(parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchTradingFeesWs() is not supported yet")) 
}
func  (this *Exchange) fetchTradingFee(symbol string, parameters interface{})  {
    if !IsTrue(this.has["fetchTradingFees"]) {
        throw new NotSupported ((string)Add(this.id, " fetchTradingFee() is not supported yet")) 
    }
    fees := await this.fetchTradingFees(parameters)
    return this.safeDict(fees, symbol)
}
func  (this *Exchange) fetchConvertCurrencies(parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchConvertCurrencies() is not supported yet")) 
}
func  (this *Exchange) parseOpenInterest(interest interface{}, market interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseOpenInterest () is not supported yet")) 
}
func  (this *Exchange) parseOpenInterests(response interface{}, market interface{}, since interface{}, limit interface{})  {
    interests := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        entry := response[i]
        interest := this.parseOpenInterest(entry, market)
        interests = appendToArray(interests,interest).([]interface{})
    }
    sorted := this.sortBy(interests, "timestamp")
    symbol := this.safeString(market, "symbol")
    return this.filterBySymbolSinceLimit(sorted, symbol, since, limit)
}
func  (this *Exchange) fetchFundingRate(symbol string, parameters interface{})  {
    if IsTrue(this.has["fetchFundingRates"]) {
        await this.loadMarkets()
        market := this.market(symbol)
        symbol = market["symbol"]
        if !IsTrue(market["contract"]) {
            throw new BadSymbol ((string)Add(this.id, " fetchFundingRate() supports contract markets only")) 
        }
        rates := await this.fetchFundingRates([]interface{}{symbol}, parameters)
        rate := this.safeValue(rates, symbol)
        if IsTrue(IsEqual(rate, null)) {
            throw new NullResponse ((string)Add(Add(this.id, " fetchFundingRate () returned no data for "), symbol)) 
        } else {
            return rate
        }
    } else {
        throw new NotSupported ((string)Add(this.id, " fetchFundingRate () is not supported yet")) 
    }
}
func  (this *Exchange) fetchMarkOHLCV(symbol interface{}, timeframe string, since interface{}, limit interface{}, parameters interface{})  {
    /**
     * @method
     * @name exchange#fetchMarkOHLCV
     * @description fetches historical mark price candlestick data containing the open, high, low, and close price of a market
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {float[][]} A list of candles ordered as timestamp, open, high, low, close, undefined
     */
    if IsTrue(this.has["fetchMarkOHLCV"]) {
        request := make(map[string]interface{}) {
            "price", "mark",
        }
        return await this.fetchOHLCV(symbol, timeframe, since, limit, this.extend(request, parameters))
    } else {
        throw new NotSupported ((string)Add(this.id, " fetchMarkOHLCV () is not supported yet")) 
    }
}
func  (this *Exchange) fetchIndexOHLCV(symbol string, timeframe string, since interface{}, limit interface{}, parameters interface{})  {
    /**
     * @method
     * @name exchange#fetchIndexOHLCV
     * @description fetches historical index price candlestick data containing the open, high, low, and close price of a market
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {} A list of candles ordered as timestamp, open, high, low, close, undefined
     */
    if IsTrue(this.has["fetchIndexOHLCV"]) {
        request := make(map[string]interface{}) {
            "price", "index",
        }
        return await this.fetchOHLCV(symbol, timeframe, since, limit, this.extend(request, parameters))
    } else {
        throw new NotSupported ((string)Add(this.id, " fetchIndexOHLCV () is not supported yet")) 
    }
}
func  (this *Exchange) fetchPremiumIndexOHLCV(symbol string, timeframe string, since interface{}, limit interface{}, parameters interface{})  {
    /**
     * @method
     * @name exchange#fetchPremiumIndexOHLCV
     * @description fetches historical premium index price candlestick data containing the open, high, low, and close price of a market
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {float[][]} A list of candles ordered as timestamp, open, high, low, close, undefined
     */
    if IsTrue(this.has["fetchPremiumIndexOHLCV"]) {
        request := make(map[string]interface{}) {
            "price", "premiumIndex",
        }
        return await this.fetchOHLCV(symbol, timeframe, since, limit, this.extend(request, parameters))
    } else {
        throw new NotSupported ((string)Add(this.id, " fetchPremiumIndexOHLCV () is not supported yet")) 
    }
}
func  (this *Exchange) handleTimeInForce(parameters interface{})  {
    /**
     * @ignore
     * @method
     * Must add timeInForce to this.options to use this method
     * @returns {string} returns the exchange specific value for timeInForce
     */
    timeInForce := this.safeStringUpper(parameters, "timeInForce") // supported values GTC, IOC, PO
    if IsTrue(!IsEqual(timeInForce, null)) {
        exchangeValue := this.safeString(this.options["timeInForce"], timeInForce)
        if IsTrue(IsEqual(exchangeValue, null)) {
            throw new ExchangeError ((string)Add(Add(Add(this.id, " does not support timeInForce \""), timeInForce), "\"")) 
        }
        return exchangeValue
    }
    return null
}
func  (this *Exchange) convertTypeToAccount(account interface{})  {
    /**
     * @ignore
     * @method
     * Must add accountsByType to this.options to use this method
     * @param {string} account key for account name in this.options['accountsByType']
     * @returns the exchange specific account name or the isolated margin id for transfers
     */
    accountsByType := this.safeDict(this.options, "accountsByType", make(map[string]interface{}) {})
    lowercaseAccount := ((string)account).ToLower()
    if IsTrue(inOp(accountsByType, lowercaseAccount)) {
        return accountsByType[lowercaseAccount]
    } else if IsTrue(IsTrue((inOp(this.markets, account))) || IsTrue((inOp(this.markets_by_id, account)))) {
        market := this.market(account)
        return market["id"]
    } else {
        return account
    }
}
func  (this *Exchange) checkRequiredArgument(methodName string, argument interface{}, argumentName interface{}, options interface{})  {
    /**
     * @ignore
     * @method
     * @param {string} methodName the name of the method that the argument is being checked for
     * @param {string} argument the argument's actual value provided
     * @param {string} argumentName the name of the argument being checked (for logging purposes)
     * @param {string[]} options a list of options that the argument can be
     * @returns {undefined}
     */
    optionsLength := GetArrayLength(options)
    if IsTrue(IsTrue((IsEqual(argument, null))) || IsTrue((IsTrue((IsGreaterThan(optionsLength, 0))) && IsTrue((!IsTrue((this.inArray(argument, options)))))))) {
        messageOptions := String.Join(", ", ((IList<object>)options).ToArray())
        message := Add(Add(Add(Add(Add(this.id, " "), methodName), "() requires a "), argumentName), " argument")
        if IsTrue(!IsEqual(messageOptions, "")) {
            message = add(message, Add(Add(Add(", one of ", "("), messageOptions), ")"))
        }
        throw new ArgumentsRequired ((string)message) 
    }
}
func  (this *Exchange) checkRequiredMarginArgument(methodName string, symbol interface{}, marginMode string)  {
    /**
     * @ignore
     * @method
     * @param {string} symbol unified symbol of the market
     * @param {string} methodName name of the method that requires a symbol
     * @param {string} marginMode is either 'isolated' or 'cross'
     */
    if IsTrue(IsTrue((IsEqual(marginMode, "isolated"))) && IsTrue((IsEqual(symbol, null)))) {
        throw new ArgumentsRequired ((string)Add(Add(Add(this.id, " "), methodName), "() requires a symbol argument for isolated margin")) 
    } else if IsTrue(IsTrue((IsEqual(marginMode, "cross"))) && IsTrue((!IsEqual(symbol, null)))) {
        throw new ArgumentsRequired ((string)Add(Add(Add(this.id, " "), methodName), "() cannot have a symbol argument for cross margin")) 
    }
}
func  (this *Exchange) parseDepositWithdrawFees(response interface{}, codes interface{}, currencyIdKey interface{})  {
    /**
     * @ignore
     * @method
     * @param {object[]|object} response unparsed response from the exchange
     * @param {string[]|undefined} codes the unified currency codes to fetch transactions fees for, returns all currencies when undefined
     * @param {str} currencyIdKey *should only be undefined when response is a dictionary* the object key that corresponds to the currency id
     * @returns {object} objects with withdraw and deposit fees, indexed by currency codes
     */
    depositWithdrawFees := make(map[string]interface{}) {}
    isArray := ((response is IList<object>) || (response.GetType().IsGenericType && response.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))
    responseKeys := response
    if !IsTrue(isArray) {
        responseKeys = new List<object>(((IDictionary<string,object>)response).Keys)
    }
    for i := 0; IsLessThan(i, GetArrayLength(responseKeys)); i++ {
        entry := responseKeys[i]
        dictionary := ((bool) IsTrue(isArray)) ? entry : response[entry]
        currencyId := ((bool) IsTrue(isArray)) ? this.safeString(dictionary, currencyIdKey) : entry
        currency := this.safeCurrency(currencyId)
        code := this.safeString(currency, "code")
        if IsTrue(IsTrue((IsEqual(codes, null))) || IsTrue((this.inArray(code, codes)))) {
            addElementToObject(depositWithdrawFees, code, this.parseDepositWithdrawFee(dictionary, currency))
        }
    }
    return depositWithdrawFees
}
func  (this *Exchange) parseDepositWithdrawFee(fee interface{}, currency interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseDepositWithdrawFee() is not supported yet")) 
}
func  (this *Exchange) depositWithdrawFee(info interface{})  {
    return make(map[string]interface{}) {
        "info", info,
        "withdraw", make(map[string]interface{}) {
            "fee", null,
            "percentage", null,
        },
        "deposit", make(map[string]interface{}) {
            "fee", null,
            "percentage", null,
        },
        "networks", make(map[string]interface{}) {},
    }
}
func  (this *Exchange) assignDefaultDepositWithdrawFees(fee interface{}, currency interface{})  {
    /**
     * @ignore
     * @method
     * @description Takes a depositWithdrawFee structure and assigns the default values for withdraw and deposit
     * @param {object} fee A deposit withdraw fee structure
     * @param {object} currency A currency structure, the response from this.currency ()
     * @returns {object} A deposit withdraw fee structure
     */
    networkKeys := new List<object>(((IDictionary<string,object>)fee["networks"]).Keys)
    numNetworks := GetArrayLength(networkKeys)
    if IsTrue(IsEqual(numNetworks, 1)) {
        addElementToObject(fee, "withdraw", fee["networks"][networkKeys[0]]["withdraw"])
        addElementToObject(fee, "deposit", fee["networks"][networkKeys[0]]["deposit"])
        return fee
    }
    currencyCode := this.safeString(currency, "code")
    for i := 0; IsLessThan(i, numNetworks); i++ {
        network := networkKeys[i]
        if IsTrue(IsEqual(network, currencyCode)) {
            addElementToObject(fee, "withdraw", fee["networks"][networkKeys[i]]["withdraw"])
            addElementToObject(fee, "deposit", fee["networks"][networkKeys[i]]["deposit"])
        }
    }
    return fee
}
func  (this *Exchange) parseIncome(info interface{}, market interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseIncome () is not supported yet")) 
}
func  (this *Exchange) parseIncomes(incomes interface{}, market interface{}, since interface{}, limit interface{})  {
    /**
     * @ignore
     * @method
     * @description parses funding fee info from exchange response
     * @param {object[]} incomes each item describes once instance of currency being received or paid
     * @param {object} market ccxt market
     * @param {int} [since] when defined, the response items are filtered to only include items after this timestamp
     * @param {int} [limit] limits the number of items in the response
     * @returns {object[]} an array of [funding history structures]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
     */
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(incomes)); i++ {
        entry := incomes[i]
        parsed := this.parseIncome(entry, market)
        result = appendToArray(result,parsed).([]interface{})
    }
    sorted := this.sortBy(result, "timestamp")
    return this.filterBySinceLimit(sorted, since, limit)
}
func  (this *Exchange) getMarketFromSymbols(symbols interface{})  {
    if IsTrue(IsEqual(symbols, null)) {
        return null
    }
    firstMarket := this.safeString(symbols, 0)
    market := this.market(firstMarket)
    return market
}
func  (this *Exchange) parseWsOHLCVs(ohlcvs interface{}, market interface{}, timeframe string, since interface{}, limit interface{})  {
    results := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(ohlcvs)); i++ {
        results = appendToArray(results,this.parseWsOHLCV(ohlcvs[i], market)).([]interface{})
    }
    return results
}
func  (this *Exchange) fetchTransactions(code interface{}, since interface{}, limit interface{}, parameters interface{})  {
    /**
     * @method
     * @name exchange#fetchTransactions
     * @deprecated
     * @description *DEPRECATED* use fetchDepositsWithdrawals instead
     * @param {string} code unified currency code for the currency of the deposit/withdrawals, default is undefined
     * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
     * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    if IsTrue(this.has["fetchDepositsWithdrawals"]) {
        return await this.fetchDepositsWithdrawals(code, since, limit, parameters)
    } else {
        throw new NotSupported ((string)Add(this.id, " fetchTransactions () is not supported yet")) 
    }
}
func  (this *Exchange) filterByArrayPositions(objects interface{}, key interface{}, values interface{}, indexed bool)  {
    /**
     * @ignore
     * @method
     * @description Typed wrapper for filterByArray that returns a list of positions
     */
    return this.filterByArray(objects, key, values, indexed)
}
func  (this *Exchange) filterByArrayTickers(objects interface{}, key interface{}, values interface{}, indexed bool)  {
    /**
     * @ignore
     * @method
     * @description Typed wrapper for filterByArray that returns a dictionary of tickers
     */
    return this.filterByArray(objects, key, values, indexed)
}
func  (this *Exchange) createOHLCVObject(symbol string, timeframe string, data interface{})  {
    res := make(map[string]interface{}) {}
    addElementToObject(res, symbol, make(map[string]interface{}) {})
    addElementToObject(res[symbol], timeframe, data)
    return res
}
func  (this *Exchange) handleMaxEntriesPerRequestAndParams(method string, maxEntriesPerRequest interface{}, parameters interface{})  {
    newMaxEntriesPerRequest := null
    var newMaxEntriesPerRequestparametersVariable = this.handleOptionAndParams(parameters, method, "maxEntriesPerRequest");
    newMaxEntriesPerRequest = ((IList<object>)newMaxEntriesPerRequestparametersVariable)[0];
    parameters = ((IList<object>)newMaxEntriesPerRequestparametersVariable)[1]
    if IsTrue(IsTrue((!IsEqual(newMaxEntriesPerRequest, null))) && IsTrue((!IsEqual(newMaxEntriesPerRequest, maxEntriesPerRequest)))) {
        maxEntriesPerRequest = newMaxEntriesPerRequest
    }
    if IsTrue(IsEqual(maxEntriesPerRequest, null)) {
        maxEntriesPerRequest = 1000 // default to 1000
    }
    return []interface{}{maxEntriesPerRequest, parameters}
}
func  (this *Exchange) fetchPaginatedCallDynamic(method string, symbol interface{}, since interface{}, limit interface{}, parameters interface{}, maxEntriesPerRequest interface{})  {
    maxCalls := null
    var maxCallsparametersVariable = this.handleOptionAndParams(parameters, method, "paginationCalls", 10);
    maxCalls = ((IList<object>)maxCallsparametersVariable)[0];
    parameters = ((IList<object>)maxCallsparametersVariable)[1]
    maxRetries := null
    var maxRetriesparametersVariable = this.handleOptionAndParams(parameters, method, "maxRetries", 3);
    maxRetries = ((IList<object>)maxRetriesparametersVariable)[0];
    parameters = ((IList<object>)maxRetriesparametersVariable)[1]
    paginationDirection := null
    var paginationDirectionparametersVariable = this.handleOptionAndParams(parameters, method, "paginationDirection", "backward");
    paginationDirection = ((IList<object>)paginationDirectionparametersVariable)[0];
    parameters = ((IList<object>)paginationDirectionparametersVariable)[1]
    paginationTimestamp := null
    calls := 0
    result := []interface{}{}
    errors := 0
    until := this.safeInteger2(parameters, "untill", "till") // do not omit it from params here
    var maxEntriesPerRequestparametersVariable = this.handleMaxEntriesPerRequestAndParams(method, maxEntriesPerRequest, parameters);
    maxEntriesPerRequest = ((IList<object>)maxEntriesPerRequestparametersVariable)[0];
    parameters = ((IList<object>)maxEntriesPerRequestparametersVariable)[1]
    if IsTrue((IsEqual(paginationDirection, "forward"))) {
        if IsTrue(IsEqual(since, null)) {
            throw new ArgumentsRequired ((string)Add(this.id, " pagination requires a since argument when paginationDirection set to forward")) 
        }
        paginationTimestamp = since
    }
    while (IsLessThan(calls, maxCalls)) {
        calls = add(calls, 1)
        try {
            if IsTrue(IsEqual(paginationDirection, "backward")) {
                // do it backwards, starting from the last
                // UNTIL filtering is required in order to work
                if IsTrue(!IsEqual(paginationTimestamp, null)) {
                    addElementToObject(parameters, "until", Subtract(paginationTimestamp, 1))
                }
                response := await ((Task<object>)callDynamically(this, method, new object[] { symbol, null, maxEntriesPerRequest, parameters }))
                responseLength := GetArrayLength(response)
                if IsTrue(this.verbose) {
                    backwardMessage := Add(Add(Add(Add(Add("Dynamic pagination call ", this.numberToString(calls)), " method "), method), " response length "), this.numberToString(responseLength))
                    if IsTrue(!IsEqual(paginationTimestamp, null)) {
                        backwardMessage = add(backwardMessage, Add(" timestamp ", this.numberToString(paginationTimestamp)))
                    }
                    this.log(backwardMessage)
                }
                if IsTrue(IsEqual(responseLength, 0)) {
                    break
                }
                errors = 0
                result = this.arrayConcat(result, response)
                firstElement := this.safeValue(response, 0)
                paginationTimestamp = this.safeInteger2(firstElement, "timestamp", 0)
                if IsTrue(IsTrue((!IsEqual(since, null))) && IsTrue((IsLessThanOrEqual(paginationTimestamp, since)))) {
                    break
                }
            } else {
                // do it forwards, starting from the since
                response := await ((Task<object>)callDynamically(this, method, new object[] { symbol, paginationTimestamp, maxEntriesPerRequest, parameters }))
                responseLength := GetArrayLength(response)
                if IsTrue(this.verbose) {
                    forwardMessage := Add(Add(Add(Add(Add("Dynamic pagination call ", this.numberToString(calls)), " method "), method), " response length "), this.numberToString(responseLength))
                    if IsTrue(!IsEqual(paginationTimestamp, null)) {
                        forwardMessage = add(forwardMessage, Add(" timestamp ", this.numberToString(paginationTimestamp)))
                    }
                    this.log(forwardMessage)
                }
                if IsTrue(IsEqual(responseLength, 0)) {
                    break
                }
                errors = 0
                result = this.arrayConcat(result, response)
                last := this.safeValue(response, Subtract(responseLength, 1))
                paginationTimestamp = Subtract(this.safeInteger(last, "timestamp"), 1)
                if IsTrue(IsTrue((!IsEqual(until, null))) && IsTrue((IsGreaterThanOrEqual(paginationTimestamp, until)))) {
                    break
                }
            }
        } catch Exception e {
            errors = add(errors, 1)
            if IsTrue(IsGreaterThan(errors, maxRetries)) {
                throw e
            }
        }
    }
    uniqueResults := this.removeRepeatedElementsFromArray(result)
    key := ((bool) IsTrue((IsEqual(method, "fetchOHLCV")))) ? 0 : "timestamp"
    return this.filterBySinceLimit(uniqueResults, since, limit, key)
}
func  (this *Exchange) safeDeterministicCall(method string, symbol interface{}, since interface{}, limit interface{}, timeframe interface{}, parameters interface{})  {
    maxRetries := null
    var maxRetriesparametersVariable = this.handleOptionAndParams(parameters, method, "maxRetries", 3);
    maxRetries = ((IList<object>)maxRetriesparametersVariable)[0];
    parameters = ((IList<object>)maxRetriesparametersVariable)[1]
    errors := 0
    while IsLessThanOrEqual(errors, maxRetries) {
        try {
            if IsTrue(IsTrue(timeframe) && IsTrue(!IsEqual(method, "fetchFundingRateHistory"))) {
                return await ((Task<object>)callDynamically(this, method, new object[] { symbol, timeframe, since, limit, parameters }))
            } else {
                return await ((Task<object>)callDynamically(this, method, new object[] { symbol, since, limit, parameters }))
            }
        } catch Exception e {
            if IsTrue(e is RateLimitExceeded) {
                throw e
            }
            errors = add(errors, 1)
            if IsTrue(IsGreaterThan(errors, maxRetries)) {
                throw e
            }
        }
    }
    return []interface{}{}
}
func  (this *Exchange) fetchPaginatedCallDeterministic(method string, symbol interface{}, since interface{}, limit interface{}, timeframe interface{}, parameters interface{}, maxEntriesPerRequest interface{})  {
    maxCalls := null
    var maxCallsparametersVariable = this.handleOptionAndParams(parameters, method, "paginationCalls", 10);
    maxCalls = ((IList<object>)maxCallsparametersVariable)[0];
    parameters = ((IList<object>)maxCallsparametersVariable)[1]
    var maxEntriesPerRequestparametersVariable = this.handleMaxEntriesPerRequestAndParams(method, maxEntriesPerRequest, parameters);
    maxEntriesPerRequest = ((IList<object>)maxEntriesPerRequestparametersVariable)[0];
    parameters = ((IList<object>)maxEntriesPerRequestparametersVariable)[1]
    current := this.milliseconds()
    tasks := []interface{}{}
    time := Multiply(this.parseTimeframe(timeframe), 1000)
    step := Multiply(time, maxEntriesPerRequest)
    currentSince := Subtract(Subtract(current, (Multiply(maxCalls, step))), 1)
    if IsTrue(!IsEqual(since, null)) {
        currentSince = mathMax(currentSince, since)
    } else {
        currentSince = mathMax(currentSince, 1241440531000) // avoid timestamps older than 2009
    }
    until := this.safeInteger2(parameters, "until", "till") // do not omit it here
    if IsTrue(!IsEqual(until, null)) {
        requiredCalls := Math.Ceiling(Convert.ToDouble(Divide((Subtract(until, since)), step)))
        if IsTrue(IsGreaterThan(requiredCalls, maxCalls)) {
            throw new BadRequest ((string)Add(Add(Add(Add(this.id, " the number of required calls is greater than the max number of calls allowed, either increase the paginationCalls or decrease the since-until gap. Current paginationCalls limit is "), ((object)maxCalls).ToString()), " required calls is "), ((object)requiredCalls).ToString())) 
        }
    }
    for i := 0; IsLessThan(i, maxCalls); i++ {
        if IsTrue(IsTrue((!IsEqual(until, null))) && IsTrue((IsGreaterThanOrEqual(currentSince, until)))) {
            break
        }
        if IsTrue(IsGreaterThanOrEqual(currentSince, current)) {
            break
        }
        tasks = appendToArray(tasks,this.safeDeterministicCall(method, symbol, currentSince, maxEntriesPerRequest, timeframe, parameters)).([]interface{})
        currentSince = Subtract(this.sum(currentSince, step), 1)
    }
    results := await promiseAll(tasks)
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(results)); i++ {
        result = this.arrayConcat(result, results[i])
    }
    uniqueResults := ((object)this.removeRepeatedElementsFromArray(result))
    key := ((bool) IsTrue((IsEqual(method, "fetchOHLCV")))) ? 0 : "timestamp"
    return this.filterBySinceLimit(uniqueResults, since, limit, key)
}
func  (this *Exchange) fetchPaginatedCallCursor(method string, symbol interface{}, since interface{}, limit interface{}, parameters interface{}, cursorReceived interface{}, cursorSent interface{}, cursorIncrement interface{}, maxEntriesPerRequest interface{})  {
    maxCalls := null
    var maxCallsparametersVariable = this.handleOptionAndParams(parameters, method, "paginationCalls", 10);
    maxCalls = ((IList<object>)maxCallsparametersVariable)[0];
    parameters = ((IList<object>)maxCallsparametersVariable)[1]
    maxRetries := null
    var maxRetriesparametersVariable = this.handleOptionAndParams(parameters, method, "maxRetries", 3);
    maxRetries = ((IList<object>)maxRetriesparametersVariable)[0];
    parameters = ((IList<object>)maxRetriesparametersVariable)[1]
    var maxEntriesPerRequestparametersVariable = this.handleMaxEntriesPerRequestAndParams(method, maxEntriesPerRequest, parameters);
    maxEntriesPerRequest = ((IList<object>)maxEntriesPerRequestparametersVariable)[0];
    parameters = ((IList<object>)maxEntriesPerRequestparametersVariable)[1]
    cursorValue := null
    i := 0
    errors := 0
    result := []interface{}{}
    while IsLessThan(i, maxCalls) {
        try {
            if IsTrue(!IsEqual(cursorValue, null)) {
                if IsTrue(!IsEqual(cursorIncrement, null)) {
                    cursorValue = Add(this.parseToInt(cursorValue), cursorIncrement)
                }
                addElementToObject(parameters, cursorSent, cursorValue)
            }
            response := null
            if IsTrue(IsEqual(method, "fetchAccounts")) {
                response = await ((Task<object>)callDynamically(this, method, new object[] { parameters }))
            } else if IsTrue(IsEqual(method, "getLeverageTiersPaginated")) {
                response = await ((Task<object>)callDynamically(this, method, new object[] { symbol, parameters }))
            } else {
                response = await ((Task<object>)callDynamically(this, method, new object[] { symbol, since, maxEntriesPerRequest, parameters }))
            }
            errors = 0
            responseLength := GetArrayLength(response)
            if IsTrue(this.verbose) {
                cursorString := ((bool) IsTrue((IsEqual(cursorValue, null)))) ? "" : cursorValue
                iteration := (Add(i, 1))
                cursorMessage := Add(Add(Add(Add(Add(Add(Add("Cursor pagination call ", ((object)iteration).ToString()), " method "), method), " response length "), ((object)responseLength).ToString()), " cursor "), cursorString)
                this.log(cursorMessage)
            }
            if IsTrue(IsEqual(responseLength, 0)) {
                break
            }
            result = this.arrayConcat(result, response)
            last := this.safeValue(response, Subtract(responseLength, 1))
            cursorValue = this.safeValue(last["info"], cursorReceived)
            if IsTrue(IsEqual(cursorValue, null)) {
                break
            }
            lastTimestamp := this.safeInteger(last, "timestamp")
            if IsTrue(IsTrue(!IsEqual(lastTimestamp, null)) && IsTrue(IsLessThan(lastTimestamp, since))) {
                break
            }
        } catch Exception e {
            errors = add(errors, 1)
            if IsTrue(IsGreaterThan(errors, maxRetries)) {
                throw e
            }
        }
        i = add(i, 1)
    }
    sorted := this.sortCursorPaginatedResult(result)
    key := ((bool) IsTrue((IsEqual(method, "fetchOHLCV")))) ? 0 : "timestamp"
    return this.filterBySinceLimit(sorted, since, limit, key)
}
func  (this *Exchange) fetchPaginatedCallIncremental(method string, symbol interface{}, since interface{}, limit interface{}, parameters interface{}, pageKey interface{}, maxEntriesPerRequest interface{})  {
    maxCalls := null
    var maxCallsparametersVariable = this.handleOptionAndParams(parameters, method, "paginationCalls", 10);
    maxCalls = ((IList<object>)maxCallsparametersVariable)[0];
    parameters = ((IList<object>)maxCallsparametersVariable)[1]
    maxRetries := null
    var maxRetriesparametersVariable = this.handleOptionAndParams(parameters, method, "maxRetries", 3);
    maxRetries = ((IList<object>)maxRetriesparametersVariable)[0];
    parameters = ((IList<object>)maxRetriesparametersVariable)[1]
    var maxEntriesPerRequestparametersVariable = this.handleMaxEntriesPerRequestAndParams(method, maxEntriesPerRequest, parameters);
    maxEntriesPerRequest = ((IList<object>)maxEntriesPerRequestparametersVariable)[0];
    parameters = ((IList<object>)maxEntriesPerRequestparametersVariable)[1]
    i := 0
    errors := 0
    result := []interface{}{}
    while IsLessThan(i, maxCalls) {
        try {
            addElementToObject(parameters, pageKey, Add(i, 1))
            response := await ((Task<object>)callDynamically(this, method, new object[] { symbol, since, maxEntriesPerRequest, parameters }))
            errors = 0
            responseLength := GetArrayLength(response)
            if IsTrue(this.verbose) {
                iteration := ((object)(Add(i, 1))).ToString()
                incrementalMessage := Add(Add(Add(Add(Add("Incremental pagination call ", iteration), " method "), method), " response length "), ((object)responseLength).ToString())
                this.log(incrementalMessage)
            }
            if IsTrue(IsEqual(responseLength, 0)) {
                break
            }
            result = this.arrayConcat(result, response)
        } catch Exception e {
            errors = add(errors, 1)
            if IsTrue(IsGreaterThan(errors, maxRetries)) {
                throw e
            }
        }
        i = add(i, 1)
    }
    sorted := this.sortCursorPaginatedResult(result)
    key := ((bool) IsTrue((IsEqual(method, "fetchOHLCV")))) ? 0 : "timestamp"
    return this.filterBySinceLimit(sorted, since, limit, key)
}
func  (this *Exchange) sortCursorPaginatedResult(result interface{})  {
    first := this.safeValue(result, 0)
    if IsTrue(!IsEqual(first, null)) {
        if IsTrue(inOp(first, "timestamp")) {
            return this.sortBy(result, "timestamp", true)
        }
        if IsTrue(inOp(first, "id")) {
            return this.sortBy(result, "id", true)
        }
    }
    return result
}
func  (this *Exchange) removeRepeatedElementsFromArray(input interface{})  {
    uniqueResult := make(map[string]interface{}) {}
    for i := 0; IsLessThan(i, GetArrayLength(input)); i++ {
        entry := input[i]
        id := this.safeString(entry, "id")
        if IsTrue(!IsEqual(id, null)) {
            if IsTrue(IsEqual(this.safeString(uniqueResult, id), null)) {
                addElementToObject(uniqueResult, id, entry)
            }
        } else {
            timestamp := this.safeInteger2(entry, "timestamp", 0)
            if IsTrue(!IsEqual(timestamp, null)) {
                if IsTrue(IsEqual(this.safeString(uniqueResult, timestamp), null)) {
                    addElementToObject(uniqueResult, timestamp, entry)
                }
            }
        }
    }
    values := new List<object>(((IDictionary<string,object>)uniqueResult).Values)
    valuesLength := GetArrayLength(values)
    if IsTrue(IsGreaterThan(valuesLength, 0)) {
        return ((object)values)
    }
    return input
}
func  (this *Exchange) handleUntilOption(key string, request interface{}, parameters interface{}, multiplier interface{})  {
    until := this.safeInteger2(parameters, "until", "till")
    if IsTrue(!IsEqual(until, null)) {
        addElementToObject(request, key, this.parseToInt(Multiply(until, multiplier)))
        parameters = this.omit(parameters, []interface{}{"until", "till"})
    }
    return []interface{}{request, parameters}
}
func  (this *Exchange) safeOpenInterest(interest interface{}, market interface{})  {
    return this.extend(interest, make(map[string]interface{}) {
        "symbol", this.safeString(market, "symbol"),
        "baseVolume", this.safeNumber(interest, "baseVolume"),
        "quoteVolume", this.safeNumber(interest, "quoteVolume"),
        "openInterestAmount", this.safeNumber(interest, "openInterestAmount"),
        "openInterestValue", this.safeNumber(interest, "openInterestValue"),
        "timestamp", this.safeInteger(interest, "timestamp"),
        "datetime", this.safeString(interest, "datetime"),
        "info", this.safeValue(interest, "info"),
    })
}
func  (this *Exchange) parseLiquidation(liquidation interface{}, market interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseLiquidation () is not supported yet")) 
}
func  (this *Exchange) parseLiquidations(liquidations interface{}, market interface{}, since interface{}, limit interface{})  {
    /**
     * @ignore
     * @method
     * @description parses liquidation info from the exchange response
     * @param {object[]} liquidations each item describes an instance of a liquidation event
     * @param {object} market ccxt market
     * @param {int} [since] when defined, the response items are filtered to only include items after this timestamp
     * @param {int} [limit] limits the number of items in the response
     * @returns {object[]} an array of [liquidation structures]{@link https://docs.ccxt.com/#/?id=liquidation-structure}
     */
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(liquidations)); i++ {
        entry := liquidations[i]
        parsed := this.parseLiquidation(entry, market)
        result = appendToArray(result,parsed).([]interface{})
    }
    sorted := this.sortBy(result, "timestamp")
    symbol := this.safeString(market, "symbol")
    return this.filterBySymbolSinceLimit(sorted, symbol, since, limit)
}
func  (this *Exchange) parseGreeks(greeks interface{}, market interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseGreeks () is not supported yet")) 
}
func  (this *Exchange) parseOption(chain interface{}, currency interface{}, market interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseOption () is not supported yet")) 
}
func  (this *Exchange) parseOptionChain(response interface{}, currencyKey interface{}, symbolKey interface{})  {
    optionStructures := make(map[string]interface{}) {}
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        info := response[i]
        currencyId := this.safeString(info, currencyKey)
        currency := this.safeCurrency(currencyId)
        marketId := this.safeString(info, symbolKey)
        market := this.safeMarket(marketId, null, null, "option")
        addElementToObject(optionStructures, market["symbol"], this.parseOption(info, currency, market))
    }
    return optionStructures
}
func  (this *Exchange) parseMarginModes(response interface{}, symbols interface{}, symbolKey interface{}, marketType interface{})  {
    marginModeStructures := make(map[string]interface{}) {}
    if IsTrue(IsEqual(marketType, null)) {
        marketType = "swap" // default to swap
    }
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        info := response[i]
        marketId := this.safeString(info, symbolKey)
        market := this.safeMarket(marketId, null, null, marketType)
        if IsTrue(IsTrue((IsEqual(symbols, null))) || IsTrue(this.inArray(market["symbol"], symbols))) {
            addElementToObject(marginModeStructures, market["symbol"], this.parseMarginMode(info, market))
        }
    }
    return marginModeStructures
}
func  (this *Exchange) parseMarginMode(marginMode interface{}, market interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseMarginMode () is not supported yet")) 
}
func  (this *Exchange) parseLeverages(response interface{}, symbols interface{}, symbolKey interface{}, marketType interface{})  {
    leverageStructures := make(map[string]interface{}) {}
    if IsTrue(IsEqual(marketType, null)) {
        marketType = "swap" // default to swap
    }
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        info := response[i]
        marketId := this.safeString(info, symbolKey)
        market := this.safeMarket(marketId, null, null, marketType)
        if IsTrue(IsTrue((IsEqual(symbols, null))) || IsTrue(this.inArray(market["symbol"], symbols))) {
            addElementToObject(leverageStructures, market["symbol"], this.parseLeverage(info, market))
        }
    }
    return leverageStructures
}
func  (this *Exchange) parseLeverage(leverage interface{}, market interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseLeverage () is not supported yet")) 
}
func  (this *Exchange) parseConversions(conversions interface{}, code interface{}, fromCurrencyKey interface{}, toCurrencyKey interface{}, since interface{}, limit interface{}, parameters interface{})  {
    conversions = this.toArray(conversions)
    result := []interface{}{}
    fromCurrency := null
    toCurrency := null
    for i := 0; IsLessThan(i, GetArrayLength(conversions)); i++ {
        entry := conversions[i]
        fromId := this.safeString(entry, fromCurrencyKey)
        toId := this.safeString(entry, toCurrencyKey)
        if IsTrue(!IsEqual(fromId, null)) {
            fromCurrency = this.safeCurrency(fromId)
        }
        if IsTrue(!IsEqual(toId, null)) {
            toCurrency = this.safeCurrency(toId)
        }
        conversion := this.extend(this.parseConversion(entry, fromCurrency, toCurrency), parameters)
        result = appendToArray(result,conversion).([]interface{})
    }
    sorted := this.sortBy(result, "timestamp")
    currency := null
    if IsTrue(!IsEqual(code, null)) {
        currency = this.safeCurrency(code)
        code = currency["code"]
    }
    if IsTrue(IsEqual(code, null)) {
        return this.filterBySinceLimit(sorted, since, limit)
    }
    fromConversion := this.filterBy(sorted, "fromCurrency", code)
    toConversion := this.filterBy(sorted, "toCurrency", code)
    both := this.arrayConcat(fromConversion, toConversion)
    return this.filterBySinceLimit(both, since, limit)
}
func  (this *Exchange) parseConversion(conversion interface{}, fromCurrency interface{}, toCurrency interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseConversion () is not supported yet")) 
}
func  (this *Exchange) convertExpireDate(date string)  {
    // parse YYMMDD to datetime string
    year := slice(date, 0, 2)
    month := slice(date, 2, 4)
    day := slice(date, 4, 6)
    reconstructedDate := Add(Add(Add(Add(Add(Add("20", year), "-"), month), "-"), day), "T00:00:00Z")
    return reconstructedDate
}
func  (this *Exchange) convertExpireDateToMarketIdDate(date string)  {
    // parse 240119 to 19JAN24
    year := slice(date, 0, 2)
    monthRaw := slice(date, 2, 4)
    month := null
    day := slice(date, 4, 6)
    if IsTrue(IsEqual(monthRaw, "01")) {
        month = "JAN"
    } else if IsTrue(IsEqual(monthRaw, "02")) {
        month = "FEB"
    } else if IsTrue(IsEqual(monthRaw, "03")) {
        month = "MAR"
    } else if IsTrue(IsEqual(monthRaw, "04")) {
        month = "APR"
    } else if IsTrue(IsEqual(monthRaw, "05")) {
        month = "MAY"
    } else if IsTrue(IsEqual(monthRaw, "06")) {
        month = "JUN"
    } else if IsTrue(IsEqual(monthRaw, "07")) {
        month = "JUL"
    } else if IsTrue(IsEqual(monthRaw, "08")) {
        month = "AUG"
    } else if IsTrue(IsEqual(monthRaw, "09")) {
        month = "SEP"
    } else if IsTrue(IsEqual(monthRaw, "10")) {
        month = "OCT"
    } else if IsTrue(IsEqual(monthRaw, "11")) {
        month = "NOV"
    } else if IsTrue(IsEqual(monthRaw, "12")) {
        month = "DEC"
    }
    reconstructedDate := Add(Add(day, month), year)
    return reconstructedDate
}
func  (this *Exchange) convertMarketIdExpireDate(date string)  {
    // parse 03JAN24 to 240103
    monthMappping := make(map[string]interface{}) {
        "JAN", "01",
        "FEB", "02",
        "MAR", "03",
        "APR", "04",
        "MAY", "05",
        "JUN", "06",
        "JUL", "07",
        "AUG", "08",
        "SEP", "09",
        "OCT", "10",
        "NOV", "11",
        "DEC", "12",
    }
    // if exchange omits first zero and provides i.e. '3JAN24' instead of '03JAN24'
    if IsTrue(IsEqual(((string)date).Length, 6)) {
        date = Add("0", date)
    }
    year := slice(date, 0, 2)
    monthName := slice(date, 2, 5)
    month := this.safeString(monthMappping, monthName)
    day := slice(date, 5, 7)
    reconstructedDate := Add(Add(day, month), year)
    return reconstructedDate
}
func  (this *Exchange) fetchPositionHistory(symbol string, since interface{}, limit interface{}, parameters interface{})  {
    /**
     * @method
     * @name exchange#fetchPositionHistory
     * @description fetches the history of margin added or reduced from contract isolated positions
     * @param {string} [symbol] unified market symbol
     * @param {int} [since] timestamp in ms of the position
     * @param {int} [limit] the maximum amount of candles to fetch, default=1000
     * @param {object} params extra parameters specific to the exchange api endpoint
     * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    if IsTrue(this.has["fetchPositionsHistory"]) {
        positions := await this.fetchPositionsHistory([]interface{}{symbol}, since, limit, parameters)
        return this.safeDict(positions, 0)
    } else {
        throw new NotSupported ((string)Add(this.id, " fetchPositionHistory () is not supported yet")) 
    }
}
func  (this *Exchange) fetchPositionsHistory(symbols interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchPositionsHistory () is not supported yet")) 
}
func  (this *Exchange) parseMarginModification(data interface{}, market interface{})  {
    throw new NotSupported ((string)Add(this.id, " parseMarginModification() is not supported yet")) 
}
func  (this *Exchange) parseMarginModifications(response interface{}, symbols interface{}, symbolKey interface{}, marketType interface{})  {
    marginModifications := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        info := response[i]
        marketId := this.safeString(info, symbolKey)
        market := this.safeMarket(marketId, null, null, marketType)
        if IsTrue(IsTrue((IsEqual(symbols, null))) || IsTrue(this.inArray(market["symbol"], symbols))) {
            marginModifications = appendToArray(marginModifications,this.parseMarginModification(info, market)).([]interface{})
        }
    }
    return marginModifications
}
func  (this *Exchange) fetchTransfer(id string, code interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchTransfer () is not supported yet")) 
}
func  (this *Exchange) fetchTransfers(code interface{}, since interface{}, limit interface{}, parameters interface{})  {
    throw new NotSupported ((string)Add(this.id, " fetchTransfers () is not supported yet")) 
}

