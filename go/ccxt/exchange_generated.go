package ccxt
// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

func  (this *Exchange) safeBoolN(dictionaryOrList interface{}, keys interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description safely extract boolean value from dictionary or list
    * @returns {bool | undefined}
    */
    defaultValue := GetArg(optionalArgs, 2, nil)
    _ = defaultValue
    var value interface{} = this.safeValueN(dictionaryOrList, keys, defaultValue)
    if IsTrue(IsBool(value)) {
        return value
    }
    return defaultValue
}
func  (this *Exchange) safeBool2(dictionary interface{}, key1 interface{}, key2 interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description safely extract boolean value from dictionary or list
    * @returns {bool | undefined}
    */
    defaultValue := GetArg(optionalArgs, 3, nil)
    _ = defaultValue
    return this.safeBoolN(dictionary, []interface{}{key1, key2}, defaultValue)
}
func  (this *Exchange) safeBool(dictionary interface{}, key interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description safely extract boolean value from dictionary or list
    * @returns {bool | undefined}
    */
    defaultValue := GetArg(optionalArgs, 2, nil)
    _ = defaultValue
    return this.safeBoolN(dictionary, []interface{}{key}, defaultValue)
}
func  (this *Exchange) safeDictN(dictionaryOrList interface{}, keys interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description safely extract a dictionary from dictionary or list
    * @returns {object | undefined}
    */
    defaultValue := GetArg(optionalArgs, 2, nil)
    _ = defaultValue
    var value interface{} = this.safeValueN(dictionaryOrList, keys, defaultValue)
    if IsTrue(IsEqual(value, nil)) {
        return defaultValue
    }
    if IsTrue(IsObject(value)) {
        return value
    }
    return defaultValue
}
func  (this *Exchange) safeDict(dictionary interface{}, key interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description safely extract a dictionary from dictionary or list
    * @returns {object | undefined}
    */
    defaultValue := GetArg(optionalArgs, 2, nil)
    _ = defaultValue
    return this.safeDictN(dictionary, []interface{}{key}, defaultValue)
}
func  (this *Exchange) safeDict2(dictionary interface{}, key1 interface{}, key2 interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description safely extract a dictionary from dictionary or list
    * @returns {object | undefined}
    */
    defaultValue := GetArg(optionalArgs, 3, nil)
    _ = defaultValue
    return this.safeDictN(dictionary, []interface{}{key1, key2}, defaultValue)
}
func  (this *Exchange) safeListN(dictionaryOrList interface{}, keys interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description safely extract an Array from dictionary or list
    * @returns {Array | undefined}
    */
    defaultValue := GetArg(optionalArgs, 2, nil)
    _ = defaultValue
    var value interface{} = this.safeValueN(dictionaryOrList, keys, defaultValue)
    if IsTrue(IsEqual(value, nil)) {
        return defaultValue
    }
    if IsTrue(IsArray(value)) {
        return value
    }
    return defaultValue
}
func  (this *Exchange) safeList2(dictionaryOrList interface{}, key1 interface{}, key2 interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description safely extract an Array from dictionary or list
    * @returns {Array | undefined}
    */
    defaultValue := GetArg(optionalArgs, 3, nil)
    _ = defaultValue
    return this.safeListN(dictionaryOrList, []interface{}{key1, key2}, defaultValue)
}
func  (this *Exchange) safeList(dictionaryOrList interface{}, key interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description safely extract an Array from dictionary or list
    * @returns {Array | undefined}
    */
    defaultValue := GetArg(optionalArgs, 2, nil)
    _ = defaultValue
    return this.safeListN(dictionaryOrList, []interface{}{key}, defaultValue)
}
func  (this *Exchange) handleDeltas(orderbook interface{}, deltas interface{})  {
    for i := 0; IsLessThan(i, GetArrayLength(deltas)); i++ {
        this.handleDelta(orderbook, GetValue(deltas, i))
    }
}
func  (this *Exchange) handleDelta(bookside interface{}, delta interface{})  {
    panic(NotSupported(Add(this.id, " handleDelta not supported yet")))
}
func  (this *Exchange) getCacheIndex(orderbook interface{}, deltas interface{}) interface{}  {
    // return the first index of the cache that can be applied to the orderbook or -1 if not possible
    return OpNeg(IsTrue(1))
}
func  (this *Exchange) findTimeframe(timeframe interface{}, optionalArgs ...interface{}) interface{}  {
    timeframes := GetArg(optionalArgs, 1, nil)
    _ = timeframes
    if IsTrue(IsEqual(timeframes, nil)) {
        timeframes = this.timeframes
    }
    var keys interface{} = ObjectKeys(timeframes)
    for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
        var key interface{} = GetValue(keys, i)
        if IsTrue(IsEqual(GetValue(timeframes, key), timeframe)) {
            return key
        }
    }
    return nil
}
func  (this *Exchange) checkProxyUrlSettings(optionalArgs ...interface{}) interface{}  {
    url := GetArg(optionalArgs, 0, nil)
    _ = url
    method := GetArg(optionalArgs, 1, nil)
    _ = method
    headers := GetArg(optionalArgs, 2, nil)
    _ = headers
    body := GetArg(optionalArgs, 3, nil)
    _ = body
    var usedProxies interface{} = []interface{}{}
    var proxyUrl interface{} = nil
    if IsTrue(!IsEqual(this.proxyUrl, nil)) {
        AppendToArray(&usedProxies,"proxyUrl")
        proxyUrl = this.proxyUrl
    }
    if IsTrue(!IsEqual(this.proxy_url, nil)) {
        AppendToArray(&usedProxies,"proxy_url")
        proxyUrl = this.proxy_url
    }
    if IsTrue(!IsEqual(this.proxyUrlCallback, nil)) {
        AppendToArray(&usedProxies,"proxyUrlCallback")
        proxyUrl = callDynamically("proxyUrlCallback", url, method, headers, body)
    }
    if IsTrue(!IsEqual(this.proxy_url_callback, nil)) {
        AppendToArray(&usedProxies,"proxy_url_callback")
        proxyUrl = callDynamically("proxy_url_callback", url, method, headers, body)
    }
    // backwards-compatibility
    if IsTrue(!IsEqual(this.proxy, nil)) {
        AppendToArray(&usedProxies,"proxy")
        if IsTrue(IsFunction(this.proxy)) {
            proxyUrl = callDynamically("proxy", url, method, headers, body)
        } else {
            proxyUrl = this.proxy
        }
    }
    var length interface{} =     GetArrayLength(usedProxies)
    if IsTrue(IsGreaterThan(length, 1)) {
        var joinedProxyNames interface{} = Join(usedProxies, ",")
        panic(ProxyError(Add(Add(Add(this.id, " you have multiple conflicting proxy settings ("), joinedProxyNames), "), please use only one from : proxyUrl, proxy_url, proxyUrlCallback, proxy_url_callback")))
    }
    return proxyUrl
}
func  (this *Exchange) checkProxySettings(optionalArgs ...interface{}) interface{}  {
    url := GetArg(optionalArgs, 0, nil)
    _ = url
    method := GetArg(optionalArgs, 1, nil)
    _ = method
    headers := GetArg(optionalArgs, 2, nil)
    _ = headers
    body := GetArg(optionalArgs, 3, nil)
    _ = body
    var usedProxies interface{} = []interface{}{}
    var httpProxy interface{} = nil
    var httpsProxy interface{} = nil
    var socksProxy interface{} = nil
    // httpProxy
    if IsTrue(this.valueIsDefined(this.httpProxy)) {
        AppendToArray(&usedProxies,"httpProxy")
        httpProxy = this.httpProxy
    }
    if IsTrue(this.valueIsDefined(this.http_proxy)) {
        AppendToArray(&usedProxies,"http_proxy")
        httpProxy = this.http_proxy
    }
    if IsTrue(!IsEqual(this.httpProxyCallback, nil)) {
        AppendToArray(&usedProxies,"httpProxyCallback")
        httpProxy = callDynamically("httpProxyCallback", url, method, headers, body)
    }
    if IsTrue(!IsEqual(this.http_proxy_callback, nil)) {
        AppendToArray(&usedProxies,"http_proxy_callback")
        httpProxy = callDynamically("http_proxy_callback", url, method, headers, body)
    }
    // httpsProxy
    if IsTrue(this.valueIsDefined(this.httpsProxy)) {
        AppendToArray(&usedProxies,"httpsProxy")
        httpsProxy = this.httpsProxy
    }
    if IsTrue(this.valueIsDefined(this.https_proxy)) {
        AppendToArray(&usedProxies,"https_proxy")
        httpsProxy = this.https_proxy
    }
    if IsTrue(!IsEqual(this.httpsProxyCallback, nil)) {
        AppendToArray(&usedProxies,"httpsProxyCallback")
        httpsProxy = callDynamically("httpsProxyCallback", url, method, headers, body)
    }
    if IsTrue(!IsEqual(this.https_proxy_callback, nil)) {
        AppendToArray(&usedProxies,"https_proxy_callback")
        httpsProxy = callDynamically("https_proxy_callback", url, method, headers, body)
    }
    // socksProxy
    if IsTrue(this.valueIsDefined(this.socksProxy)) {
        AppendToArray(&usedProxies,"socksProxy")
        socksProxy = this.socksProxy
    }
    if IsTrue(this.valueIsDefined(this.socks_proxy)) {
        AppendToArray(&usedProxies,"socks_proxy")
        socksProxy = this.socks_proxy
    }
    if IsTrue(!IsEqual(this.socksProxyCallback, nil)) {
        AppendToArray(&usedProxies,"socksProxyCallback")
        socksProxy = callDynamically("socksProxyCallback", url, method, headers, body)
    }
    if IsTrue(!IsEqual(this.socks_proxy_callback, nil)) {
        AppendToArray(&usedProxies,"socks_proxy_callback")
        socksProxy = callDynamically("socks_proxy_callback", url, method, headers, body)
    }
    // check
    var length interface{} =     GetArrayLength(usedProxies)
    if IsTrue(IsGreaterThan(length, 1)) {
        var joinedProxyNames interface{} = Join(usedProxies, ",")
        panic(ProxyError(Add(Add(Add(this.id, " you have multiple conflicting proxy settings ("), joinedProxyNames), "), please use only one from: httpProxy, httpsProxy, httpProxyCallback, httpsProxyCallback, socksProxy, socksProxyCallback")))
    }
    return []interface{}{httpProxy, httpsProxy, socksProxy}
}
func  (this *Exchange) checkWsProxySettings() interface{}  {
    var usedProxies interface{} = []interface{}{}
    var wsProxy interface{} = nil
    var wssProxy interface{} = nil
    var wsSocksProxy interface{} = nil
    // ws proxy
    if IsTrue(this.valueIsDefined(this.wsProxy)) {
        AppendToArray(&usedProxies,"wsProxy")
        wsProxy = this.wsProxy
    }
    if IsTrue(this.valueIsDefined(this.ws_proxy)) {
        AppendToArray(&usedProxies,"ws_proxy")
        wsProxy = this.ws_proxy
    }
    // wss proxy
    if IsTrue(this.valueIsDefined(this.wssProxy)) {
        AppendToArray(&usedProxies,"wssProxy")
        wssProxy = this.wssProxy
    }
    if IsTrue(this.valueIsDefined(this.wss_proxy)) {
        AppendToArray(&usedProxies,"wss_proxy")
        wssProxy = this.wss_proxy
    }
    // ws socks proxy
    if IsTrue(this.valueIsDefined(this.wsSocksProxy)) {
        AppendToArray(&usedProxies,"wsSocksProxy")
        wsSocksProxy = this.wsSocksProxy
    }
    if IsTrue(this.valueIsDefined(this.ws_socks_proxy)) {
        AppendToArray(&usedProxies,"ws_socks_proxy")
        wsSocksProxy = this.ws_socks_proxy
    }
    // check
    var length interface{} =     GetArrayLength(usedProxies)
    if IsTrue(IsGreaterThan(length, 1)) {
        var joinedProxyNames interface{} = Join(usedProxies, ",")
        panic(ProxyError(Add(Add(Add(this.id, " you have multiple conflicting proxy settings ("), joinedProxyNames), "), please use only one from: wsProxy, wssProxy, wsSocksProxy")))
    }
    return []interface{}{wsProxy, wssProxy, wsSocksProxy}
}
func  (this *Exchange) checkConflictingProxies(proxyAgentSet interface{}, proxyUrlSet interface{})  {
    if IsTrue(IsTrue(proxyAgentSet) && IsTrue(proxyUrlSet)) {
        panic(ProxyError(Add(this.id, " you have multiple conflicting proxy settings, please use only one from : proxyUrl, httpProxy, httpsProxy, socksProxy")))
    }
}
func  (this *Exchange) findMessageHashes(client Client, element interface{}) interface{}  {
    var result interface{} = []interface{}{}
    var messageHashes interface{} = ObjectKeys(client.futures)
    for i := 0; IsLessThan(i, GetArrayLength(messageHashes)); i++ {
        var messageHash interface{} = GetValue(messageHashes, i)
        if IsTrue(IsGreaterThanOrEqual(GetIndexOf(messageHash, element), 0)) {
            AppendToArray(&result,messageHash)
        }
    }
    return result
}
func  (this *Exchange) filterByLimit(array interface{}, optionalArgs ...interface{}) interface{}  {
    limit := GetArg(optionalArgs, 1, nil)
    _ = limit
    key := GetArg(optionalArgs, 2, "timestamp")
    _ = key
    fromStart := GetArg(optionalArgs, 3, false)
    _ = fromStart
    if IsTrue(this.valueIsDefined(limit)) {
        var arrayLength interface{} =         GetArrayLength(array)
        if IsTrue(IsGreaterThan(arrayLength, 0)) {
            var ascending interface{} = true
            if IsTrue((InOp(GetValue(array, 0), key))) {
                var first interface{} = GetValue(GetValue(array, 0), key)
                var last interface{} = GetValue(GetValue(array, Subtract(arrayLength, 1)), key)
                if IsTrue(IsTrue(!IsEqual(first, nil)) && IsTrue(!IsEqual(last, nil))) {
                    ascending = IsLessThanOrEqual(first, last) // true if array is sorted in ascending order based on 'timestamp'
                }
            }
            if IsTrue(fromStart) {
                if IsTrue(IsGreaterThan(limit, arrayLength)) {
                    limit = arrayLength
                }
                array = Ternary(IsTrue(ascending), this.arraySlice(array, 0, limit), this.arraySlice(array, OpNeg(IsTrue(limit))))
            } else {
                array = Ternary(IsTrue(ascending), this.arraySlice(array, OpNeg(IsTrue(limit))), this.arraySlice(array, 0, limit))
            }
        }
    }
    return array
}
func  (this *Exchange) filterBySinceLimit(array interface{}, optionalArgs ...interface{}) interface{}  {
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    key := GetArg(optionalArgs, 3, "timestamp")
    _ = key
    tail := GetArg(optionalArgs, 4, false)
    _ = tail
    var sinceIsDefined interface{} = this.valueIsDefined(since)
    var parsedArray interface{} = this.toArray(array)
    var result interface{} = parsedArray
    if IsTrue(sinceIsDefined) {
        result = []interface{}{}
        for i := 0; IsLessThan(i, GetArrayLength(parsedArray)); i++ {
            var entry interface{} = GetValue(parsedArray, i)
            var value interface{} = this.safeValue(entry, key)
            if IsTrue(IsTrue(value) && IsTrue((IsGreaterThanOrEqual(value, since)))) {
                AppendToArray(&result,entry)
            }
        }
    }
    if IsTrue(IsTrue(tail) && IsTrue(!IsEqual(limit, nil))) {
        return this.arraySlice(result, OpNeg(IsTrue(limit)))
    }
    // if the user provided a 'since' argument
    // we want to limit the result starting from the 'since'
    var shouldFilterFromStart interface{} = !IsTrue(tail) && IsTrue(sinceIsDefined)
    return this.filterByLimit(result, limit, key, shouldFilterFromStart)
}
func  (this *Exchange) filterByValueSinceLimit(array interface{}, field interface{}, optionalArgs ...interface{}) interface{}  {
    value := GetArg(optionalArgs, 2, nil)
    _ = value
    since := GetArg(optionalArgs, 3, nil)
    _ = since
    limit := GetArg(optionalArgs, 4, nil)
    _ = limit
    key := GetArg(optionalArgs, 5, "timestamp")
    _ = key
    tail := GetArg(optionalArgs, 6, false)
    _ = tail
    var valueIsDefined interface{} = this.valueIsDefined(value)
    var sinceIsDefined interface{} = this.valueIsDefined(since)
    var parsedArray interface{} = this.toArray(array)
    var result interface{} = parsedArray
    // single-pass filter for both symbol and since
    if IsTrue(IsTrue(valueIsDefined) || IsTrue(sinceIsDefined)) {
        result = []interface{}{}
        for i := 0; IsLessThan(i, GetArrayLength(parsedArray)); i++ {
            var entry interface{} = GetValue(parsedArray, i)
            var entryFiledEqualValue interface{} = IsEqual(GetValue(entry, field), value)
            var firstCondition interface{} = Ternary(IsTrue(valueIsDefined), entryFiledEqualValue, true)
            var entryKeyValue interface{} = this.safeValue(entry, key)
            var entryKeyGESince interface{} = IsTrue(IsTrue((entryKeyValue)) && IsTrue(since)) && IsTrue((IsGreaterThanOrEqual(entryKeyValue, since)))
            var secondCondition interface{} = Ternary(IsTrue(sinceIsDefined), entryKeyGESince, true)
            if IsTrue(IsTrue(firstCondition) && IsTrue(secondCondition)) {
                AppendToArray(&result,entry)
            }
        }
    }
    if IsTrue(IsTrue(tail) && IsTrue(!IsEqual(limit, nil))) {
        return this.arraySlice(result, OpNeg(IsTrue(limit)))
    }
    return this.filterByLimit(result, limit, key, sinceIsDefined)
}
func  (this *Exchange) setSandboxMode(enabled interface{})  {
    if IsTrue(enabled) {
        if IsTrue(InOp(this.urls, "test")) {
            if IsTrue(IsString(GetValue(this.urls, "api"))) {
                AddElementToObject(this.urls, "apiBackup", GetValue(this.urls, "api"))
                AddElementToObject(this.urls, "api", GetValue(this.urls, "test"))
            } else {
                AddElementToObject(this.urls, "apiBackup", this.clone(GetValue(this.urls, "api")))
                AddElementToObject(this.urls, "api", this.clone(GetValue(this.urls, "test")))
            }
        } else {
            panic(NotSupported(Add(this.id, " does not have a sandbox URL")))
        }
    } else if IsTrue(InOp(this.urls, "apiBackup")) {
        if IsTrue(IsString(GetValue(this.urls, "api"))) {
            AddElementToObject(this.urls, "api", GetValue(this.urls, "apiBackup"))
        } else {
            AddElementToObject(this.urls, "api", this.clone(GetValue(this.urls, "apiBackup")))
        }
        var newUrls interface{} = this.omit(this.urls, "apiBackup")
        this.urls = newUrls
    }
}
func  (this *Exchange) sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 1, "public")
    _ = api
    method := GetArg(optionalArgs, 2, "GET")
    _ = method
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 4, nil)
    _ = headers
    body := GetArg(optionalArgs, 5, nil)
    _ = body
    return map[string]interface{} {}
}
func  (this *Exchange) fetchAccounts(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchAccounts() is not supported yet")))
}
func  (this *Exchange) fetchTrades(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchTrades() is not supported yet")))
}
func  (this *Exchange) fetchTradesWs(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchTradesWs() is not supported yet")))
}
func  (this *Exchange) watchLiquidations(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "watchLiquidationsForSymbols")) {
        return this.watchLiquidationsForSymbols([]interface{}{symbol}, since, limit, params)
    }
    panic(NotSupported(Add(this.id, " watchLiquidations() is not supported yet")))
}
func  (this *Exchange) watchLiquidationsForSymbols(symbols interface{}, optionalArgs ...interface{}) interface{}  {
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchLiquidationsForSymbols() is not supported yet")))
}
func  (this *Exchange) watchMyLiquidations(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "watchMyLiquidationsForSymbols")) {
        return this.watchMyLiquidationsForSymbols([]interface{}{symbol}, since, limit, params)
    }
    panic(NotSupported(Add(this.id, " watchMyLiquidations() is not supported yet")))
}
func  (this *Exchange) watchMyLiquidationsForSymbols(symbols interface{}, optionalArgs ...interface{}) interface{}  {
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchMyLiquidationsForSymbols() is not supported yet")))
}
func  (this *Exchange) watchTrades(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchTrades() is not supported yet")))
}
func  (this *Exchange) watchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) interface{}  {
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchTradesForSymbols() is not supported yet")))
}
func  (this *Exchange) watchMyTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) interface{}  {
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchMyTradesForSymbols() is not supported yet")))
}
func  (this *Exchange) watchOrdersForSymbols(symbols interface{}, optionalArgs ...interface{}) interface{}  {
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchOrdersForSymbols() is not supported yet")))
}
func  (this *Exchange) watchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) interface{}  {
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchOHLCVForSymbols() is not supported yet")))
}
func  (this *Exchange) watchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) interface{}  {
    limit := GetArg(optionalArgs, 1, nil)
    _ = limit
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchOrderBookForSymbols() is not supported yet")))
}
func  (this *Exchange) fetchDepositAddresses(optionalArgs ...interface{}) interface{}  {
    codes := GetArg(optionalArgs, 0, nil)
    _ = codes
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchDepositAddresses() is not supported yet")))
}
func  (this *Exchange) fetchOrderBook(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    limit := GetArg(optionalArgs, 1, nil)
    _ = limit
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchOrderBook() is not supported yet")))
}
func  (this *Exchange) fetchMarginMode(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchMarginModes")) {
        var marginModes interface{} = this.fetchMarginModes([]interface{}{symbol}, params)
        return this.safeDict(marginModes, symbol)
    } else {
        panic(NotSupported(Add(this.id, " fetchMarginMode() is not supported yet")))
    }
}
func  (this *Exchange) fetchMarginModes(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchMarginModes () is not supported yet")))
}
func  (this *Exchange) fetchRestOrderBookSafe(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    limit := GetArg(optionalArgs, 1, nil)
    _ = limit
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    var fetchSnapshotMaxRetries interface{} = this.handleOption("watchOrderBook", "maxRetries", 3)
    for i := 0; IsLessThan(i, fetchSnapshotMaxRetries); i++ {
        
        {		ret__ := func(this *Exchange) (ret_ interface{}) {
        		defer func() {
        			if e := recover().(interface{}); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *Exchange) interface{} {
        					// catch block:
                                        if IsTrue(IsEqual((Add(i, 1)), fetchSnapshotMaxRetries)) {
                        panic(e)
                    }
        					return nil
        				}(this)
        			}
        		}()
        		// try block:
                            var orderBook interface{} = this.fetchOrderBook(symbol, limit, params)
                    return orderBook
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
    }
    return nil
}
func  (this *Exchange) watchOrderBook(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    limit := GetArg(optionalArgs, 1, nil)
    _ = limit
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchOrderBook() is not supported yet")))
}
func  (this *Exchange) fetchTime(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchTime() is not supported yet")))
}
func  (this *Exchange) fetchTradingLimits(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchTradingLimits() is not supported yet")))
}
func  (this *Exchange) parseMarket(market interface{}) interface{}  {
    panic(NotSupported(Add(this.id, " parseMarket() is not supported yet")))
}
func  (this *Exchange) parseMarkets(markets interface{}) interface{}  {
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
        AppendToArray(&result,this.parseMarket(GetValue(markets, i)))
    }
    return result
}
func  (this *Exchange) parseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseTicker() is not supported yet")))
}
func  (this *Exchange) parseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 1, nil)
    _ = currency
    panic(NotSupported(Add(this.id, " parseDepositAddress() is not supported yet")))
}
func  (this *Exchange) parseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseTrade() is not supported yet")))
}
func  (this *Exchange) parseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 1, nil)
    _ = currency
    panic(NotSupported(Add(this.id, " parseTransaction() is not supported yet")))
}
func  (this *Exchange) parseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 1, nil)
    _ = currency
    panic(NotSupported(Add(this.id, " parseTransfer() is not supported yet")))
}
func  (this *Exchange) parseAccount(account interface{}) interface{}  {
    panic(NotSupported(Add(this.id, " parseAccount() is not supported yet")))
}
func  (this *Exchange) parseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 1, nil)
    _ = currency
    panic(NotSupported(Add(this.id, " parseLedgerEntry() is not supported yet")))
}
func  (this *Exchange) parseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseOrder() is not supported yet")))
}
func  (this *Exchange) fetchCrossBorrowRates(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchCrossBorrowRates() is not supported yet")))
}
func  (this *Exchange) fetchIsolatedBorrowRates(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchIsolatedBorrowRates() is not supported yet")))
}
func  (this *Exchange) parseMarketLeverageTiers(info interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseMarketLeverageTiers() is not supported yet")))
}
func  (this *Exchange) fetchLeverageTiers(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchLeverageTiers() is not supported yet")))
}
func  (this *Exchange) parsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parsePosition() is not supported yet")))
}
func  (this *Exchange) parseFundingRateHistory(info interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseFundingRateHistory() is not supported yet")))
}
func  (this *Exchange) parseBorrowInterest(info interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseBorrowInterest() is not supported yet")))
}
func  (this *Exchange) parseIsolatedBorrowRate(info interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseIsolatedBorrowRate() is not supported yet")))
}
func  (this *Exchange) parseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseWsTrade() is not supported yet")))
}
func  (this *Exchange) parseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseWsOrder() is not supported yet")))
}
func  (this *Exchange) parseWsOrderTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseWsOrderTrade() is not supported yet")))
}
func  (this *Exchange) parseWsOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    return this.parseOHLCV(ohlcv, market)
}
func  (this *Exchange) fetchFundingRates(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchFundingRates() is not supported yet")))
}
func  (this *Exchange) watchFundingRate(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchFundingRate() is not supported yet")))
}
func  (this *Exchange) watchFundingRates(symbols interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchFundingRates() is not supported yet")))
}
func  (this *Exchange) watchFundingRatesForSymbols(symbols interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    return this.watchFundingRates(symbols, params)
}
func  (this *Exchange) transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " transfer() is not supported yet")))
}
func  (this *Exchange) withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) interface{}  {
    tag := GetArg(optionalArgs, 3, nil)
    _ = tag
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " withdraw() is not supported yet")))
}
func  (this *Exchange) createDepositAddress(code interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " createDepositAddress() is not supported yet")))
}
func  (this *Exchange) setLeverage(leverage interface{}, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " setLeverage() is not supported yet")))
}
func  (this *Exchange) fetchLeverage(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchLeverages")) {
        var leverages interface{} = this.fetchLeverages([]interface{}{symbol}, params)
        return this.safeDict(leverages, symbol)
    } else {
        panic(NotSupported(Add(this.id, " fetchLeverage() is not supported yet")))
    }
}
func  (this *Exchange) fetchLeverages(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchLeverages() is not supported yet")))
}
func  (this *Exchange) setPositionMode(hedged interface{}, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " setPositionMode() is not supported yet")))
}
func  (this *Exchange) addMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " addMargin() is not supported yet")))
}
func  (this *Exchange) reduceMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " reduceMargin() is not supported yet")))
}
func  (this *Exchange) setMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " setMargin() is not supported yet")))
}
func  (this *Exchange) fetchMarginAdjustmentHistory(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    typeVar := GetArg(optionalArgs, 1, nil)
    _ = typeVar
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchMarginAdjustmentHistory() is not supported yet")))
}
func  (this *Exchange) setMarginMode(marginMode interface{}, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " setMarginMode() is not supported yet")))
}
func  (this *Exchange) fetchDepositAddressesByNetwork(code interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchDepositAddressesByNetwork() is not supported yet")))
}
func  (this *Exchange) fetchOpenInterestHistory(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    timeframe := GetArg(optionalArgs, 1, "1h")
    _ = timeframe
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchOpenInterestHistory() is not supported yet")))
}
func  (this *Exchange) fetchOpenInterest(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchOpenInterest() is not supported yet")))
}
func  (this *Exchange) signIn(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " signIn() is not supported yet")))
}
func  (this *Exchange) fetchPaymentMethods(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchPaymentMethods() is not supported yet")))
}
func  (this *Exchange) parseToInt(number interface{}) interface{}  {
    // Solve Common parseInt misuse ex: parseInt ((since / 1000).toString ())
    // using a number as parameter which is not valid in ts
    var stringifiedNumber interface{} = this.numberToString(number)
    var convertedNumber interface{} = parseFloat(stringifiedNumber)
    return parseInt(convertedNumber)
}
func  (this *Exchange) parseToNumeric(number interface{}) interface{}  {
    var stringVersion interface{} = this.numberToString(number) // this will convert 1.0 and 1 to "1" and 1.1 to "1.1"
    // keep this in mind:
    // in JS: 1 == 1.0 is true;  1 === 1.0 is true
    // in Python: 1 == 1.0 is true
    // in PHP 1 == 1.0 is true, but 1 === 1.0 is false
    if IsTrue(IsGreaterThanOrEqual(GetIndexOf(stringVersion, "."), 0)) {
        return parseFloat(stringVersion)
    }
    return parseInt(stringVersion)
}
func  (this *Exchange) isRoundNumber(value interface{}) interface{}  {
    // this method is similar to isInteger, but this is more loyal and does not check for types.
    // i.e. isRoundNumber(1.000) returns true, while isInteger(1.000) returns false
    var res interface{} = this.parseToNumeric((Mod(value, 1)))
    return IsEqual(res, 0)
}
func  (this *Exchange) safeIntegerOmitZero(obj interface{}, key interface{}, optionalArgs ...interface{}) interface{}  {
    defaultValue := GetArg(optionalArgs, 2, nil)
    _ = defaultValue
    var timestamp interface{} = this.safeInteger(obj, key, defaultValue)
    if IsTrue(IsTrue(IsEqual(timestamp, nil)) || IsTrue(IsEqual(timestamp, 0))) {
        return nil
    }
    return timestamp
}
func  (this *Exchange) afterConstruct()  {
    this.createNetworksByIdObject()
}
func  (this *Exchange) createNetworksByIdObject()  {
    // automatically generate network-id-to-code mappings
    var networkIdsToCodesGenerated interface{} = this.invertFlatStringDictionary(this.safeValue(this.options, "networks", map[string]interface{} {})) // invert defined networks dictionary
    AddElementToObject(this.options, "networksById", this.extend(networkIdsToCodesGenerated, this.safeValue(this.options, "networksById", map[string]interface{} {}))) // support manually overriden "networksById" dictionary too
}
func  (this *Exchange) getDefaultOptions() interface{}  {
    return map[string]interface{} {
        "defaultNetworkCodeReplacements": map[string]interface{} {
            "ETH": map[string]interface{} {
                "ERC20": "ETH",
            },
            "TRX": map[string]interface{} {
                "TRC20": "TRX",
            },
            "CRO": map[string]interface{} {
                "CRC20": "CRONOS",
            },
        },
    }
}
func  (this *Exchange) safeLedgerEntry(entry interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 1, nil)
    _ = currency
    currency = this.safeCurrency(nil, currency)
    var direction interface{} = this.safeString(entry, "direction")
    var before interface{} = this.safeString(entry, "before")
    var after interface{} = this.safeString(entry, "after")
    var amount interface{} = this.safeString(entry, "amount")
    if IsTrue(!IsEqual(amount, nil)) {
        if IsTrue(IsTrue(IsEqual(before, nil)) && IsTrue(!IsEqual(after, nil))) {
            before = Precise.stringSub(after, amount)
        } else if IsTrue(IsTrue(!IsEqual(before, nil)) && IsTrue(IsEqual(after, nil))) {
            after = Precise.stringAdd(before, amount)
        }
    }
    if IsTrue(IsTrue(!IsEqual(before, nil)) && IsTrue(!IsEqual(after, nil))) {
        if IsTrue(IsEqual(direction, nil)) {
            if IsTrue(Precise.stringGt(before, after)) {
                direction = "out"
            }
            if IsTrue(Precise.stringGt(after, before)) {
                direction = "in"
            }
        }
    }
    var fee interface{} = this.safeValue(entry, "fee")
    if IsTrue(!IsEqual(fee, nil)) {
        AddElementToObject(fee, "cost", this.safeNumber(fee, "cost"))
    }
    var timestamp interface{} = this.safeInteger(entry, "timestamp")
    var info interface{} = this.safeDict(entry, "info", map[string]interface{} {})
    return map[string]interface{} {
        "id": this.safeString(entry, "id"),
        "timestamp": timestamp,
        "datetime": this.iso8601(timestamp),
        "direction": direction,
        "account": this.safeString(entry, "account"),
        "referenceId": this.safeString(entry, "referenceId"),
        "referenceAccount": this.safeString(entry, "referenceAccount"),
        "type": this.safeString(entry, "type"),
        "currency": GetValue(currency, "code"),
        "amount": this.parseNumber(amount),
        "before": this.parseNumber(before),
        "after": this.parseNumber(after),
        "status": this.safeString(entry, "status"),
        "fee": fee,
        "info": info,
    }
}
func  (this *Exchange) safeCurrencyStructure(currency interface{}) interface{}  {
    return this.extend(map[string]interface{} {
        "info": nil,
        "id": nil,
        "numericId": nil,
        "code": nil,
        "precision": nil,
        "type": nil,
        "name": nil,
        "active": nil,
        "deposit": nil,
        "withdraw": nil,
        "fee": nil,
        "fees": map[string]interface{} {},
        "networks": map[string]interface{} {},
        "limits": map[string]interface{} {
            "deposit": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "withdraw": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
    }, currency)
}
func  (this *Exchange) safeMarketStructure(optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var cleanStructure interface{} = map[string]interface{} {
        "id": nil,
        "lowercaseId": nil,
        "symbol": nil,
        "base": nil,
        "quote": nil,
        "settle": nil,
        "baseId": nil,
        "quoteId": nil,
        "settleId": nil,
        "type": nil,
        "spot": nil,
        "margin": nil,
        "swap": nil,
        "future": nil,
        "option": nil,
        "index": nil,
        "active": nil,
        "contract": nil,
        "linear": nil,
        "inverse": nil,
        "subType": nil,
        "taker": nil,
        "maker": nil,
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": nil,
            "price": nil,
            "cost": nil,
            "base": nil,
            "quote": nil,
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "created": nil,
        "info": nil,
    }
    if IsTrue(!IsEqual(market, nil)) {
        var result interface{} = this.extend(cleanStructure, market)
        // set undefined swap/future/etc
        if IsTrue(GetValue(result, "spot")) {
            if IsTrue(IsEqual(GetValue(result, "contract"), nil)) {
                AddElementToObject(result, "contract", false)
            }
            if IsTrue(IsEqual(GetValue(result, "swap"), nil)) {
                AddElementToObject(result, "swap", false)
            }
            if IsTrue(IsEqual(GetValue(result, "future"), nil)) {
                AddElementToObject(result, "future", false)
            }
            if IsTrue(IsEqual(GetValue(result, "option"), nil)) {
                AddElementToObject(result, "option", false)
            }
            if IsTrue(IsEqual(GetValue(result, "index"), nil)) {
                AddElementToObject(result, "index", false)
            }
        }
        return result
    }
    return cleanStructure
}
func  (this *Exchange) setMarkets(markets interface{}, optionalArgs ...interface{}) interface{}  {
    currencies := GetArg(optionalArgs, 1, nil)
    _ = currencies
    var values interface{} = []interface{}{}
    this.markets_by_id = map[string]interface{} {}
    // handle marketId conflicts
    // we insert spot markets first
    var marketValues interface{} = this.sortBy(this.toArray(markets), "spot", true, true)
    for i := 0; IsLessThan(i, GetArrayLength(marketValues)); i++ {
        var value interface{} = GetValue(marketValues, i)
        if IsTrue(InOp(this.markets_by_id, GetValue(value, "id"))) {
            var marketsByIdArray interface{} =             GetValue(this.markets_by_id, GetValue(value, "id"))
            AppendToArray(&marketsByIdArray,value)
        } else {
            AddElementToObject(this.markets_by_id, GetValue(value, "id"), []interface{}{value})
        }
        var market interface{} = this.deepExtend(this.safeMarketStructure(), map[string]interface{} {
            "precision": this.precision,
            "limits": this.limits,
        }, GetValue(this.fees, "trading"), value)
        if IsTrue(GetValue(market, "linear")) {
            AddElementToObject(market, "subType", "linear")
        } else if IsTrue(GetValue(market, "inverse")) {
            AddElementToObject(market, "subType", "inverse")
        } else {
            AddElementToObject(market, "subType", nil)
        }
        AppendToArray(&values,market)
    }
    this.markets = this.indexBy(values, "symbol")
    var marketsSortedBySymbol interface{} = this.keysort(this.markets)
    var marketsSortedById interface{} = this.keysort(this.markets_by_id)
    this.symbols = ObjectKeys(marketsSortedBySymbol)
    this.ids = ObjectKeys(marketsSortedById)
    if IsTrue(!IsEqual(currencies, nil)) {
        // currencies is always undefined when called in constructor but not when called from loadMarkets
        this.currencies = this.deepExtend(this.currencies, currencies)
    } else {
        var baseCurrencies interface{} = []interface{}{}
        var quoteCurrencies interface{} = []interface{}{}
        for i := 0; IsLessThan(i, GetArrayLength(values)); i++ {
            var market interface{} = GetValue(values, i)
            var defaultCurrencyPrecision interface{} = Ternary(IsTrue((IsEqual(this.precisionMode, DECIMAL_PLACES))), 8, this.parseNumber("1e-8"))
            var marketPrecision interface{} = this.safeDict(market, "precision", map[string]interface{} {})
            if IsTrue(InOp(market, "base")) {
                var currency interface{} = this.safeCurrencyStructure(map[string]interface{} {
                    "id": this.safeString2(market, "baseId", "base"),
                    "numericId": this.safeInteger(market, "baseNumericId"),
                    "code": this.safeString(market, "base"),
                    "precision": this.safeValue2(marketPrecision, "base", "amount", defaultCurrencyPrecision),
                })
                AppendToArray(&baseCurrencies,currency)
            }
            if IsTrue(InOp(market, "quote")) {
                var currency interface{} = this.safeCurrencyStructure(map[string]interface{} {
                    "id": this.safeString2(market, "quoteId", "quote"),
                    "numericId": this.safeInteger(market, "quoteNumericId"),
                    "code": this.safeString(market, "quote"),
                    "precision": this.safeValue2(marketPrecision, "quote", "price", defaultCurrencyPrecision),
                })
                AppendToArray(&quoteCurrencies,currency)
            }
        }
        baseCurrencies = this.sortBy(baseCurrencies, "code", false, "")
        quoteCurrencies = this.sortBy(quoteCurrencies, "code", false, "")
        this.baseCurrencies = this.indexBy(baseCurrencies, "code")
        this.quoteCurrencies = this.indexBy(quoteCurrencies, "code")
        var allCurrencies interface{} = this.arrayConcat(baseCurrencies, quoteCurrencies)
        var groupedCurrencies interface{} = this.groupBy(allCurrencies, "code")
        var codes interface{} = ObjectKeys(groupedCurrencies)
        var resultingCurrencies interface{} = []interface{}{}
        for i := 0; IsLessThan(i, GetArrayLength(codes)); i++ {
            var code interface{} = GetValue(codes, i)
            var groupedCurrenciesCode interface{} = this.safeList(groupedCurrencies, code, []interface{}{})
            var highestPrecisionCurrency interface{} = this.safeValue(groupedCurrenciesCode, 0)
            for j := 1; IsLessThan(j, GetArrayLength(groupedCurrenciesCode)); j++ {
                var currentCurrency interface{} = GetValue(groupedCurrenciesCode, j)
                if IsTrue(IsEqual(this.precisionMode, TICK_SIZE)) {
                    highestPrecisionCurrency = Ternary(IsTrue((IsLessThan(GetValue(currentCurrency, "precision"), GetValue(highestPrecisionCurrency, "precision")))), currentCurrency, highestPrecisionCurrency)
                } else {
                    highestPrecisionCurrency = Ternary(IsTrue((IsGreaterThan(GetValue(currentCurrency, "precision"), GetValue(highestPrecisionCurrency, "precision")))), currentCurrency, highestPrecisionCurrency)
                }
            }
            AppendToArray(&resultingCurrencies,highestPrecisionCurrency)
        }
        var sortedCurrencies interface{} = this.sortBy(resultingCurrencies, "code")
        this.currencies = this.deepExtend(this.currencies, this.indexBy(sortedCurrencies, "code"))
    }
    this.currencies_by_id = this.indexBy(this.currencies, "id")
    var currenciesSortedByCode interface{} = this.keysort(this.currencies)
    this.codes = ObjectKeys(currenciesSortedByCode)
    return this.markets
}
func  (this *Exchange) getDescribeForExtendedWsExchange(currentRestInstance Exchange, parentRestInstance Exchange, wsBaseDescribe interface{}) interface{}  {
    var extendedRestDescribe interface{} = this.deepExtend(parentRestInstance.describe(), currentRestInstance.describe())
    var superWithRestDescribe interface{} = this.deepExtend(extendedRestDescribe, wsBaseDescribe)
    return superWithRestDescribe
}
func  (this *Exchange) safeBalance(balance interface{}) interface{}  {
    var balances interface{} = this.omit(balance, []interface{}{"info", "timestamp", "datetime", "free", "used", "total"})
    var codes interface{} = ObjectKeys(balances)
    AddElementToObject(balance, "free", map[string]interface{} {})
    AddElementToObject(balance, "used", map[string]interface{} {})
    AddElementToObject(balance, "total", map[string]interface{} {})
    var debtBalance interface{} = map[string]interface{} {}
    for i := 0; IsLessThan(i, GetArrayLength(codes)); i++ {
        var code interface{} = GetValue(codes, i)
        var total interface{} = this.safeString(GetValue(balance, code), "total")
        var free interface{} = this.safeString(GetValue(balance, code), "free")
        var used interface{} = this.safeString(GetValue(balance, code), "used")
        var debt interface{} = this.safeString(GetValue(balance, code), "debt")
        if IsTrue(IsTrue(IsTrue((IsEqual(total, nil))) && IsTrue((!IsEqual(free, nil)))) && IsTrue((!IsEqual(used, nil)))) {
            total = Precise.stringAdd(free, used)
        }
        if IsTrue(IsTrue(IsTrue((IsEqual(free, nil))) && IsTrue((!IsEqual(total, nil)))) && IsTrue((!IsEqual(used, nil)))) {
            free = Precise.stringSub(total, used)
        }
        if IsTrue(IsTrue(IsTrue((IsEqual(used, nil))) && IsTrue((!IsEqual(total, nil)))) && IsTrue((!IsEqual(free, nil)))) {
            used = Precise.stringSub(total, free)
        }
        AddElementToObject(GetValue(balance, code), "free", this.parseNumber(free))
        AddElementToObject(GetValue(balance, code), "used", this.parseNumber(used))
        AddElementToObject(GetValue(balance, code), "total", this.parseNumber(total))
        AddElementToObject(GetValue(balance, "free"), code, GetValue(GetValue(balance, code), "free"))
        AddElementToObject(GetValue(balance, "used"), code, GetValue(GetValue(balance, code), "used"))
        AddElementToObject(GetValue(balance, "total"), code, GetValue(GetValue(balance, code), "total"))
        if IsTrue(!IsEqual(debt, nil)) {
            AddElementToObject(GetValue(balance, code), "debt", this.parseNumber(debt))
            AddElementToObject(debtBalance, code, GetValue(GetValue(balance, code), "debt"))
        }
    }
    var debtBalanceArray interface{} = ObjectKeys(debtBalance)
    var length interface{} =     GetArrayLength(debtBalanceArray)
    if IsTrue(length) {
        AddElementToObject(balance, "debt", debtBalance)
    }
    return balance
}
func  (this *Exchange) safeOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    // parses numbers as strings
    // * it is important pass the trades as unparsed rawTrades
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    var amount interface{} = this.omitZero(this.safeString(order, "amount"))
    var remaining interface{} = this.safeString(order, "remaining")
    var filled interface{} = this.safeString(order, "filled")
    var cost interface{} = this.safeString(order, "cost")
    var average interface{} = this.omitZero(this.safeString(order, "average"))
    var price interface{} = this.omitZero(this.safeString(order, "price"))
    var lastTradeTimeTimestamp interface{} = this.safeInteger(order, "lastTradeTimestamp")
    var symbol interface{} = this.safeString(order, "symbol")
    var side interface{} = this.safeString(order, "side")
    var status interface{} = this.safeString(order, "status")
    var parseFilled interface{} =     (IsEqual(filled, nil))
    var parseCost interface{} =     (IsEqual(cost, nil))
    var parseLastTradeTimeTimestamp interface{} =     (IsEqual(lastTradeTimeTimestamp, nil))
    var fee interface{} = this.safeValue(order, "fee")
    var parseFee interface{} =     (IsEqual(fee, nil))
    var parseFees interface{} = IsEqual(this.safeValue(order, "fees"), nil)
    var parseSymbol interface{} = IsEqual(symbol, nil)
    var parseSide interface{} = IsEqual(side, nil)
    var shouldParseFees interface{} = IsTrue(parseFee) || IsTrue(parseFees)
    var fees interface{} = this.safeList(order, "fees", []interface{}{})
    var trades interface{} = []interface{}{}
    var isTriggerOrSLTpOrder interface{} =     (IsTrue((IsTrue(!IsEqual(this.safeString(order, "triggerPrice"), nil)) || IsTrue((!IsEqual(this.safeString(order, "stopLossPrice"), nil))))) || IsTrue((!IsEqual(this.safeString(order, "takeProfitPrice"), nil))))
    if IsTrue(IsTrue(IsTrue(parseFilled) || IsTrue(parseCost)) || IsTrue(shouldParseFees)) {
        var rawTrades interface{} = this.safeValue(order, "trades", trades)
        var oldNumber interface{} = this.number
        // we parse trades as strings here!
        this.number = "string"
        var firstTrade interface{} = this.safeValue(rawTrades, 0)
        // parse trades if they haven't already been parsed
        var tradesAreParsed interface{} =         (IsTrue(IsTrue((!IsEqual(firstTrade, nil))) && IsTrue((InOp(firstTrade, "info")))) && IsTrue((InOp(firstTrade, "id"))))
        if !IsTrue(tradesAreParsed) {
            trades = this.parseTrades(rawTrades, market)
        } else {
            trades = rawTrades
        }
        this.number = oldNumber
        var tradesLength interface{} = 0
        var isArray interface{} = IsArray(trades)
        if IsTrue(isArray) {
            tradesLength = GetArrayLength(trades)
        }
        if IsTrue(IsTrue(isArray) && IsTrue((IsGreaterThan(tradesLength, 0)))) {
            // move properties that are defined in trades up into the order
            if IsTrue(IsEqual(GetValue(order, "symbol"), nil)) {
                AddElementToObject(order, "symbol", GetValue(GetValue(trades, 0), "symbol"))
            }
            if IsTrue(IsEqual(GetValue(order, "side"), nil)) {
                AddElementToObject(order, "side", GetValue(GetValue(trades, 0), "side"))
            }
            if IsTrue(IsEqual(GetValue(order, "type"), nil)) {
                AddElementToObject(order, "type", GetValue(GetValue(trades, 0), "type"))
            }
            if IsTrue(IsEqual(GetValue(order, "id"), nil)) {
                AddElementToObject(order, "id", GetValue(GetValue(trades, 0), "order"))
            }
            if IsTrue(parseFilled) {
                filled = "0"
            }
            if IsTrue(parseCost) {
                cost = "0"
            }
            for i := 0; IsLessThan(i, GetArrayLength(trades)); i++ {
                var trade interface{} = GetValue(trades, i)
                var tradeAmount interface{} = this.safeString(trade, "amount")
                if IsTrue(IsTrue(parseFilled) && IsTrue((!IsEqual(tradeAmount, nil)))) {
                    filled = Precise.stringAdd(filled, tradeAmount)
                }
                var tradeCost interface{} = this.safeString(trade, "cost")
                if IsTrue(IsTrue(parseCost) && IsTrue((!IsEqual(tradeCost, nil)))) {
                    cost = Precise.stringAdd(cost, tradeCost)
                }
                if IsTrue(parseSymbol) {
                    symbol = this.safeString(trade, "symbol")
                }
                if IsTrue(parseSide) {
                    side = this.safeString(trade, "side")
                }
                var tradeTimestamp interface{} = this.safeValue(trade, "timestamp")
                if IsTrue(IsTrue(parseLastTradeTimeTimestamp) && IsTrue((!IsEqual(tradeTimestamp, nil)))) {
                    if IsTrue(IsEqual(lastTradeTimeTimestamp, nil)) {
                        lastTradeTimeTimestamp = tradeTimestamp
                    } else {
                        lastTradeTimeTimestamp = mathMax(lastTradeTimeTimestamp, tradeTimestamp)
                    }
                }
                if IsTrue(shouldParseFees) {
                    var tradeFees interface{} = this.safeValue(trade, "fees")
                    if IsTrue(!IsEqual(tradeFees, nil)) {
                        for j := 0; IsLessThan(j, GetArrayLength(tradeFees)); j++ {
                            var tradeFee interface{} = GetValue(tradeFees, j)
                            AppendToArray(&fees,this.extend(map[string]interface{} {}, tradeFee))
                        }
                    } else {
                        var tradeFee interface{} = this.safeValue(trade, "fee")
                        if IsTrue(!IsEqual(tradeFee, nil)) {
                            AppendToArray(&fees,this.extend(map[string]interface{} {}, tradeFee))
                        }
                    }
                }
            }
        }
    }
    if IsTrue(shouldParseFees) {
        var reducedFees interface{} = Ternary(IsTrue(this.reduceFees), this.reduceFeesByCurrency(fees), fees)
        var reducedLength interface{} =         GetArrayLength(reducedFees)
        for i := 0; IsLessThan(i, reducedLength); i++ {
            AddElementToObject(GetValue(reducedFees, i), "cost", this.safeNumber(GetValue(reducedFees, i), "cost"))
            if IsTrue(InOp(GetValue(reducedFees, i), "rate")) {
                AddElementToObject(GetValue(reducedFees, i), "rate", this.safeNumber(GetValue(reducedFees, i), "rate"))
            }
        }
        if IsTrue(!IsTrue(parseFee) && IsTrue((IsEqual(reducedLength, 0)))) {
            // copy fee to avoid modification by reference
            var feeCopy interface{} = this.deepExtend(fee)
            AddElementToObject(feeCopy, "cost", this.safeNumber(feeCopy, "cost"))
            if IsTrue(InOp(feeCopy, "rate")) {
                AddElementToObject(feeCopy, "rate", this.safeNumber(feeCopy, "rate"))
            }
            AppendToArray(&reducedFees,feeCopy)
        }
        AddElementToObject(order, "fees", reducedFees)
        if IsTrue(IsTrue(parseFee) && IsTrue((IsEqual(reducedLength, 1)))) {
            AddElementToObject(order, "fee", GetValue(reducedFees, 0))
        }
    }
    if IsTrue(IsEqual(amount, nil)) {
        // ensure amount = filled + remaining
        if IsTrue(IsTrue(!IsEqual(filled, nil)) && IsTrue(!IsEqual(remaining, nil))) {
            amount = Precise.stringAdd(filled, remaining)
        } else if IsTrue(IsEqual(status, "closed")) {
            amount = filled
        }
    }
    if IsTrue(IsEqual(filled, nil)) {
        if IsTrue(IsTrue(!IsEqual(amount, nil)) && IsTrue(!IsEqual(remaining, nil))) {
            filled = Precise.stringSub(amount, remaining)
        } else if IsTrue(IsTrue(IsEqual(status, "closed")) && IsTrue(!IsEqual(amount, nil))) {
            filled = amount
        }
    }
    if IsTrue(IsEqual(remaining, nil)) {
        if IsTrue(IsTrue(!IsEqual(amount, nil)) && IsTrue(!IsEqual(filled, nil))) {
            remaining = Precise.stringSub(amount, filled)
        } else if IsTrue(IsEqual(status, "closed")) {
            remaining = "0"
        }
    }
    // ensure that the average field is calculated correctly
    var inverse interface{} = this.safeBool(market, "inverse", false)
    var contractSize interface{} = this.numberToString(this.safeValue(market, "contractSize", 1))
    // inverse
    // price = filled * contract size / cost
    //
    // linear
    // price = cost / (filled * contract size)
    if IsTrue(IsEqual(average, nil)) {
        if IsTrue(IsTrue(IsTrue((!IsEqual(filled, nil))) && IsTrue((!IsEqual(cost, nil)))) && IsTrue(Precise.stringGt(filled, "0"))) {
            var filledTimesContractSize interface{} = Precise.stringMul(filled, contractSize)
            if IsTrue(inverse) {
                average = Precise.stringDiv(filledTimesContractSize, cost)
            } else {
                average = Precise.stringDiv(cost, filledTimesContractSize)
            }
        }
    }
    // similarly
    // inverse
    // cost = filled * contract size / price
    //
    // linear
    // cost = filled * contract size * price
    var costPriceExists interface{} = IsTrue((!IsEqual(average, nil))) || IsTrue((!IsEqual(price, nil)))
    if IsTrue(IsTrue(IsTrue(parseCost) && IsTrue((!IsEqual(filled, nil)))) && IsTrue(costPriceExists)) {
        var multiplyPrice interface{} = nil
        if IsTrue(IsEqual(average, nil)) {
            multiplyPrice = price
        } else {
            multiplyPrice = average
        }
        // contract trading
        var filledTimesContractSize interface{} = Precise.stringMul(filled, contractSize)
        if IsTrue(inverse) {
            cost = Precise.stringDiv(filledTimesContractSize, multiplyPrice)
        } else {
            cost = Precise.stringMul(filledTimesContractSize, multiplyPrice)
        }
    }
    // support for market orders
    var orderType interface{} = this.safeValue(order, "type")
    var emptyPrice interface{} = IsTrue((IsEqual(price, nil))) || IsTrue(Precise.stringEquals(price, "0"))
    if IsTrue(IsTrue(emptyPrice) && IsTrue((IsEqual(orderType, "market")))) {
        price = average
    }
    // we have trades with string values at this point so we will mutate them
    for i := 0; IsLessThan(i, GetArrayLength(trades)); i++ {
        var entry interface{} = GetValue(trades, i)
        AddElementToObject(entry, "amount", this.safeNumber(entry, "amount"))
        AddElementToObject(entry, "price", this.safeNumber(entry, "price"))
        AddElementToObject(entry, "cost", this.safeNumber(entry, "cost"))
        var tradeFee interface{} = this.safeDict(entry, "fee", map[string]interface{} {})
        AddElementToObject(tradeFee, "cost", this.safeNumber(tradeFee, "cost"))
        if IsTrue(InOp(tradeFee, "rate")) {
            AddElementToObject(tradeFee, "rate", this.safeNumber(tradeFee, "rate"))
        }
        var entryFees interface{} = this.safeList(entry, "fees", []interface{}{})
        for j := 0; IsLessThan(j, GetArrayLength(entryFees)); j++ {
            AddElementToObject(GetValue(entryFees, j), "cost", this.safeNumber(GetValue(entryFees, j), "cost"))
        }
        AddElementToObject(entry, "fees", entryFees)
        AddElementToObject(entry, "fee", tradeFee)
    }
    var timeInForce interface{} = this.safeString(order, "timeInForce")
    var postOnly interface{} = this.safeValue(order, "postOnly")
    // timeInForceHandling
    if IsTrue(IsEqual(timeInForce, nil)) {
        if IsTrue(!IsTrue(isTriggerOrSLTpOrder) && IsTrue((IsEqual(this.safeString(order, "type"), "market")))) {
            timeInForce = "IOC"
        }
        // allow postOnly override
        if IsTrue(postOnly) {
            timeInForce = "PO"
        }
    } else if IsTrue(IsEqual(postOnly, nil)) {
        // timeInForce is not undefined here
        postOnly = IsEqual(timeInForce, "PO")
    }
    var timestamp interface{} = this.safeInteger(order, "timestamp")
    var lastUpdateTimestamp interface{} = this.safeInteger(order, "lastUpdateTimestamp")
    var datetime interface{} = this.safeString(order, "datetime")
    if IsTrue(IsEqual(datetime, nil)) {
        datetime = this.iso8601(timestamp)
    }
    var triggerPrice interface{} = this.parseNumber(this.safeString2(order, "triggerPrice", "stopPrice"))
    var takeProfitPrice interface{} = this.parseNumber(this.safeString(order, "takeProfitPrice"))
    var stopLossPrice interface{} = this.parseNumber(this.safeString(order, "stopLossPrice"))
    return this.extend(order, map[string]interface{} {
        "id": this.safeString(order, "id"),
        "clientOrderId": this.safeString(order, "clientOrderId"),
        "timestamp": timestamp,
        "datetime": datetime,
        "symbol": symbol,
        "type": this.safeString(order, "type"),
        "side": side,
        "lastTradeTimestamp": lastTradeTimeTimestamp,
        "lastUpdateTimestamp": lastUpdateTimestamp,
        "price": this.parseNumber(price),
        "amount": this.parseNumber(amount),
        "cost": this.parseNumber(cost),
        "average": this.parseNumber(average),
        "filled": this.parseNumber(filled),
        "remaining": this.parseNumber(remaining),
        "timeInForce": timeInForce,
        "postOnly": postOnly,
        "trades": trades,
        "reduceOnly": this.safeValue(order, "reduceOnly"),
        "stopPrice": triggerPrice,
        "triggerPrice": triggerPrice,
        "takeProfitPrice": takeProfitPrice,
        "stopLossPrice": stopLossPrice,
        "status": status,
        "fee": this.safeValue(order, "fee"),
    })
}
func  (this *Exchange) parseOrders(orders interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // the value of orders is either a dict or a list
    //
    // dict
    //
    //     {
    //         'id1': { ... },
    //         'id2': { ... },
    //         'id3': { ... },
    //         ...
    //     }
    //
    // list
    //
    //     [
    //         { 'id': 'id1', ... },
    //         { 'id': 'id2', ... },
    //         { 'id': 'id3', ... },
    //         ...
    //     ]
    //
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    var results interface{} = []interface{}{}
    if IsTrue(IsArray(orders)) {
        for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
            var order interface{} = this.extend(this.parseOrder(GetValue(orders, i), market), params)
            AppendToArray(&results,order)
        }
    } else {
        var ids interface{} = ObjectKeys(orders)
        for i := 0; IsLessThan(i, GetArrayLength(ids)); i++ {
            var id interface{} = GetValue(ids, i)
            var order interface{} = this.extend(this.parseOrder(this.extend(map[string]interface{} {
                "id": id,
            }, GetValue(orders, id)), market), params)
            AppendToArray(&results,order)
        }
    }
    results = this.sortBy(results, "timestamp")
    var symbol interface{} = Ternary(IsTrue((!IsEqual(market, nil))), GetValue(market, "symbol"), nil)
    return this.filterBySymbolSinceLimit(results, symbol, since, limit)
}
func  (this *Exchange) calculateFee(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, price interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @description calculates the presumptive fee that would be charged for an order
    * @param {string} symbol unified market symbol
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade, in units of the base currency on most exchanges, or number of contracts
    * @param {float} price the price for the order to be filled at, in units of the quote currency
    * @param {string} takerOrMaker 'taker' or 'maker'
    * @param {object} params
    * @returns {object} contains the rate, the percentage multiplied to the order amount to obtain the fee amount, and cost, the total value of the fee in units of the quote currency, for the order
    */
    takerOrMaker := GetArg(optionalArgs, 5, "taker")
    _ = takerOrMaker
    params := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = params
    if IsTrue(IsTrue(IsEqual(typeVar, "market")) && IsTrue(IsEqual(takerOrMaker, "maker"))) {
        panic(ArgumentsRequired(Add(this.id, " calculateFee() - you have provided incompatible arguments - \"market\" type order can not be \"maker\". Change either the \"type\" or the \"takerOrMaker\" argument to calculate the fee.")))
    }
    var market interface{} = GetValue(this.markets, symbol)
    var feeSide interface{} = this.safeString(market, "feeSide", "quote")
    var useQuote interface{} = nil
    if IsTrue(IsEqual(feeSide, "get")) {
        // the fee is always in the currency you get
        useQuote = IsEqual(side, "sell")
    } else if IsTrue(IsEqual(feeSide, "give")) {
        // the fee is always in the currency you give
        useQuote = IsEqual(side, "buy")
    } else {
        // the fee is always in feeSide currency
        useQuote = IsEqual(feeSide, "quote")
    }
    var cost interface{} = this.numberToString(amount)
    var key interface{} = nil
    if IsTrue(useQuote) {
        var priceString interface{} = this.numberToString(price)
        cost = Precise.stringMul(cost, priceString)
        key = "quote"
    } else {
        key = "base"
    }
    // for derivatives, the fee is in 'settle' currency
    if !IsTrue(GetValue(market, "spot")) {
        key = "settle"
    }
    // even if `takerOrMaker` argument was set to 'maker', for 'market' orders we should forcefully override it to 'taker'
    if IsTrue(IsEqual(typeVar, "market")) {
        takerOrMaker = "taker"
    }
    var rate interface{} = this.safeString(market, takerOrMaker)
    cost = Precise.stringMul(cost, rate)
    return map[string]interface{} {
        "type": takerOrMaker,
        "currency": GetValue(market, key),
        "rate": this.parseNumber(rate),
        "cost": this.parseNumber(cost),
    }
}
func  (this *Exchange) safeLiquidation(liquidation interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    var contracts interface{} = this.safeString(liquidation, "contracts")
    var contractSize interface{} = this.safeString(market, "contractSize")
    var price interface{} = this.safeString(liquidation, "price")
    var baseValue interface{} = this.safeString(liquidation, "baseValue")
    var quoteValue interface{} = this.safeString(liquidation, "quoteValue")
    if IsTrue(IsTrue(IsTrue(IsTrue((IsEqual(baseValue, nil))) && IsTrue((!IsEqual(contracts, nil)))) && IsTrue((!IsEqual(contractSize, nil)))) && IsTrue((!IsEqual(price, nil)))) {
        baseValue = Precise.stringMul(contracts, contractSize)
    }
    if IsTrue(IsTrue(IsTrue((IsEqual(quoteValue, nil))) && IsTrue((!IsEqual(baseValue, nil)))) && IsTrue((!IsEqual(price, nil)))) {
        quoteValue = Precise.stringMul(baseValue, price)
    }
    AddElementToObject(liquidation, "contracts", this.parseNumber(contracts))
    AddElementToObject(liquidation, "contractSize", this.parseNumber(contractSize))
    AddElementToObject(liquidation, "price", this.parseNumber(price))
    AddElementToObject(liquidation, "baseValue", this.parseNumber(baseValue))
    AddElementToObject(liquidation, "quoteValue", this.parseNumber(quoteValue))
    return liquidation
}
func  (this *Exchange) safeTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    var amount interface{} = this.safeString(trade, "amount")
    var price interface{} = this.safeString(trade, "price")
    var cost interface{} = this.safeString(trade, "cost")
    if IsTrue(IsEqual(cost, nil)) {
        // contract trading
        var contractSize interface{} = this.safeString(market, "contractSize")
        var multiplyPrice interface{} = price
        if IsTrue(!IsEqual(contractSize, nil)) {
            var inverse interface{} = this.safeBool(market, "inverse", false)
            if IsTrue(inverse) {
                multiplyPrice = Precise.stringDiv("1", price)
            }
            multiplyPrice = Precise.stringMul(multiplyPrice, contractSize)
        }
        cost = Precise.stringMul(multiplyPrice, amount)
    }
    var parseFee interface{} = IsEqual(this.safeValue(trade, "fee"), nil)
    var parseFees interface{} = IsEqual(this.safeValue(trade, "fees"), nil)
    var shouldParseFees interface{} = IsTrue(parseFee) || IsTrue(parseFees)
    var fees interface{} = []interface{}{}
    var fee interface{} = this.safeValue(trade, "fee")
    if IsTrue(shouldParseFees) {
        var reducedFees interface{} = Ternary(IsTrue(this.reduceFees), this.reduceFeesByCurrency(fees), fees)
        var reducedLength interface{} =         GetArrayLength(reducedFees)
        for i := 0; IsLessThan(i, reducedLength); i++ {
            AddElementToObject(GetValue(reducedFees, i), "cost", this.safeNumber(GetValue(reducedFees, i), "cost"))
            if IsTrue(InOp(GetValue(reducedFees, i), "rate")) {
                AddElementToObject(GetValue(reducedFees, i), "rate", this.safeNumber(GetValue(reducedFees, i), "rate"))
            }
        }
        if IsTrue(!IsTrue(parseFee) && IsTrue((IsEqual(reducedLength, 0)))) {
            // copy fee to avoid modification by reference
            var feeCopy interface{} = this.deepExtend(fee)
            AddElementToObject(feeCopy, "cost", this.safeNumber(feeCopy, "cost"))
            if IsTrue(InOp(feeCopy, "rate")) {
                AddElementToObject(feeCopy, "rate", this.safeNumber(feeCopy, "rate"))
            }
            AppendToArray(&reducedFees,feeCopy)
        }
        if IsTrue(parseFees) {
            AddElementToObject(trade, "fees", reducedFees)
        }
        if IsTrue(IsTrue(parseFee) && IsTrue((IsEqual(reducedLength, 1)))) {
            AddElementToObject(trade, "fee", GetValue(reducedFees, 0))
        }
        var tradeFee interface{} = this.safeValue(trade, "fee")
        if IsTrue(!IsEqual(tradeFee, nil)) {
            AddElementToObject(tradeFee, "cost", this.safeNumber(tradeFee, "cost"))
            if IsTrue(InOp(tradeFee, "rate")) {
                AddElementToObject(tradeFee, "rate", this.safeNumber(tradeFee, "rate"))
            }
            AddElementToObject(trade, "fee", tradeFee)
        }
    }
    AddElementToObject(trade, "amount", this.parseNumber(amount))
    AddElementToObject(trade, "price", this.parseNumber(price))
    AddElementToObject(trade, "cost", this.parseNumber(cost))
    return trade
}
func  (this *Exchange) findNearestCeiling(arr interface{}, providedValue interface{}) interface{}  {
    //  i.e. findNearestCeiling ([ 10, 30, 50],  23) returns 30
    var length interface{} =     GetArrayLength(arr)
    for i := 0; IsLessThan(i, length); i++ {
        var current interface{} = GetValue(arr, i)
        if IsTrue(IsLessThanOrEqual(providedValue, current)) {
            return current
        }
    }
    return GetValue(arr, Subtract(length, 1))
}
func  (this *Exchange) invertFlatStringDictionary(dict interface{}) interface{}  {
    var reversed interface{} = map[string]interface{} {}
    var keys interface{} = ObjectKeys(dict)
    for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
        var key interface{} = GetValue(keys, i)
        var value interface{} = GetValue(dict, key)
        if IsTrue(IsString(value)) {
            AddElementToObject(reversed, value, key)
        }
    }
    return reversed
}
func  (this *Exchange) reduceFeesByCurrency(fees interface{}) interface{}  {
    //
    // this function takes a list of fee structures having the following format
    //
    //     string = true
    //
    //     [
    //         { 'currency': 'BTC', 'cost': '0.1' },
    //         { 'currency': 'BTC', 'cost': '0.2'  },
    //         { 'currency': 'BTC', 'cost': '0.2', 'rate': '0.00123' },
    //         { 'currency': 'BTC', 'cost': '0.4', 'rate': '0.00123' },
    //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
    //         { 'currency': 'USDT', 'cost': '12.3456' },
    //     ]
    //
    //     string = false
    //
    //     [
    //         { 'currency': 'BTC', 'cost': 0.1 },
    //         { 'currency': 'BTC', 'cost': 0.2 },
    //         { 'currency': 'BTC', 'cost': 0.2, 'rate': 0.00123 },
    //         { 'currency': 'BTC', 'cost': 0.4, 'rate': 0.00123 },
    //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
    //         { 'currency': 'USDT', 'cost': 12.3456 },
    //     ]
    //
    // and returns a reduced fee list, where fees are summed per currency and rate (if any)
    //
    //     string = true
    //
    //     [
    //         { 'currency': 'BTC', 'cost': '0.4'  },
    //         { 'currency': 'BTC', 'cost': '0.6', 'rate': '0.00123' },
    //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
    //         { 'currency': 'USDT', 'cost': '12.3456' },
    //     ]
    //
    //     string  = false
    //
    //     [
    //         { 'currency': 'BTC', 'cost': 0.3  },
    //         { 'currency': 'BTC', 'cost': 0.6, 'rate': 0.00123 },
    //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
    //         { 'currency': 'USDT', 'cost': 12.3456 },
    //     ]
    //
    var reduced interface{} = map[string]interface{} {}
    for i := 0; IsLessThan(i, GetArrayLength(fees)); i++ {
        var fee interface{} = GetValue(fees, i)
        var feeCurrencyCode interface{} = this.safeString(fee, "currency")
        if IsTrue(!IsEqual(feeCurrencyCode, nil)) {
            var rate interface{} = this.safeString(fee, "rate")
            var cost interface{} = this.safeValue(fee, "cost")
            if IsTrue(Precise.stringEq(cost, "0")) {
                continue
            }
            if !IsTrue((InOp(reduced, feeCurrencyCode))) {
                AddElementToObject(reduced, feeCurrencyCode, map[string]interface{} {})
            }
            var rateKey interface{} = Ternary(IsTrue((IsEqual(rate, nil))), "", rate)
            if IsTrue(InOp(GetValue(reduced, feeCurrencyCode), rateKey)) {
                AddElementToObject(GetValue(GetValue(reduced, feeCurrencyCode), rateKey), "cost", Precise.stringAdd(GetValue(GetValue(GetValue(reduced, feeCurrencyCode), rateKey), "cost"), cost))
            } else {
                AddElementToObject(GetValue(reduced, feeCurrencyCode), rateKey, map[string]interface{} {
    "currency": feeCurrencyCode,
    "cost": cost,
})
                if IsTrue(!IsEqual(rate, nil)) {
                    AddElementToObject(GetValue(GetValue(reduced, feeCurrencyCode), rateKey), "rate", rate)
                }
            }
        }
    }
    var result interface{} = []interface{}{}
    var feeValues interface{} = ObjectValues(reduced)
    for i := 0; IsLessThan(i, GetArrayLength(feeValues)); i++ {
        var reducedFeeValues interface{} = ObjectValues(GetValue(feeValues, i))
        result = this.arrayConcat(result, reducedFeeValues)
    }
    return result
}
func  (this *Exchange) safeTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    var open interface{} = this.omitZero(this.safeString(ticker, "open"))
    var close interface{} = this.omitZero(this.safeString(ticker, "close"))
    var last interface{} = this.omitZero(this.safeString(ticker, "last"))
    var change interface{} = this.omitZero(this.safeString(ticker, "change"))
    var percentage interface{} = this.omitZero(this.safeString(ticker, "percentage"))
    var average interface{} = this.omitZero(this.safeString(ticker, "average"))
    var vwap interface{} = this.omitZero(this.safeString(ticker, "vwap"))
    var baseVolume interface{} = this.safeString(ticker, "baseVolume")
    var quoteVolume interface{} = this.safeString(ticker, "quoteVolume")
    if IsTrue(IsEqual(vwap, nil)) {
        vwap = Precise.stringDiv(this.omitZero(quoteVolume), baseVolume)
    }
    if IsTrue(IsTrue((!IsEqual(last, nil))) && IsTrue((IsEqual(close, nil)))) {
        close = last
    } else if IsTrue(IsTrue((IsEqual(last, nil))) && IsTrue((!IsEqual(close, nil)))) {
        last = close
    }
    if IsTrue(IsTrue((!IsEqual(last, nil))) && IsTrue((!IsEqual(open, nil)))) {
        if IsTrue(IsEqual(change, nil)) {
            change = Precise.stringSub(last, open)
        }
        if IsTrue(IsEqual(average, nil)) {
            average = Precise.stringDiv(Precise.stringAdd(last, open), "2")
        }
    }
    if IsTrue(IsTrue(IsTrue(IsTrue((IsEqual(percentage, nil))) && IsTrue((!IsEqual(change, nil)))) && IsTrue((!IsEqual(open, nil)))) && IsTrue(Precise.stringGt(open, "0"))) {
        percentage = Precise.stringMul(Precise.stringDiv(change, open), "100")
    }
    if IsTrue(IsTrue(IsTrue((IsEqual(change, nil))) && IsTrue((!IsEqual(percentage, nil)))) && IsTrue((!IsEqual(open, nil)))) {
        change = Precise.stringDiv(Precise.stringMul(percentage, open), "100")
    }
    if IsTrue(IsTrue(IsTrue((IsEqual(open, nil))) && IsTrue((!IsEqual(last, nil)))) && IsTrue((!IsEqual(change, nil)))) {
        open = Precise.stringSub(last, change)
    }
    // timestamp and symbol operations don't belong in safeTicker
    // they should be done in the derived classes
    return this.extend(ticker, map[string]interface{} {
        "bid": this.parseNumber(this.omitZero(this.safeString(ticker, "bid"))),
        "bidVolume": this.safeNumber(ticker, "bidVolume"),
        "ask": this.parseNumber(this.omitZero(this.safeString(ticker, "ask"))),
        "askVolume": this.safeNumber(ticker, "askVolume"),
        "high": this.parseNumber(this.omitZero(this.safeString(ticker, "high"))),
        "low": this.parseNumber(this.omitZero(this.safeString(ticker, "low"))),
        "open": this.parseNumber(this.omitZero(open)),
        "close": this.parseNumber(this.omitZero(close)),
        "last": this.parseNumber(this.omitZero(last)),
        "change": this.parseNumber(change),
        "percentage": this.parseNumber(percentage),
        "average": this.parseNumber(average),
        "vwap": this.parseNumber(vwap),
        "baseVolume": this.parseNumber(baseVolume),
        "quoteVolume": this.parseNumber(quoteVolume),
        "previousClose": this.safeNumber(ticker, "previousClose"),
    })
}
func  (this *Exchange) fetchBorrowRate(code interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchBorrowRate is deprecated, please use fetchCrossBorrowRate or fetchIsolatedBorrowRate instead")))
}
func  (this *Exchange) repayCrossMargin(code interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " repayCrossMargin is not support yet")))
}
func  (this *Exchange) repayIsolatedMargin(symbol interface{}, code interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " repayIsolatedMargin is not support yet")))
}
func  (this *Exchange) borrowCrossMargin(code interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " borrowCrossMargin is not support yet")))
}
func  (this *Exchange) borrowIsolatedMargin(symbol interface{}, code interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " borrowIsolatedMargin is not support yet")))
}
func  (this *Exchange) borrowMargin(code interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 2, nil)
    _ = symbol
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " borrowMargin is deprecated, please use borrowCrossMargin or borrowIsolatedMargin instead")))
}
func  (this *Exchange) repayMargin(code interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 2, nil)
    _ = symbol
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " repayMargin is deprecated, please use repayCrossMargin or repayIsolatedMargin instead")))
}
func  (this *Exchange) fetchOHLCV(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    timeframe := GetArg(optionalArgs, 1, "1m")
    _ = timeframe
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    var message interface{} = ""
    if IsTrue(GetValue(this.has, "fetchTrades")) {
        message = ". If you want to build OHLCV candles from trade executions data, visit https://github.com/ccxt/ccxt/tree/master/examples/ and see \"build-ohlcv-bars\" file"
    }
    panic(NotSupported(Add(Add(this.id, " fetchOHLCV() is not supported yet"), message)))
}
func  (this *Exchange) fetchOHLCVWs(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    timeframe := GetArg(optionalArgs, 1, "1m")
    _ = timeframe
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    var message interface{} = ""
    if IsTrue(GetValue(this.has, "fetchTradesWs")) {
        message = ". If you want to build OHLCV candles from trade executions data, visit https://github.com/ccxt/ccxt/tree/master/examples/ and see \"build-ohlcv-bars\" file"
    }
    panic(NotSupported(Add(Add(this.id, " fetchOHLCVWs() is not supported yet. Try using fetchOHLCV instead."), message)))
}
func  (this *Exchange) watchOHLCV(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    timeframe := GetArg(optionalArgs, 1, "1m")
    _ = timeframe
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchOHLCV() is not supported yet")))
}
func  (this *Exchange) convertTradingViewToOHLCV(ohlcvs interface{}, optionalArgs ...interface{}) interface{}  {
    timestamp := GetArg(optionalArgs, 1, "t")
    _ = timestamp
    open := GetArg(optionalArgs, 2, "o")
    _ = open
    high := GetArg(optionalArgs, 3, "h")
    _ = high
    low := GetArg(optionalArgs, 4, "l")
    _ = low
    close := GetArg(optionalArgs, 5, "c")
    _ = close
    volume := GetArg(optionalArgs, 6, "v")
    _ = volume
    ms := GetArg(optionalArgs, 7, false)
    _ = ms
    var result interface{} = []interface{}{}
    var timestamps interface{} = this.safeList(ohlcvs, timestamp, []interface{}{})
    var opens interface{} = this.safeList(ohlcvs, open, []interface{}{})
    var highs interface{} = this.safeList(ohlcvs, high, []interface{}{})
    var lows interface{} = this.safeList(ohlcvs, low, []interface{}{})
    var closes interface{} = this.safeList(ohlcvs, close, []interface{}{})
    var volumes interface{} = this.safeList(ohlcvs, volume, []interface{}{})
    for i := 0; IsLessThan(i, GetArrayLength(timestamps)); i++ {
        AppendToArray(&result,[]interface{}{Ternary(IsTrue(ms), this.safeInteger(timestamps, i), this.safeTimestamp(timestamps, i)), this.safeValue(opens, i), this.safeValue(highs, i), this.safeValue(lows, i), this.safeValue(closes, i), this.safeValue(volumes, i)})
    }
    return result
}
func  (this *Exchange) convertOHLCVToTradingView(ohlcvs interface{}, optionalArgs ...interface{}) interface{}  {
    timestamp := GetArg(optionalArgs, 1, "t")
    _ = timestamp
    open := GetArg(optionalArgs, 2, "o")
    _ = open
    high := GetArg(optionalArgs, 3, "h")
    _ = high
    low := GetArg(optionalArgs, 4, "l")
    _ = low
    close := GetArg(optionalArgs, 5, "c")
    _ = close
    volume := GetArg(optionalArgs, 6, "v")
    _ = volume
    ms := GetArg(optionalArgs, 7, false)
    _ = ms
    var result interface{} = map[string]interface{} {}
    AddElementToObject(result, timestamp, []interface{}{})
    AddElementToObject(result, open, []interface{}{})
    AddElementToObject(result, high, []interface{}{})
    AddElementToObject(result, low, []interface{}{})
    AddElementToObject(result, close, []interface{}{})
    AddElementToObject(result, volume, []interface{}{})
    for i := 0; IsLessThan(i, GetArrayLength(ohlcvs)); i++ {
        var ts interface{} = Ternary(IsTrue(ms), GetValue(GetValue(ohlcvs, i), 0), this.parseToInt(Divide(GetValue(GetValue(ohlcvs, i), 0), 1000)))
        var resultTimestamp interface{} = GetValue(result, timestamp)
        AppendToArray(&resultTimestamp,ts)
        var resultOpen interface{} = GetValue(result, open)
        AppendToArray(&resultOpen,GetValue(GetValue(ohlcvs, i), 1))
        var resultHigh interface{} = GetValue(result, high)
        AppendToArray(&resultHigh,GetValue(GetValue(ohlcvs, i), 2))
        var resultLow interface{} = GetValue(result, low)
        AppendToArray(&resultLow,GetValue(GetValue(ohlcvs, i), 3))
        var resultClose interface{} = GetValue(result, close)
        AppendToArray(&resultClose,GetValue(GetValue(ohlcvs, i), 4))
        var resultVolume interface{} = GetValue(result, volume)
        AppendToArray(&resultVolume,GetValue(GetValue(ohlcvs, i), 5))
    }
    return result
}
func  (this *Exchange) fetchWebEndpoint(method interface{}, endpointMethod interface{}, returnAsJson interface{}, optionalArgs ...interface{}) interface{}  {
    startRegex := GetArg(optionalArgs, 3, nil)
    _ = startRegex
    endRegex := GetArg(optionalArgs, 4, nil)
    _ = endRegex
    var errorMessage interface{} = ""
    var options interface{} = this.safeValue(this.options, method, map[string]interface{} {})
    var muteOnFailure interface{} = this.safeBool(options, "webApiMuteFailure", true)
    
    {		ret__ := func(this *Exchange) (ret_ interface{}) {
    		defer func() {
    			if e := recover().(interface{}); e != nil {
                    if e == "break" {
    				    return
    			    }
    				ret_ = func(this *Exchange) interface{} {
    					// catch block:
                                errorMessage = Add(Add(Add(this.id, " "), method), "() failed to fetch correct data from website. Probably webpage markup has been changed, breaking the page custom parser.")
    					return nil
    				}(this)
    			}
    		}()
    		// try block:
                    // if it was not explicitly disabled, then don't fetch
            if IsTrue(!IsEqual(this.safeBool(options, "webApiEnable", true), true)) {
                return nil
            }
            var maxRetries interface{} = this.safeValue(options, "webApiRetries", 10)
            var response interface{} = nil
            var retry interface{} = 0
            for IsLessThan(retry, maxRetries) {
                
                {		ret__ := func(this *Exchange) (ret_ interface{}) {
                		defer func() {
                			if e := recover().(interface{}); e != nil {
                                if e == "break" {
                				    return
                			    }
                				ret_ = func(this *Exchange) interface{} {
                					// catch block:
                                                    retry = Add(retry, 1)
                                if IsTrue(IsEqual(retry, maxRetries)) {
                                    panic(e)
                                }
                					return nil
                				}(this)
                			}
                		}()
                		// try block:
                                        response = callDynamically(endpointMethod, map[string]interface{} {})
                                panic("break")
                		return nil
                	}(this)
                	if ret__ != nil {
                		return ret__
                	}
                }
            }
            var content interface{} = response
            if IsTrue(!IsEqual(startRegex, nil)) {
                var splitted_by_start interface{} = Split(content, startRegex)
                content = GetValue(splitted_by_start, 1) // we need second part after start
            }
            if IsTrue(!IsEqual(endRegex, nil)) {
                var splitted_by_end interface{} = Split(content, endRegex)
                content = GetValue(splitted_by_end, 0) // we need first part after start
            }
            if IsTrue(IsTrue(returnAsJson) && IsTrue((IsString(content)))) {
                var jsoned interface{} = this.parseJson(Trim(content)) // content should be trimmed before json parsing
                if IsTrue(jsoned) {
                    return jsoned  // if parsing was not successfull, exception should be thrown
                } else {
                    panic(BadResponse("could not parse the response into json"))
                }
            } else {
                return content
            }
    		return nil
    	}(this)
    	if ret__ != nil {
    		return ret__
    	}
    }
    if IsTrue(muteOnFailure) {
        return nil
    } else {
        panic(BadResponse(errorMessage))
    }
}
func  (this *Exchange) marketIds(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    if IsTrue(IsEqual(symbols, nil)) {
        return symbols
    }
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
        AppendToArray(&result,this.marketId(GetValue(symbols, i)))
    }
    return result
}
func  (this *Exchange) marketsForSymbols(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    if IsTrue(IsEqual(symbols, nil)) {
        return symbols
    }
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
        AppendToArray(&result,this.market(GetValue(symbols, i)))
    }
    return result
}
func  (this *Exchange) marketSymbols(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    typeVar := GetArg(optionalArgs, 1, nil)
    _ = typeVar
    allowEmpty := GetArg(optionalArgs, 2, true)
    _ = allowEmpty
    sameTypeOnly := GetArg(optionalArgs, 3, false)
    _ = sameTypeOnly
    sameSubTypeOnly := GetArg(optionalArgs, 4, false)
    _ = sameSubTypeOnly
    if IsTrue(IsEqual(symbols, nil)) {
        if !IsTrue(allowEmpty) {
            panic(ArgumentsRequired(Add(this.id, " empty list of symbols is not supported")))
        }
        return symbols
    }
    var symbolsLength interface{} =     GetArrayLength(symbols)
    if IsTrue(IsEqual(symbolsLength, 0)) {
        if !IsTrue(allowEmpty) {
            panic(ArgumentsRequired(Add(this.id, " empty list of symbols is not supported")))
        }
        return symbols
    }
    var result interface{} = []interface{}{}
    var marketType interface{} = nil
    var isLinearSubType interface{} = nil
    for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
        var market interface{} = this.market(GetValue(symbols, i))
        if IsTrue(IsTrue(sameTypeOnly) && IsTrue((!IsEqual(marketType, nil)))) {
            if IsTrue(!IsEqual(GetValue(market, "type"), marketType)) {
                panic(BadRequest(Add(Add(Add(Add(Add(this.id, " symbols must be of the same type, either "), marketType), " or "), GetValue(market, "type")), ".")))
            }
        }
        if IsTrue(IsTrue(sameSubTypeOnly) && IsTrue((!IsEqual(isLinearSubType, nil)))) {
            if IsTrue(!IsEqual(GetValue(market, "linear"), isLinearSubType)) {
                panic(BadRequest(Add(this.id, " symbols must be of the same subType, either linear or inverse.")))
            }
        }
        if IsTrue(IsTrue(!IsEqual(typeVar, nil)) && IsTrue(!IsEqual(GetValue(market, "type"), typeVar))) {
            panic(BadRequest(Add(Add(Add(this.id, " symbols must be of the same type "), typeVar), ". If the type is incorrect you can change it in options or the params of the request")))
        }
        marketType = GetValue(market, "type")
        if !IsTrue(GetValue(market, "spot")) {
            isLinearSubType = GetValue(market, "linear")
        }
        var symbol interface{} = this.safeString(market, "symbol", GetValue(symbols, i))
        AppendToArray(&result,symbol)
    }
    return result
}
func  (this *Exchange) marketCodes(optionalArgs ...interface{}) interface{}  {
    codes := GetArg(optionalArgs, 0, nil)
    _ = codes
    if IsTrue(IsEqual(codes, nil)) {
        return codes
    }
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(codes)); i++ {
        AppendToArray(&result,this.commonCurrencyCode(GetValue(codes, i)))
    }
    return result
}
func  (this *Exchange) parseBidsAsks(bidasks interface{}, optionalArgs ...interface{}) interface{}  {
    priceKey := GetArg(optionalArgs, 1, 0)
    _ = priceKey
    amountKey := GetArg(optionalArgs, 2, 1)
    _ = amountKey
    countOrIdKey := GetArg(optionalArgs, 3, 2)
    _ = countOrIdKey
    bidasks = this.toArray(bidasks)
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(bidasks)); i++ {
        AppendToArray(&result,this.parseBidAsk(GetValue(bidasks, i), priceKey, amountKey, countOrIdKey))
    }
    return result
}
func  (this *Exchange) fetchL2OrderBook(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    limit := GetArg(optionalArgs, 1, nil)
    _ = limit
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    var orderbook interface{} = this.fetchOrderBook(symbol, limit, params)
    return this.extend(orderbook, map[string]interface{} {
        "asks": this.sortBy(this.aggregate(GetValue(orderbook, "asks")), 0),
        "bids": this.sortBy(this.aggregate(GetValue(orderbook, "bids")), 0, true),
    })
}
func  (this *Exchange) filterBySymbol(objects interface{}, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    if IsTrue(IsEqual(symbol, nil)) {
        return objects
    }
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(objects)); i++ {
        var objectSymbol interface{} = this.safeString(GetValue(objects, i), "symbol")
        if IsTrue(IsEqual(objectSymbol, symbol)) {
            AppendToArray(&result,GetValue(objects, i))
        }
    }
    return result
}
func  (this *Exchange) parseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    if IsTrue(IsArray(ohlcv)) {
        return []interface{}{this.safeInteger(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 5)}
    }
    return ohlcv
}
func  (this *Exchange) networkCodeToId(networkCode interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @name exchange#networkCodeToId
    * @description tries to convert the provided networkCode (which is expected to be an unified network code) to a network id. In order to achieve this, derived class needs to have 'options->networks' defined.
    * @param {string} networkCode unified network code
    * @param {string} currencyCode unified currency code, but this argument is not required by default, unless there is an exchange (like huobi) that needs an override of the method to be able to pass currencyCode argument additionally
    * @returns {string|undefined} exchange-specific network id
    */
    currencyCode := GetArg(optionalArgs, 1, nil)
    _ = currencyCode
    if IsTrue(IsEqual(networkCode, nil)) {
        return nil
    }
    var networkIdsByCodes interface{} = this.safeValue(this.options, "networks", map[string]interface{} {})
    var networkId interface{} = this.safeString(networkIdsByCodes, networkCode)
    // for example, if 'ETH' is passed for networkCode, but 'ETH' key not defined in `options->networks` object
    if IsTrue(IsEqual(networkId, nil)) {
        if IsTrue(IsEqual(currencyCode, nil)) {
            var currencies interface{} = ObjectValues(this.currencies)
            for i := 0; IsLessThan(i, GetArrayLength(currencies)); i++ {
                var currency interface{} = []interface{}{i}
                var networks interface{} = this.safeDict(currency, "networks")
                var network interface{} = this.safeDict(networks, networkCode)
                networkId = this.safeString(network, "id")
                if IsTrue(!IsEqual(networkId, nil)) {
                    break
                }
            }
        } else {
            // if currencyCode was provided, then we try to find if that currencyCode has a replacement (i.e. ERC20 for ETH) or is in the currency
            var defaultNetworkCodeReplacements interface{} = this.safeValue(this.options, "defaultNetworkCodeReplacements", map[string]interface{} {})
            if IsTrue(InOp(defaultNetworkCodeReplacements, currencyCode)) {
                // if there is a replacement for the passed networkCode, then we use it to find network-id in `options->networks` object
                var replacementObject interface{} = GetValue(defaultNetworkCodeReplacements, currencyCode) // i.e. { 'ERC20': 'ETH' }
                var keys interface{} = ObjectKeys(replacementObject)
                for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
                    var key interface{} = GetValue(keys, i)
                    var value interface{} = GetValue(replacementObject, key)
                    // if value matches to provided unified networkCode, then we use it's key to find network-id in `options->networks` object
                    if IsTrue(IsEqual(value, networkCode)) {
                        networkId = this.safeString(networkIdsByCodes, key)
                        break
                    }
                }
            } else {
                // serach for network inside currency
                var currency interface{} = this.safeDict(this.currencies, currencyCode)
                var networks interface{} = this.safeDict(currency, "networks")
                var network interface{} = this.safeDict(networks, networkCode)
                networkId = this.safeString(network, "id")
            }
        }
        // if it wasn't found, we just set the provided value to network-id
        if IsTrue(IsEqual(networkId, nil)) {
            networkId = networkCode
        }
    }
    return networkId
}
func  (this *Exchange) networkIdToCode(optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @name exchange#networkIdToCode
    * @description tries to convert the provided exchange-specific networkId to an unified network Code. In order to achieve this, derived class needs to have "options['networksById']" defined.
    * @param {string} networkId exchange specific network id/title, like: TRON, Trc-20, usdt-erc20, etc
    * @param {string|undefined} currencyCode unified currency code, but this argument is not required by default, unless there is an exchange (like huobi) that needs an override of the method to be able to pass currencyCode argument additionally
    * @returns {string|undefined} unified network code
    */
    networkId := GetArg(optionalArgs, 0, nil)
    _ = networkId
    currencyCode := GetArg(optionalArgs, 1, nil)
    _ = currencyCode
    if IsTrue(IsEqual(networkId, nil)) {
        return nil
    }
    var networkCodesByIds interface{} = this.safeDict(this.options, "networksById", map[string]interface{} {})
    var networkCode interface{} = this.safeString(networkCodesByIds, networkId, networkId)
    // replace mainnet network-codes (i.e. ERC20->ETH)
    if IsTrue(!IsEqual(currencyCode, nil)) {
        var defaultNetworkCodeReplacements interface{} = this.safeDict(this.options, "defaultNetworkCodeReplacements", map[string]interface{} {})
        if IsTrue(InOp(defaultNetworkCodeReplacements, currencyCode)) {
            var replacementObject interface{} = this.safeDict(defaultNetworkCodeReplacements, currencyCode, map[string]interface{} {})
            networkCode = this.safeString(replacementObject, networkCode, networkCode)
        }
    }
    return networkCode
}
func  (this *Exchange) handleNetworkCodeAndParams(params interface{}) interface{}  {
    var networkCodeInParams interface{} = this.safeString2(params, "networkCode", "network")
    if IsTrue(!IsEqual(networkCodeInParams, nil)) {
        params = this.omit(params, []interface{}{"networkCode", "network"})
    }
    // if it was not defined by user, we should not set it from 'defaultNetworks', because handleNetworkCodeAndParams is for only request-side and thus we do not fill it with anything. We can only use 'defaultNetworks' after parsing response-side
    return []interface{}{networkCodeInParams, params}
}
func  (this *Exchange) defaultNetworkCode(currencyCode interface{}) interface{}  {
    var defaultNetworkCode interface{} = nil
    var defaultNetworks interface{} = this.safeDict(this.options, "defaultNetworks", map[string]interface{} {})
    if IsTrue(InOp(defaultNetworks, currencyCode)) {
        // if currency had set its network in "defaultNetworks", use it
        defaultNetworkCode = GetValue(defaultNetworks, currencyCode)
    } else {
        // otherwise, try to use the global-scope 'defaultNetwork' value (even if that network is not supported by currency, it doesn't make any problem, this will be just used "at first" if currency supports this network at all)
        var defaultNetwork interface{} = this.safeDict(this.options, "defaultNetwork")
        if IsTrue(!IsEqual(defaultNetwork, nil)) {
            defaultNetworkCode = defaultNetwork
        }
    }
    return defaultNetworkCode
}
func  (this *Exchange) selectNetworkCodeFromUnifiedNetworks(currencyCode interface{}, networkCode interface{}, indexedNetworkEntries interface{}) interface{}  {
    return this.selectNetworkKeyFromNetworks(currencyCode, networkCode, indexedNetworkEntries, true)
}
func  (this *Exchange) selectNetworkIdFromRawNetworks(currencyCode interface{}, networkCode interface{}, indexedNetworkEntries interface{}) interface{}  {
    return this.selectNetworkKeyFromNetworks(currencyCode, networkCode, indexedNetworkEntries, false)
}
func  (this *Exchange) selectNetworkKeyFromNetworks(currencyCode interface{}, networkCode interface{}, indexedNetworkEntries interface{}, optionalArgs ...interface{}) interface{}  {
    // this method is used against raw & unparse network entries, which are just indexed by network id
    isIndexedByUnifiedNetworkCode := GetArg(optionalArgs, 3, false)
    _ = isIndexedByUnifiedNetworkCode
    var chosenNetworkId interface{} = nil
    var availableNetworkIds interface{} = ObjectKeys(indexedNetworkEntries)
    var responseNetworksLength interface{} =     GetArrayLength(availableNetworkIds)
    if IsTrue(!IsEqual(networkCode, nil)) {
        if IsTrue(IsEqual(responseNetworksLength, 0)) {
            panic(NotSupported(Add(Add(Add(Add(this.id, " - "), networkCode), " network did not return any result for "), currencyCode)))
        } else {
            // if networkCode was provided by user, we should check it after response, as the referenced exchange doesn't support network-code during request
            var networkId interface{} = Ternary(IsTrue(isIndexedByUnifiedNetworkCode), networkCode, this.networkCodeToId(networkCode, currencyCode))
            if IsTrue(InOp(indexedNetworkEntries, networkId)) {
                chosenNetworkId = networkId
            } else {
                panic(NotSupported(Add(Add(Add(Add(Add(Add(this.id, " - "), networkId), " network was not found for "), currencyCode), ", use one of "), Join(availableNetworkIds, ", "))))
            }
        }
    } else {
        if IsTrue(IsEqual(responseNetworksLength, 0)) {
            panic(NotSupported(Add(Add(this.id, " - no networks were returned for "), currencyCode)))
        } else {
            // if networkCode was not provided by user, then we try to use the default network (if it was defined in "defaultNetworks"), otherwise, we just return the first network entry
            var defaultNetworkCode interface{} = this.defaultNetworkCode(currencyCode)
            var defaultNetworkId interface{} = Ternary(IsTrue(isIndexedByUnifiedNetworkCode), defaultNetworkCode, this.networkCodeToId(defaultNetworkCode, currencyCode))
            chosenNetworkId = Ternary(IsTrue((InOp(indexedNetworkEntries, defaultNetworkId))), defaultNetworkId, GetValue(availableNetworkIds, 0))
        }
    }
    return chosenNetworkId
}
func  (this *Exchange) safeNumber2(dictionary interface{}, key1 interface{}, key2 interface{}, optionalArgs ...interface{}) interface{}  {
    d := GetArg(optionalArgs, 3, nil)
    _ = d
    var value interface{} = this.safeString2(dictionary, key1, key2)
    return this.parseNumber(value, d)
}
func  (this *Exchange) parseOrderBook(orderbook interface{}, symbol interface{}, optionalArgs ...interface{}) interface{}  {
    timestamp := GetArg(optionalArgs, 2, nil)
    _ = timestamp
    bidsKey := GetArg(optionalArgs, 3, "bids")
    _ = bidsKey
    asksKey := GetArg(optionalArgs, 4, "asks")
    _ = asksKey
    priceKey := GetArg(optionalArgs, 5, 0)
    _ = priceKey
    amountKey := GetArg(optionalArgs, 6, 1)
    _ = amountKey
    countOrIdKey := GetArg(optionalArgs, 7, 2)
    _ = countOrIdKey
    var bids interface{} = this.parseBidsAsks(this.safeValue(orderbook, bidsKey, []interface{}{}), priceKey, amountKey, countOrIdKey)
    var asks interface{} = this.parseBidsAsks(this.safeValue(orderbook, asksKey, []interface{}{}), priceKey, amountKey, countOrIdKey)
    return map[string]interface{} {
        "symbol": symbol,
        "bids": this.sortBy(bids, 0, true),
        "asks": this.sortBy(asks, 0),
        "timestamp": timestamp,
        "datetime": this.iso8601(timestamp),
        "nonce": nil,
    }
}
func  (this *Exchange) parseOHLCVs(ohlcvs interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    timeframe := GetArg(optionalArgs, 2, "1m")
    _ = timeframe
    since := GetArg(optionalArgs, 3, nil)
    _ = since
    limit := GetArg(optionalArgs, 4, nil)
    _ = limit
    var results interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(ohlcvs)); i++ {
        AppendToArray(&results,this.parseOHLCV(GetValue(ohlcvs, i), market))
    }
    var sorted interface{} = this.sortBy(results, 0)
    return this.filterBySinceLimit(sorted, since, limit, 0)
}
func  (this *Exchange) parseLeverageTiers(response interface{}, optionalArgs ...interface{}) interface{}  {
    // marketIdKey should only be undefined when response is a dictionary
    symbols := GetArg(optionalArgs, 1, nil)
    _ = symbols
    marketIdKey := GetArg(optionalArgs, 2, nil)
    _ = marketIdKey
    symbols = this.marketSymbols(symbols)
    var tiers interface{} = map[string]interface{} {}
    var symbolsLength interface{} = 0
    if IsTrue(!IsEqual(symbols, nil)) {
        symbolsLength = GetArrayLength(symbols)
    }
    var noSymbols interface{} = IsTrue((IsEqual(symbols, nil))) || IsTrue((IsEqual(symbolsLength, 0)))
    if IsTrue(IsArray(response)) {
        for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
            var item interface{} = GetValue(response, i)
            var id interface{} = this.safeString(item, marketIdKey)
            var market interface{} = this.safeMarket(id, nil, nil, "swap")
            var symbol interface{} = GetValue(market, "symbol")
            var contract interface{} = this.safeBool(market, "contract", false)
            if IsTrue(IsTrue(contract) && IsTrue((IsTrue(noSymbols) || IsTrue(this.inArray(symbol, symbols))))) {
                AddElementToObject(tiers, symbol, this.parseMarketLeverageTiers(item, market))
            }
        }
    } else {
        var keys interface{} = ObjectKeys(response)
        for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
            var marketId interface{} = GetValue(keys, i)
            var item interface{} = GetValue(response, marketId)
            var market interface{} = this.safeMarket(marketId, nil, nil, "swap")
            var symbol interface{} = GetValue(market, "symbol")
            var contract interface{} = this.safeBool(market, "contract", false)
            if IsTrue(IsTrue(contract) && IsTrue((IsTrue(noSymbols) || IsTrue(this.inArray(symbol, symbols))))) {
                AddElementToObject(tiers, symbol, this.parseMarketLeverageTiers(item, market))
            }
        }
    }
    return tiers
}
func  (this *Exchange) loadTradingLimits(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    reload := GetArg(optionalArgs, 1, false)
    _ = reload
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchTradingLimits")) {
        if IsTrue(IsTrue(reload) || !IsTrue((InOp(this.options, "limitsLoaded")))) {
            var response interface{} = this.fetchTradingLimits(symbols)
            for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
                var symbol interface{} = GetValue(symbols, i)
                AddElementToObject(this.markets, symbol, this.deepExtend(GetValue(this.markets, symbol), GetValue(response, symbol)))
            }
            AddElementToObject(this.options, "limitsLoaded", this.milliseconds())
        }
    }
    return this.markets
}
func  (this *Exchange) safePosition(position interface{}) interface{}  {
    // simplified version of: /pull/12765/
    var unrealizedPnlString interface{} = this.safeString(position, "unrealisedPnl")
    var initialMarginString interface{} = this.safeString(position, "initialMargin")
    //
    // PERCENTAGE
    //
    var percentage interface{} = this.safeValue(position, "percentage")
    if IsTrue(IsTrue(IsTrue((IsEqual(percentage, nil))) && IsTrue((!IsEqual(unrealizedPnlString, nil)))) && IsTrue((!IsEqual(initialMarginString, nil)))) {
        // as it was done in all implementations ( aax, btcex, bybit, deribit, ftx, gate, kucoinfutures, phemex )
        var percentageString interface{} = Precise.stringMul(Precise.stringDiv(unrealizedPnlString, initialMarginString, 4), "100")
        AddElementToObject(position, "percentage", this.parseNumber(percentageString))
    }
    // if contractSize is undefined get from market
    var contractSize interface{} = this.safeNumber(position, "contractSize")
    var symbol interface{} = this.safeString(position, "symbol")
    var market interface{} = nil
    if IsTrue(!IsEqual(symbol, nil)) {
        market = this.safeValue(this.markets, symbol)
    }
    if IsTrue(IsTrue(IsEqual(contractSize, nil)) && IsTrue(!IsEqual(market, nil))) {
        contractSize = this.safeNumber(market, "contractSize")
        AddElementToObject(position, "contractSize", contractSize)
    }
    return position
}
func  (this *Exchange) parsePositions(positions interface{}, optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 1, nil)
    _ = symbols
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    symbols = this.marketSymbols(symbols)
    positions = this.toArray(positions)
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(positions)); i++ {
        var position interface{} = this.extend(this.parsePosition(GetValue(positions, i), nil), params)
        AppendToArray(&result,position)
    }
    return this.filterByArrayPositions(result, "symbol", symbols, false)
}
func  (this *Exchange) parseAccounts(accounts interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    accounts = this.toArray(accounts)
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(accounts)); i++ {
        var account interface{} = this.extend(this.parseAccount(GetValue(accounts, i)), params)
        AppendToArray(&result,account)
    }
    return result
}
func  (this *Exchange) parseTrades(trades interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    trades = this.toArray(trades)
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(trades)); i++ {
        var trade interface{} = this.extend(this.parseTrade(GetValue(trades, i), market), params)
        AppendToArray(&result,trade)
    }
    result = this.sortBy2(result, "timestamp", "id")
    var symbol interface{} = Ternary(IsTrue((!IsEqual(market, nil))), GetValue(market, "symbol"), nil)
    return this.filterBySymbolSinceLimit(result, symbol, since, limit)
}
func  (this *Exchange) parseTransactions(transactions interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 1, nil)
    _ = currency
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    transactions = this.toArray(transactions)
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(transactions)); i++ {
        var transaction interface{} = this.extend(this.parseTransaction(GetValue(transactions, i), currency), params)
        AppendToArray(&result,transaction)
    }
    result = this.sortBy(result, "timestamp")
    var code interface{} = Ternary(IsTrue((!IsEqual(currency, nil))), GetValue(currency, "code"), nil)
    return this.filterByCurrencySinceLimit(result, code, since, limit)
}
func  (this *Exchange) parseTransfers(transfers interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 1, nil)
    _ = currency
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    transfers = this.toArray(transfers)
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(transfers)); i++ {
        var transfer interface{} = this.extend(this.parseTransfer(GetValue(transfers, i), currency), params)
        AppendToArray(&result,transfer)
    }
    result = this.sortBy(result, "timestamp")
    var code interface{} = Ternary(IsTrue((!IsEqual(currency, nil))), GetValue(currency, "code"), nil)
    return this.filterByCurrencySinceLimit(result, code, since, limit)
}
func  (this *Exchange) parseLedger(data interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 1, nil)
    _ = currency
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    var result interface{} = []interface{}{}
    var arrayData interface{} = this.toArray(data)
    for i := 0; IsLessThan(i, GetArrayLength(arrayData)); i++ {
        var itemOrItems interface{} = this.parseLedgerEntry(GetValue(arrayData, i), currency)
        if IsTrue(IsArray(itemOrItems)) {
            for j := 0; IsLessThan(j, GetArrayLength(itemOrItems)); j++ {
                AppendToArray(&result,this.extend(GetValue(itemOrItems, j), params))
            }
        } else {
            AppendToArray(&result,this.extend(itemOrItems, params))
        }
    }
    result = this.sortBy(result, "timestamp")
    var code interface{} = Ternary(IsTrue((!IsEqual(currency, nil))), GetValue(currency, "code"), nil)
    return this.filterByCurrencySinceLimit(result, code, since, limit)
}
func  (this *Exchange) nonce() interface{}  {
    return this.seconds()
}
func  (this *Exchange) setHeaders(headers interface{}) interface{}  {
    return headers
}
func  (this *Exchange) marketId(symbol interface{}) interface{}  {
    var market interface{} = this.market(symbol)
    if IsTrue(!IsEqual(market, nil)) {
        return GetValue(market, "id")
    }
    return symbol
}
func  (this *Exchange) symbol(symbol interface{}) interface{}  {
    var market interface{} = this.market(symbol)
    return this.safeString(market, "symbol", symbol)
}
func  (this *Exchange) handleParamString(params interface{}, paramName interface{}, optionalArgs ...interface{}) interface{}  {
    defaultValue := GetArg(optionalArgs, 2, nil)
    _ = defaultValue
    var value interface{} = this.safeString(params, paramName, defaultValue)
    if IsTrue(!IsEqual(value, nil)) {
        params = this.omit(params, paramName)
    }
    return []interface{}{value, params}
}
func  (this *Exchange) handleParamString2(params interface{}, paramName1 interface{}, paramName2 interface{}, optionalArgs ...interface{}) interface{}  {
    defaultValue := GetArg(optionalArgs, 3, nil)
    _ = defaultValue
    var value interface{} = this.safeString2(params, paramName1, paramName2, defaultValue)
    if IsTrue(!IsEqual(value, nil)) {
        params = this.omit(params, []interface{}{paramName1, paramName2})
    }
    return []interface{}{value, params}
}
func  (this *Exchange) handleParamInteger(params interface{}, paramName interface{}, optionalArgs ...interface{}) interface{}  {
    defaultValue := GetArg(optionalArgs, 2, nil)
    _ = defaultValue
    var value interface{} = this.safeInteger(params, paramName, defaultValue)
    if IsTrue(!IsEqual(value, nil)) {
        params = this.omit(params, paramName)
    }
    return []interface{}{value, params}
}
func  (this *Exchange) handleParamInteger2(params interface{}, paramName1 interface{}, paramName2 interface{}, optionalArgs ...interface{}) interface{}  {
    defaultValue := GetArg(optionalArgs, 3, nil)
    _ = defaultValue
    var value interface{} = this.safeInteger2(params, paramName1, paramName2, defaultValue)
    if IsTrue(!IsEqual(value, nil)) {
        params = this.omit(params, []interface{}{paramName1, paramName2})
    }
    return []interface{}{value, params}
}
func  (this *Exchange) handleParamBool(params interface{}, paramName interface{}, optionalArgs ...interface{}) interface{}  {
    defaultValue := GetArg(optionalArgs, 2, nil)
    _ = defaultValue
    var value interface{} = this.safeBool(params, paramName, defaultValue)
    if IsTrue(!IsEqual(value, nil)) {
        params = this.omit(params, paramName)
    }
    return []interface{}{value, params}
}
func  (this *Exchange) handleParamBool2(params interface{}, paramName1 interface{}, paramName2 interface{}, optionalArgs ...interface{}) interface{}  {
    defaultValue := GetArg(optionalArgs, 3, nil)
    _ = defaultValue
    var value interface{} = this.safeBool2(params, paramName1, paramName2, defaultValue)
    if IsTrue(!IsEqual(value, nil)) {
        params = this.omit(params, []interface{}{paramName1, paramName2})
    }
    return []interface{}{value, params}
}
func  (this *Exchange) resolvePath(path interface{}, params interface{}) interface{}  {
    return []interface{}{this.implodeParams(path, params), this.omit(params, this.extractParams(path))}
}
func  (this *Exchange) getListFromObjectValues(objects interface{}, key interface{}) interface{}  {
    var newArray interface{} = this.toArray(objects)
    var results interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(newArray)); i++ {
        AppendToArray(&results,GetValue(GetValue(newArray, i), key))
    }
    return results
}
func  (this *Exchange) getSymbolsForMarketType(optionalArgs ...interface{}) interface{}  {
    marketType := GetArg(optionalArgs, 0, nil)
    _ = marketType
    subType := GetArg(optionalArgs, 1, nil)
    _ = subType
    symbolWithActiveStatus := GetArg(optionalArgs, 2, true)
    _ = symbolWithActiveStatus
    symbolWithUnknownStatus := GetArg(optionalArgs, 3, true)
    _ = symbolWithUnknownStatus
    var filteredMarkets interface{} = this.markets
    if IsTrue(!IsEqual(marketType, nil)) {
        filteredMarkets = this.filterBy(filteredMarkets, "type", marketType)
    }
    if IsTrue(!IsEqual(subType, nil)) {
        this.checkRequiredArgument("getSymbolsForMarketType", subType, "subType", []interface{}{"linear", "inverse", "quanto"})
        filteredMarkets = this.filterBy(filteredMarkets, "subType", subType)
    }
    var activeStatuses interface{} = []interface{}{}
    if IsTrue(symbolWithActiveStatus) {
        AppendToArray(&activeStatuses,true)
    }
    if IsTrue(symbolWithUnknownStatus) {
        AppendToArray(&activeStatuses,nil)
    }
    filteredMarkets = this.filterByArray(filteredMarkets, "active", activeStatuses, false)
    return this.getListFromObjectValues(filteredMarkets, "symbol")
}
func  (this *Exchange) filterByArray(objects interface{}, key interface{}, optionalArgs ...interface{}) interface{}  {
    values := GetArg(optionalArgs, 2, nil)
    _ = values
    indexed := GetArg(optionalArgs, 3, true)
    _ = indexed
    objects = this.toArray(objects)
    // return all of them if no values were passed
    if IsTrue(IsTrue(IsEqual(values, nil)) || !IsTrue(values)) {
        return Ternary(IsTrue(indexed), this.indexBy(objects, key), objects)
    }
    var results interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(objects)); i++ {
        if IsTrue(this.inArray(GetValue(GetValue(objects, i), key), values)) {
            AppendToArray(&results,GetValue(objects, i))
        }
    }
    return Ternary(IsTrue(indexed), this.indexBy(results, key), results)
}
func  (this *Exchange) fetch2(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 1, "public")
    _ = api
    method := GetArg(optionalArgs, 2, "GET")
    _ = method
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 4, nil)
    _ = headers
    body := GetArg(optionalArgs, 5, nil)
    _ = body
    config := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = config
    if IsTrue(this.enableRateLimit) {
        var cost interface{} = this.calculateRateLimiterCost(api, method, path, params, config)
        this.throttle(cost)
    }
    this.lastRestRequestTimestamp = this.milliseconds()
    var request interface{} = this.sign(path, api, method, params, headers, body)
    this.last_request_headers = GetValue(request, "headers")
    this.last_request_body = GetValue(request, "body")
    this.last_request_url = GetValue(request, "url")
    return this.fetch(GetValue(request, "url"), GetValue(request, "method"), GetValue(request, "headers"), GetValue(request, "body"))
}
func  (this *Exchange) request(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 1, "public")
    _ = api
    method := GetArg(optionalArgs, 2, "GET")
    _ = method
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 4, nil)
    _ = headers
    body := GetArg(optionalArgs, 5, nil)
    _ = body
    config := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = config
    return this.fetch2(path, api, method, params, headers, body, config)
}
func  (this *Exchange) loadAccounts(optionalArgs ...interface{}) interface{}  {
    reload := GetArg(optionalArgs, 0, false)
    _ = reload
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    if IsTrue(reload) {
        this.accounts = this.fetchAccounts(params)
    } else {
        if IsTrue(this.accounts) {
            return this.accounts
        } else {
            this.accounts = this.fetchAccounts(params)
        }
    }
    this.accountsById = this.indexBy(this.accounts, "id")
    return this.accounts
}
func  (this *Exchange) buildOHLCVC(trades interface{}, optionalArgs ...interface{}) interface{}  {
    // given a sorted arrays of trades (recent last) and a timeframe builds an array of OHLCV candles
    // note, default limit value (2147483647) is max int32 value
    timeframe := GetArg(optionalArgs, 1, "1m")
    _ = timeframe
    since := GetArg(optionalArgs, 2, 0)
    _ = since
    limit := GetArg(optionalArgs, 3, 2147483647)
    _ = limit
    var ms interface{} = Multiply(this.parseTimeframe(timeframe), 1000)
    var ohlcvs interface{} = []interface{}{}
    var i_timestamp interface{} = 0
    // const open = 1;
    var i_high interface{} = 2
    var i_low interface{} = 3
    var i_close interface{} = 4
    var i_volume interface{} = 5
    var i_count interface{} = 6
    var tradesLength interface{} =     GetArrayLength(trades)
    var oldest interface{} = mathMin(tradesLength, limit)
    for i := 0; IsLessThan(i, oldest); i++ {
        var trade interface{} = GetValue(trades, i)
        var ts interface{} = GetValue(trade, "timestamp")
        if IsTrue(IsLessThan(ts, since)) {
            continue
        }
        var openingTime interface{} = Multiply(MathFloor(Divide(ts, ms)), ms) // shift to the edge of m/h/d (but not M)
        if IsTrue(IsLessThan(openingTime, since)) {
            continue
        }
        var ohlcv_length interface{} =         GetArrayLength(ohlcvs)
        var candle interface{} = Subtract(ohlcv_length, 1)
        if IsTrue(IsTrue((IsEqual(candle, OpNeg(IsTrue(1))))) || IsTrue((IsGreaterThanOrEqual(openingTime, this.sum(GetValue(GetValue(ohlcvs, candle), i_timestamp), ms))))) {
            // moved to a new timeframe -> create a new candle from opening trade
            AppendToArray(&ohlcvs,[]interface{}{openingTime, GetValue(trade, "price"), GetValue(trade, "price"), GetValue(trade, "price"), GetValue(trade, "price"), GetValue(trade, "amount"), 1})
        } else {
            // still processing the same timeframe -> update opening trade
            AddElementToObject(GetValue(ohlcvs, candle), i_high, mathMax(GetValue(GetValue(ohlcvs, candle), i_high), GetValue(trade, "price")))
            AddElementToObject(GetValue(ohlcvs, candle), i_low, mathMin(GetValue(GetValue(ohlcvs, candle), i_low), GetValue(trade, "price")))
            AddElementToObject(GetValue(ohlcvs, candle), i_close, GetValue(trade, "price"))
            AddElementToObject(GetValue(ohlcvs, candle), i_volume, this.sum(GetValue(GetValue(ohlcvs, candle), i_volume), GetValue(trade, "amount")))
            AddElementToObject(GetValue(ohlcvs, candle), i_count, this.sum(GetValue(GetValue(ohlcvs, candle), i_count), 1))
        }
    }
    return ohlcvs
}
func  (this *Exchange) parseTradingViewOHLCV(ohlcvs interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    timeframe := GetArg(optionalArgs, 2, "1m")
    _ = timeframe
    since := GetArg(optionalArgs, 3, nil)
    _ = since
    limit := GetArg(optionalArgs, 4, nil)
    _ = limit
    var result interface{} = this.convertTradingViewToOHLCV(ohlcvs)
    return this.parseOHLCVs(result, market, timeframe, since, limit)
}
func  (this *Exchange) editLimitBuyOrder(id interface{}, symbol interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 3, nil)
    _ = price
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    return this.editLimitOrder(id, symbol, "buy", amount, price, params)
}
func  (this *Exchange) editLimitSellOrder(id interface{}, symbol interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 3, nil)
    _ = price
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    return this.editLimitOrder(id, symbol, "sell", amount, price, params)
}
func  (this *Exchange) editLimitOrder(id interface{}, symbol interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    params := GetArg(optionalArgs, 5, map[string]interface{} {})
    _ = params
    return this.editOrder(id, symbol, "limit", side, amount, price, params)
}
func  (this *Exchange) editOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) interface{}  {
    amount := GetArg(optionalArgs, 4, nil)
    _ = amount
    price := GetArg(optionalArgs, 5, nil)
    _ = price
    params := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = params
    this.cancelOrder(id, symbol)
    return this.createOrder(symbol, typeVar, side, amount, price, params)
}
func  (this *Exchange) editOrderWs(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) interface{}  {
    amount := GetArg(optionalArgs, 4, nil)
    _ = amount
    price := GetArg(optionalArgs, 5, nil)
    _ = price
    params := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = params
    this.cancelOrderWs(id, symbol)
    return this.createOrderWs(symbol, typeVar, side, amount, price, params)
}
func  (this *Exchange) fetchPermissions(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchPermissions() is not supported yet")))
}
func  (this *Exchange) fetchPosition(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchPosition() is not supported yet")))
}
func  (this *Exchange) fetchPositionWs(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchPositionWs() is not supported yet")))
}
func  (this *Exchange) watchPosition(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchPosition() is not supported yet")))
}
func  (this *Exchange) watchPositions(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchPositions() is not supported yet")))
}
func  (this *Exchange) watchPositionForSymbols(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    return this.watchPositions(symbols, since, limit, params)
}
func  (this *Exchange) fetchPositionsForSymbol(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchPositionsForSymbol() is not supported yet")))
}
func  (this *Exchange) fetchPositionsForSymbolWs(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchPositionsForSymbol() is not supported yet")))
}
func  (this *Exchange) fetchPositions(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchPositions() is not supported yet")))
}
func  (this *Exchange) fetchPositionsWs(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchPositions() is not supported yet")))
}
func  (this *Exchange) fetchPositionsRisk(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchPositionsRisk() is not supported yet")))
}
func  (this *Exchange) fetchBidsAsks(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchBidsAsks() is not supported yet")))
}
func  (this *Exchange) fetchBorrowInterest(optionalArgs ...interface{}) interface{}  {
    code := GetArg(optionalArgs, 0, nil)
    _ = code
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchBorrowInterest() is not supported yet")))
}
func  (this *Exchange) fetchLedger(optionalArgs ...interface{}) interface{}  {
    code := GetArg(optionalArgs, 0, nil)
    _ = code
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchLedger() is not supported yet")))
}
func  (this *Exchange) fetchLedgerEntry(id interface{}, optionalArgs ...interface{}) interface{}  {
    code := GetArg(optionalArgs, 1, nil)
    _ = code
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchLedgerEntry() is not supported yet")))
}
func  (this *Exchange) parseBidAsk(bidask interface{}, optionalArgs ...interface{}) interface{}  {
    priceKey := GetArg(optionalArgs, 1, 0)
    _ = priceKey
    amountKey := GetArg(optionalArgs, 2, 1)
    _ = amountKey
    countOrIdKey := GetArg(optionalArgs, 3, 2)
    _ = countOrIdKey
    var price interface{} = this.safeNumber(bidask, priceKey)
    var amount interface{} = this.safeNumber(bidask, amountKey)
    var countOrId interface{} = this.safeInteger(bidask, countOrIdKey)
    var bidAsk interface{} = []interface{}{price, amount}
    if IsTrue(!IsEqual(countOrId, nil)) {
        AppendToArray(&bidAsk,countOrId)
    }
    return bidAsk
}
func  (this *Exchange) safeCurrency(currencyId interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 1, nil)
    _ = currency
    if IsTrue(IsTrue((IsEqual(currencyId, nil))) && IsTrue((!IsEqual(currency, nil)))) {
        return currency
    }
    if IsTrue(IsTrue(IsTrue((!IsEqual(this.currencies_by_id, nil))) && IsTrue((InOp(this.currencies_by_id, currencyId)))) && IsTrue((!IsEqual(GetValue(this.currencies_by_id, currencyId), nil)))) {
        return GetValue(this.currencies_by_id, currencyId)
    }
    var code interface{} = currencyId
    if IsTrue(!IsEqual(currencyId, nil)) {
        code = this.commonCurrencyCode(ToUpper(currencyId))
    }
    return this.safeCurrencyStructure(map[string]interface{} {
        "id": currencyId,
        "code": code,
        "precision": nil,
    })
}
func  (this *Exchange) safeMarket(marketId interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    delimiter := GetArg(optionalArgs, 2, nil)
    _ = delimiter
    marketType := GetArg(optionalArgs, 3, nil)
    _ = marketType
    var result interface{} = this.safeMarketStructure(map[string]interface{} {
        "symbol": marketId,
        "marketId": marketId,
    })
    if IsTrue(!IsEqual(marketId, nil)) {
        if IsTrue(IsTrue((!IsEqual(this.markets_by_id, nil))) && IsTrue((InOp(this.markets_by_id, marketId)))) {
            var markets interface{} = GetValue(this.markets_by_id, marketId)
            var numMarkets interface{} =             GetArrayLength(markets)
            if IsTrue(IsEqual(numMarkets, 1)) {
                return GetValue(markets, 0)
            } else {
                if IsTrue(IsEqual(marketType, nil)) {
                    if IsTrue(IsEqual(market, nil)) {
                        panic(ArgumentsRequired(Add(Add(Add(this.id, " safeMarket() requires a fourth argument for "), marketId), " to disambiguate between different markets with the same market id")))
                    } else {
                        marketType = GetValue(market, "type")
                    }
                }
                for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
                    var currentMarket interface{} = GetValue(markets, i)
                    if IsTrue(GetValue(currentMarket, marketType)) {
                        return currentMarket
                    }
                }
            }
        } else if IsTrue(IsTrue(!IsEqual(delimiter, nil)) && IsTrue(!IsEqual(delimiter, ""))) {
            var parts interface{} = Split(marketId, delimiter)
            var partsLength interface{} =             GetArrayLength(parts)
            if IsTrue(IsEqual(partsLength, 2)) {
                AddElementToObject(result, "baseId", this.safeString(parts, 0))
                AddElementToObject(result, "quoteId", this.safeString(parts, 1))
                AddElementToObject(result, "base", this.safeCurrencyCode(GetValue(result, "baseId")))
                AddElementToObject(result, "quote", this.safeCurrencyCode(GetValue(result, "quoteId")))
                AddElementToObject(result, "symbol", Add(Add(GetValue(result, "base"), "/"), GetValue(result, "quote")))
                return result
            } else {
                return result
            }
        }
    }
    if IsTrue(!IsEqual(market, nil)) {
        return market
    }
    return result
}
func  (this *Exchange) checkRequiredCredentials(optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @param {boolean} error throw an error that a credential is required if true
    * @returns {boolean} true if all required credentials have been set, otherwise false or an error is thrown is param error=true
    */
    error := GetArg(optionalArgs, 0, true)
    _ = error
    var keys interface{} = ObjectKeys(this.requiredCredentials)
    for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
        var key interface{} = GetValue(keys, i)
        if IsTrue(IsTrue(GetValue(this.requiredCredentials, key)) && !IsTrue(GetValue(this, key))) {
            if IsTrue(error) {
                panic(AuthenticationError(Add(Add(Add(this.id, " requires \""), key), "\" credential")))
            } else {
                return false
            }
        }
    }
    return true
}
func  (this *Exchange) oath() interface{}  {
    if IsTrue(!IsEqual(this.twofa, nil)) {
        return totp(this.twofa)
    } else {
        panic(ExchangeError(Add(this.id, " exchange.twofa has not been set for 2FA Two-Factor Authentication")))
    }
}
func  (this *Exchange) fetchBalance(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchBalance() is not supported yet")))
}
func  (this *Exchange) fetchBalanceWs(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchBalanceWs() is not supported yet")))
}
func  (this *Exchange) parseBalance(response interface{}) interface{}  {
    panic(NotSupported(Add(this.id, " parseBalance() is not supported yet")))
}
func  (this *Exchange) watchBalance(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchBalance() is not supported yet")))
}
func  (this *Exchange) fetchPartialBalance(part interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var balance interface{} = this.fetchBalance(params)
    return GetValue(balance, part)
}
func  (this *Exchange) fetchFreeBalance(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    return this.fetchPartialBalance("free", params)
}
func  (this *Exchange) fetchUsedBalance(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    return this.fetchPartialBalance("used", params)
}
func  (this *Exchange) fetchTotalBalance(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    return this.fetchPartialBalance("total", params)
}
func  (this *Exchange) fetchStatus(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchStatus() is not supported yet")))
}
func  (this *Exchange) fetchTransactionFee(code interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    if !IsTrue(GetValue(this.has, "fetchTransactionFees")) {
        panic(NotSupported(Add(this.id, " fetchTransactionFee() is not supported yet")))
    }
    return this.fetchTransactionFees([]interface{}{code}, params)
}
func  (this *Exchange) fetchTransactionFees(optionalArgs ...interface{}) interface{}  {
    codes := GetArg(optionalArgs, 0, nil)
    _ = codes
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchTransactionFees() is not supported yet")))
}
func  (this *Exchange) fetchDepositWithdrawFees(optionalArgs ...interface{}) interface{}  {
    codes := GetArg(optionalArgs, 0, nil)
    _ = codes
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchDepositWithdrawFees() is not supported yet")))
}
func  (this *Exchange) fetchDepositWithdrawFee(code interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    if !IsTrue(GetValue(this.has, "fetchDepositWithdrawFees")) {
        panic(NotSupported(Add(this.id, " fetchDepositWithdrawFee() is not supported yet")))
    }
    var fees interface{} = this.fetchDepositWithdrawFees([]interface{}{code}, params)
    return this.safeValue(fees, code)
}
func  (this *Exchange) getSupportedMapping(key interface{}, optionalArgs ...interface{}) interface{}  {
    mapping := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = mapping
    if IsTrue(InOp(mapping, key)) {
        return GetValue(mapping, key)
    } else {
        panic(NotSupported(Add(Add(Add(this.id, " "), key), " does not have a value in mapping")))
    }
}
func  (this *Exchange) fetchCrossBorrowRate(code interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    this.loadMarkets()
    if !IsTrue(GetValue(this.has, "fetchBorrowRates")) {
        panic(NotSupported(Add(this.id, " fetchCrossBorrowRate() is not supported yet")))
    }
    var borrowRates interface{} = this.fetchCrossBorrowRates(params)
    var rate interface{} = this.safeValue(borrowRates, code)
    if IsTrue(IsEqual(rate, nil)) {
        panic(ExchangeError(Add(Add(this.id, " fetchCrossBorrowRate() could not find the borrow rate for currency code "), code)))
    }
    return rate
}
func  (this *Exchange) fetchIsolatedBorrowRate(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    this.loadMarkets()
    if !IsTrue(GetValue(this.has, "fetchBorrowRates")) {
        panic(NotSupported(Add(this.id, " fetchIsolatedBorrowRate() is not supported yet")))
    }
    var borrowRates interface{} = this.fetchIsolatedBorrowRates(params)
    var rate interface{} = this.safeDict(borrowRates, symbol)
    if IsTrue(IsEqual(rate, nil)) {
        panic(ExchangeError(Add(Add(this.id, " fetchIsolatedBorrowRate() could not find the borrow rate for market symbol "), symbol)))
    }
    return rate
}
func  (this *Exchange) handleOptionAndParams(params interface{}, methodName interface{}, optionName interface{}, optionalArgs ...interface{}) interface{}  {
    // This method can be used to obtain method specific properties, i.e: this.handleOptionAndParams (params, 'fetchPosition', 'marginMode', 'isolated')
    defaultValue := GetArg(optionalArgs, 3, nil)
    _ = defaultValue
    var defaultOptionName interface{} = Add("default", this.capitalize(optionName)) // we also need to check the 'defaultXyzWhatever'
    // check if params contain the key
    var value interface{} = this.safeValue2(params, optionName, defaultOptionName)
    if IsTrue(!IsEqual(value, nil)) {
        params = this.omit(params, []interface{}{optionName, defaultOptionName})
    } else {
        // handle routed methods like "watchTrades > watchTradesForSymbols" (or "watchTicker > watchTickers")
        methodNameparamsVariable := this.handleParamString(params, "callerMethodName", methodName);
        methodName = GetValue(methodNameparamsVariable,0);
        params = GetValue(methodNameparamsVariable,1)
        // check if exchange has properties for this method
        var exchangeWideMethodOptions interface{} = this.safeValue(this.options, methodName)
        if IsTrue(!IsEqual(exchangeWideMethodOptions, nil)) {
            // check if the option is defined inside this method's props
            value = this.safeValue2(exchangeWideMethodOptions, optionName, defaultOptionName)
        }
        if IsTrue(IsEqual(value, nil)) {
            // if it's still undefined, check if global exchange-wide option exists
            value = this.safeValue2(this.options, optionName, defaultOptionName)
        }
        // if it's still undefined, use the default value
        value = Ternary(IsTrue((!IsEqual(value, nil))), value, defaultValue)
    }
    return []interface{}{value, params}
}
func  (this *Exchange) handleOptionAndParams2(params interface{}, methodName1 interface{}, optionName1 interface{}, optionName2 interface{}, optionalArgs ...interface{}) interface{}  {
    defaultValue := GetArg(optionalArgs, 4, nil)
    _ = defaultValue
    var value interface{} = nil
    valueparamsVariable := this.handleOptionAndParams(params, methodName1, optionName1, defaultValue);
    value = GetValue(valueparamsVariable,0);
    params = GetValue(valueparamsVariable,1)
    // if still undefined, try optionName2
    var value2 interface{} = nil
    value2paramsVariable := this.handleOptionAndParams(params, methodName1, optionName2, value);
    value2 = GetValue(value2paramsVariable,0);
    params = GetValue(value2paramsVariable,1)
    return []interface{}{value2, params}
}
func  (this *Exchange) handleOption(methodName interface{}, optionName interface{}, optionalArgs ...interface{}) interface{}  {
    defaultValue := GetArg(optionalArgs, 2, nil)
    _ = defaultValue
    var res interface{} = this.handleOptionAndParams(map[string]interface{} {}, methodName, optionName, defaultValue)
    return this.safeValue(res, 0)
}
func  (this *Exchange) handleMarketTypeAndParams(methodName interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @name exchange#handleMarketTypeAndParams
    * @param methodName the method calling handleMarketTypeAndParams
    * @param {Market} market
    * @param {object} params
    * @param {string} [params.type] type assigned by user
    * @param {string} [params.defaultType] same as params.type
    * @param {string} [defaultValue] assigned programatically in the method calling handleMarketTypeAndParams
    * @returns {[string, object]} the market type and params with type and defaultType omitted
    */
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    defaultValue := GetArg(optionalArgs, 3, nil)
    _ = defaultValue
    var defaultType interface{} = this.safeString2(this.options, "defaultType", "type", "spot")
    if IsTrue(IsEqual(defaultValue, nil)) {
        defaultValue = defaultType
    }
    var methodOptions interface{} = this.safeDict(this.options, methodName)
    var methodType interface{} = defaultValue
    if IsTrue(!IsEqual(methodOptions, nil)) {
        if IsTrue(IsString(methodOptions)) {
            methodType = methodOptions
        } else {
            methodType = this.safeString2(methodOptions, "defaultType", "type", methodType)
        }
    }
    var marketType interface{} = Ternary(IsTrue((IsEqual(market, nil))), methodType, GetValue(market, "type"))
    var typeVar interface{} = this.safeString2(params, "defaultType", "type", marketType)
    params = this.omit(params, []interface{}{"defaultType", "type"})
    return []interface{}{typeVar, params}
}
func  (this *Exchange) handleSubTypeAndParams(methodName interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    defaultValue := GetArg(optionalArgs, 3, nil)
    _ = defaultValue
    var subType interface{} = nil
    // if set in params, it takes precedence
    var subTypeInParams interface{} = this.safeString2(params, "subType", "defaultSubType")
    // avoid omitting if it's not present
    if IsTrue(!IsEqual(subTypeInParams, nil)) {
        subType = subTypeInParams
        params = this.omit(params, []interface{}{"subType", "defaultSubType"})
    } else {
        // at first, check from market object
        if IsTrue(!IsEqual(market, nil)) {
            if IsTrue(GetValue(market, "linear")) {
                subType = "linear"
            } else if IsTrue(GetValue(market, "inverse")) {
                subType = "inverse"
            }
        }
        // if it was not defined in market object
        if IsTrue(IsEqual(subType, nil)) {
            var values interface{} = this.handleOptionAndParams(map[string]interface{} {}, methodName, "subType", defaultValue) // no need to re-test params here
            subType = GetValue(values, 0)
        }
    }
    return []interface{}{subType, params}
}
func  (this *Exchange) handleMarginModeAndParams(methodName interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {Array} the marginMode in lowercase as specified by params["marginMode"], params["defaultMarginMode"] this.options["marginMode"] or this.options["defaultMarginMode"]
    */
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    defaultValue := GetArg(optionalArgs, 2, nil)
    _ = defaultValue
    return this.handleOptionAndParams(params, methodName, "marginMode", defaultValue)
}
func  (this *Exchange) throwExactlyMatchedException(exact interface{}, string interface{}, message interface{})  {
    if IsTrue(IsEqual(string, nil)) {
        return
    }
    if IsTrue(InOp(exact, string)) {
        throwDynamicException(GetValue(exact, string), message);
    }
}
func  (this *Exchange) throwBroadlyMatchedException(broad interface{}, string interface{}, message interface{})  {
    var broadKey interface{} = this.findBroadlyMatchedKey(broad, string)
    if IsTrue(!IsEqual(broadKey, nil)) {
        throwDynamicException(GetValue(broad, broadKey), message);
    }
}
func  (this *Exchange) findBroadlyMatchedKey(broad interface{}, string interface{}) interface{}  {
    // a helper for matching error strings exactly vs broadly
    var keys interface{} = ObjectKeys(broad)
    for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
        var key interface{} = GetValue(keys, i)
        if IsTrue(!IsEqual(string, nil)) {
            if IsTrue(IsGreaterThanOrEqual(GetIndexOf(string, key), 0)) {
                return key
            }
        }
    }
    return nil
}
func  (this *Exchange) handleErrors(statusCode interface{}, statusText interface{}, url interface{}, method interface{}, responseHeaders interface{}, responseBody interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    // it is a stub method that must be overrided in the derived exchange classes
    // throw new NotSupported (this.id + ' handleErrors() not implemented yet');
    return nil
}
func  (this *Exchange) calculateRateLimiterCost(api interface{}, method interface{}, path interface{}, params interface{}, optionalArgs ...interface{}) interface{}  {
    config := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = config
    return this.safeValue(config, "cost", 1)
}
func  (this *Exchange) fetchTicker(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchTickers")) {
        this.loadMarkets()
        var market interface{} = this.market(symbol)
        symbol = GetValue(market, "symbol")
        var tickers interface{} = this.fetchTickers([]interface{}{symbol}, params)
        var ticker interface{} = this.safeDict(tickers, symbol)
        if IsTrue(IsEqual(ticker, nil)) {
            panic(NullResponse(Add(Add(this.id, " fetchTickers() could not find a ticker for "), symbol)))
        } else {
            return ticker
        }
    } else {
        panic(NotSupported(Add(this.id, " fetchTicker() is not supported yet")))
    }
}
func  (this *Exchange) fetchTickerWs(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchTickersWs")) {
        this.loadMarkets()
        var market interface{} = this.market(symbol)
        symbol = GetValue(market, "symbol")
        var tickers interface{} = this.fetchTickerWs(symbol, params)
        var ticker interface{} = this.safeDict(tickers, symbol)
        if IsTrue(IsEqual(ticker, nil)) {
            panic(NullResponse(Add(Add(this.id, " fetchTickers() could not find a ticker for "), symbol)))
        } else {
            return ticker
        }
    } else {
        panic(NotSupported(Add(this.id, " fetchTicker() is not supported yet")))
    }
}
func  (this *Exchange) watchTicker(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchTicker() is not supported yet")))
}
func  (this *Exchange) fetchTickers(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchTickers() is not supported yet")))
}
func  (this *Exchange) fetchTickersWs(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchTickers() is not supported yet")))
}
func  (this *Exchange) fetchOrderBooks(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    limit := GetArg(optionalArgs, 1, nil)
    _ = limit
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchOrderBooks() is not supported yet")))
}
func  (this *Exchange) watchBidsAsks(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchBidsAsks() is not supported yet")))
}
func  (this *Exchange) watchTickers(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchTickers() is not supported yet")))
}
func  (this *Exchange) fetchOrder(id interface{}, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchOrder() is not supported yet")))
}
func  (this *Exchange) fetchOrderWs(id interface{}, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchOrderWs() is not supported yet")))
}
func  (this *Exchange) fetchOrderStatus(id interface{}, optionalArgs ...interface{}) interface{}  {
    // TODO: TypeScript: change method signature by replacing
    // Promise<string> with Promise<Order['status']>.
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    var order interface{} = this.fetchOrder(id, symbol, params)
    return GetValue(order, "status")
}
func  (this *Exchange) fetchUnifiedOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    return this.fetchOrder(this.safeString(order, "id"), this.safeString(order, "symbol"), params)
}
func  (this *Exchange) createOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    params := GetArg(optionalArgs, 5, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " createOrder() is not supported yet")))
}
func  (this *Exchange) createTrailingAmountOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createTrailingAmountOrder
    * @description create a trailing order by providing the symbol, type, side, amount, price and trailingAmount
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency, or number of contracts
    * @param {float} [price] the price for the order to be filled at, in units of the quote currency, ignored in market orders
    * @param {float} trailingAmount the quote amount to trail away from the current market price
    * @param {float} [trailingTriggerPrice] the price to activate a trailing order, default uses the price argument
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    trailingAmount := GetArg(optionalArgs, 5, nil)
    _ = trailingAmount
    trailingTriggerPrice := GetArg(optionalArgs, 6, nil)
    _ = trailingTriggerPrice
    params := GetArg(optionalArgs, 7, map[string]interface{} {})
    _ = params
    if IsTrue(IsEqual(trailingAmount, nil)) {
        panic(ArgumentsRequired(Add(this.id, " createTrailingAmountOrder() requires a trailingAmount argument")))
    }
    AddElementToObject(params, "trailingAmount", trailingAmount)
    if IsTrue(!IsEqual(trailingTriggerPrice, nil)) {
        AddElementToObject(params, "trailingTriggerPrice", trailingTriggerPrice)
    }
    if IsTrue(GetValue(this.has, "createTrailingAmountOrder")) {
        return this.createOrder(symbol, typeVar, side, amount, price, params)
    }
    panic(NotSupported(Add(this.id, " createTrailingAmountOrder() is not supported yet")))
}
func  (this *Exchange) createTrailingAmountOrderWs(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createTrailingAmountOrderWs
    * @description create a trailing order by providing the symbol, type, side, amount, price and trailingAmount
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency, or number of contracts
    * @param {float} [price] the price for the order to be filled at, in units of the quote currency, ignored in market orders
    * @param {float} trailingAmount the quote amount to trail away from the current market price
    * @param {float} [trailingTriggerPrice] the price to activate a trailing order, default uses the price argument
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    trailingAmount := GetArg(optionalArgs, 5, nil)
    _ = trailingAmount
    trailingTriggerPrice := GetArg(optionalArgs, 6, nil)
    _ = trailingTriggerPrice
    params := GetArg(optionalArgs, 7, map[string]interface{} {})
    _ = params
    if IsTrue(IsEqual(trailingAmount, nil)) {
        panic(ArgumentsRequired(Add(this.id, " createTrailingAmountOrderWs() requires a trailingAmount argument")))
    }
    AddElementToObject(params, "trailingAmount", trailingAmount)
    if IsTrue(!IsEqual(trailingTriggerPrice, nil)) {
        AddElementToObject(params, "trailingTriggerPrice", trailingTriggerPrice)
    }
    if IsTrue(GetValue(this.has, "createTrailingAmountOrderWs")) {
        return this.createOrderWs(symbol, typeVar, side, amount, price, params)
    }
    panic(NotSupported(Add(this.id, " createTrailingAmountOrderWs() is not supported yet")))
}
func  (this *Exchange) createTrailingPercentOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createTrailingPercentOrder
    * @description create a trailing order by providing the symbol, type, side, amount, price and trailingPercent
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency, or number of contracts
    * @param {float} [price] the price for the order to be filled at, in units of the quote currency, ignored in market orders
    * @param {float} trailingPercent the percent to trail away from the current market price
    * @param {float} [trailingTriggerPrice] the price to activate a trailing order, default uses the price argument
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    trailingPercent := GetArg(optionalArgs, 5, nil)
    _ = trailingPercent
    trailingTriggerPrice := GetArg(optionalArgs, 6, nil)
    _ = trailingTriggerPrice
    params := GetArg(optionalArgs, 7, map[string]interface{} {})
    _ = params
    if IsTrue(IsEqual(trailingPercent, nil)) {
        panic(ArgumentsRequired(Add(this.id, " createTrailingPercentOrder() requires a trailingPercent argument")))
    }
    AddElementToObject(params, "trailingPercent", trailingPercent)
    if IsTrue(!IsEqual(trailingTriggerPrice, nil)) {
        AddElementToObject(params, "trailingTriggerPrice", trailingTriggerPrice)
    }
    if IsTrue(GetValue(this.has, "createTrailingPercentOrder")) {
        return this.createOrder(symbol, typeVar, side, amount, price, params)
    }
    panic(NotSupported(Add(this.id, " createTrailingPercentOrder() is not supported yet")))
}
func  (this *Exchange) createTrailingPercentOrderWs(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createTrailingPercentOrderWs
    * @description create a trailing order by providing the symbol, type, side, amount, price and trailingPercent
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency, or number of contracts
    * @param {float} [price] the price for the order to be filled at, in units of the quote currency, ignored in market orders
    * @param {float} trailingPercent the percent to trail away from the current market price
    * @param {float} [trailingTriggerPrice] the price to activate a trailing order, default uses the price argument
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    trailingPercent := GetArg(optionalArgs, 5, nil)
    _ = trailingPercent
    trailingTriggerPrice := GetArg(optionalArgs, 6, nil)
    _ = trailingTriggerPrice
    params := GetArg(optionalArgs, 7, map[string]interface{} {})
    _ = params
    if IsTrue(IsEqual(trailingPercent, nil)) {
        panic(ArgumentsRequired(Add(this.id, " createTrailingPercentOrderWs() requires a trailingPercent argument")))
    }
    AddElementToObject(params, "trailingPercent", trailingPercent)
    if IsTrue(!IsEqual(trailingTriggerPrice, nil)) {
        AddElementToObject(params, "trailingTriggerPrice", trailingTriggerPrice)
    }
    if IsTrue(GetValue(this.has, "createTrailingPercentOrderWs")) {
        return this.createOrderWs(symbol, typeVar, side, amount, price, params)
    }
    panic(NotSupported(Add(this.id, " createTrailingPercentOrderWs() is not supported yet")))
}
func  (this *Exchange) createMarketOrderWithCost(symbol interface{}, side interface{}, cost interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createMarketOrderWithCost
    * @description create a market order by providing the symbol, side and cost
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} side 'buy' or 'sell'
    * @param {float} cost how much you want to trade in units of the quote currency
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    if IsTrue(IsTrue(GetValue(this.has, "createMarketOrderWithCost")) || IsTrue((IsTrue(GetValue(this.has, "createMarketBuyOrderWithCost")) && IsTrue(GetValue(this.has, "createMarketSellOrderWithCost"))))) {
        return this.createOrder(symbol, "market", side, cost, 1, params)
    }
    panic(NotSupported(Add(this.id, " createMarketOrderWithCost() is not supported yet")))
}
func  (this *Exchange) createMarketBuyOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createMarketBuyOrderWithCost
    * @description create a market buy order by providing the symbol and cost
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {float} cost how much you want to trade in units of the quote currency
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    if IsTrue(IsTrue(GetValue(this.options, "createMarketBuyOrderRequiresPrice")) || IsTrue(GetValue(this.has, "createMarketBuyOrderWithCost"))) {
        return this.createOrder(symbol, "market", "buy", cost, 1, params)
    }
    panic(NotSupported(Add(this.id, " createMarketBuyOrderWithCost() is not supported yet")))
}
func  (this *Exchange) createMarketSellOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createMarketSellOrderWithCost
    * @description create a market sell order by providing the symbol and cost
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {float} cost how much you want to trade in units of the quote currency
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    if IsTrue(IsTrue(GetValue(this.options, "createMarketSellOrderRequiresPrice")) || IsTrue(GetValue(this.has, "createMarketSellOrderWithCost"))) {
        return this.createOrder(symbol, "market", "sell", cost, 1, params)
    }
    panic(NotSupported(Add(this.id, " createMarketSellOrderWithCost() is not supported yet")))
}
func  (this *Exchange) createMarketOrderWithCostWs(symbol interface{}, side interface{}, cost interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createMarketOrderWithCostWs
    * @description create a market order by providing the symbol, side and cost
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} side 'buy' or 'sell'
    * @param {float} cost how much you want to trade in units of the quote currency
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    if IsTrue(IsTrue(GetValue(this.has, "createMarketOrderWithCostWs")) || IsTrue((IsTrue(GetValue(this.has, "createMarketBuyOrderWithCostWs")) && IsTrue(GetValue(this.has, "createMarketSellOrderWithCostWs"))))) {
        return this.createOrderWs(symbol, "market", side, cost, 1, params)
    }
    panic(NotSupported(Add(this.id, " createMarketOrderWithCostWs() is not supported yet")))
}
func  (this *Exchange) createTriggerOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createTriggerOrder
    * @description create a trigger stop order (type 1)
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency or the number of contracts
    * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
    * @param {float} triggerPrice the price to trigger the stop order, in units of the quote currency
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    triggerPrice := GetArg(optionalArgs, 5, nil)
    _ = triggerPrice
    params := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = params
    if IsTrue(IsEqual(triggerPrice, nil)) {
        panic(ArgumentsRequired(Add(this.id, " createTriggerOrder() requires a triggerPrice argument")))
    }
    AddElementToObject(params, "triggerPrice", triggerPrice)
    if IsTrue(GetValue(this.has, "createTriggerOrder")) {
        return this.createOrder(symbol, typeVar, side, amount, price, params)
    }
    panic(NotSupported(Add(this.id, " createTriggerOrder() is not supported yet")))
}
func  (this *Exchange) createTriggerOrderWs(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createTriggerOrderWs
    * @description create a trigger stop order (type 1)
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency or the number of contracts
    * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
    * @param {float} triggerPrice the price to trigger the stop order, in units of the quote currency
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    triggerPrice := GetArg(optionalArgs, 5, nil)
    _ = triggerPrice
    params := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = params
    if IsTrue(IsEqual(triggerPrice, nil)) {
        panic(ArgumentsRequired(Add(this.id, " createTriggerOrderWs() requires a triggerPrice argument")))
    }
    AddElementToObject(params, "triggerPrice", triggerPrice)
    if IsTrue(GetValue(this.has, "createTriggerOrderWs")) {
        return this.createOrderWs(symbol, typeVar, side, amount, price, params)
    }
    panic(NotSupported(Add(this.id, " createTriggerOrderWs() is not supported yet")))
}
func  (this *Exchange) createStopLossOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createStopLossOrder
    * @description create a trigger stop loss order (type 2)
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency or the number of contracts
    * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
    * @param {float} stopLossPrice the price to trigger the stop loss order, in units of the quote currency
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    stopLossPrice := GetArg(optionalArgs, 5, nil)
    _ = stopLossPrice
    params := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = params
    if IsTrue(IsEqual(stopLossPrice, nil)) {
        panic(ArgumentsRequired(Add(this.id, " createStopLossOrder() requires a stopLossPrice argument")))
    }
    AddElementToObject(params, "stopLossPrice", stopLossPrice)
    if IsTrue(GetValue(this.has, "createStopLossOrder")) {
        return this.createOrder(symbol, typeVar, side, amount, price, params)
    }
    panic(NotSupported(Add(this.id, " createStopLossOrder() is not supported yet")))
}
func  (this *Exchange) createStopLossOrderWs(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createStopLossOrderWs
    * @description create a trigger stop loss order (type 2)
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency or the number of contracts
    * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
    * @param {float} stopLossPrice the price to trigger the stop loss order, in units of the quote currency
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    stopLossPrice := GetArg(optionalArgs, 5, nil)
    _ = stopLossPrice
    params := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = params
    if IsTrue(IsEqual(stopLossPrice, nil)) {
        panic(ArgumentsRequired(Add(this.id, " createStopLossOrderWs() requires a stopLossPrice argument")))
    }
    AddElementToObject(params, "stopLossPrice", stopLossPrice)
    if IsTrue(GetValue(this.has, "createStopLossOrderWs")) {
        return this.createOrderWs(symbol, typeVar, side, amount, price, params)
    }
    panic(NotSupported(Add(this.id, " createStopLossOrderWs() is not supported yet")))
}
func  (this *Exchange) createTakeProfitOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createTakeProfitOrder
    * @description create a trigger take profit order (type 2)
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency or the number of contracts
    * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
    * @param {float} takeProfitPrice the price to trigger the take profit order, in units of the quote currency
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    takeProfitPrice := GetArg(optionalArgs, 5, nil)
    _ = takeProfitPrice
    params := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = params
    if IsTrue(IsEqual(takeProfitPrice, nil)) {
        panic(ArgumentsRequired(Add(this.id, " createTakeProfitOrder() requires a takeProfitPrice argument")))
    }
    AddElementToObject(params, "takeProfitPrice", takeProfitPrice)
    if IsTrue(GetValue(this.has, "createTakeProfitOrder")) {
        return this.createOrder(symbol, typeVar, side, amount, price, params)
    }
    panic(NotSupported(Add(this.id, " createTakeProfitOrder() is not supported yet")))
}
func  (this *Exchange) createTakeProfitOrderWs(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createTakeProfitOrderWs
    * @description create a trigger take profit order (type 2)
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency or the number of contracts
    * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
    * @param {float} takeProfitPrice the price to trigger the take profit order, in units of the quote currency
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    takeProfitPrice := GetArg(optionalArgs, 5, nil)
    _ = takeProfitPrice
    params := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = params
    if IsTrue(IsEqual(takeProfitPrice, nil)) {
        panic(ArgumentsRequired(Add(this.id, " createTakeProfitOrderWs() requires a takeProfitPrice argument")))
    }
    AddElementToObject(params, "takeProfitPrice", takeProfitPrice)
    if IsTrue(GetValue(this.has, "createTakeProfitOrderWs")) {
        return this.createOrderWs(symbol, typeVar, side, amount, price, params)
    }
    panic(NotSupported(Add(this.id, " createTakeProfitOrderWs() is not supported yet")))
}
func  (this *Exchange) createOrderWithTakeProfitAndStopLoss(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createOrderWithTakeProfitAndStopLoss
    * @description create an order with a stop loss or take profit attached (type 3)
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency or the number of contracts
    * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
    * @param {float} [takeProfit] the take profit price, in units of the quote currency
    * @param {float} [stopLoss] the stop loss price, in units of the quote currency
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @param {string} [params.takeProfitType] *not available on all exchanges* 'limit' or 'market'
    * @param {string} [params.stopLossType] *not available on all exchanges* 'limit' or 'market'
    * @param {string} [params.takeProfitPriceType] *not available on all exchanges* 'last', 'mark' or 'index'
    * @param {string} [params.stopLossPriceType] *not available on all exchanges* 'last', 'mark' or 'index'
    * @param {float} [params.takeProfitLimitPrice] *not available on all exchanges* limit price for a limit take profit order
    * @param {float} [params.stopLossLimitPrice] *not available on all exchanges* stop loss for a limit stop loss order
    * @param {float} [params.takeProfitAmount] *not available on all exchanges* the amount for a take profit
    * @param {float} [params.stopLossAmount] *not available on all exchanges* the amount for a stop loss
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    takeProfit := GetArg(optionalArgs, 5, nil)
    _ = takeProfit
    stopLoss := GetArg(optionalArgs, 6, nil)
    _ = stopLoss
    params := GetArg(optionalArgs, 7, map[string]interface{} {})
    _ = params
    params = this.setTakeProfitAndStopLossParams(symbol, typeVar, side, amount, price, takeProfit, stopLoss, params)
    if IsTrue(GetValue(this.has, "createOrderWithTakeProfitAndStopLoss")) {
        return this.createOrder(symbol, typeVar, side, amount, price, params)
    }
    panic(NotSupported(Add(this.id, " createOrderWithTakeProfitAndStopLoss() is not supported yet")))
}
func  (this *Exchange) setTakeProfitAndStopLossParams(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    takeProfit := GetArg(optionalArgs, 5, nil)
    _ = takeProfit
    stopLoss := GetArg(optionalArgs, 6, nil)
    _ = stopLoss
    params := GetArg(optionalArgs, 7, map[string]interface{} {})
    _ = params
    if IsTrue(IsTrue((IsEqual(takeProfit, nil))) && IsTrue((IsEqual(stopLoss, nil)))) {
        panic(ArgumentsRequired(Add(this.id, " createOrderWithTakeProfitAndStopLoss() requires either a takeProfit or stopLoss argument")))
    }
    if IsTrue(!IsEqual(takeProfit, nil)) {
        AddElementToObject(params, "takeProfit", map[string]interface{} {
    "triggerPrice": takeProfit,
})
    }
    if IsTrue(!IsEqual(stopLoss, nil)) {
        AddElementToObject(params, "stopLoss", map[string]interface{} {
    "triggerPrice": stopLoss,
})
    }
    var takeProfitType interface{} = this.safeString(params, "takeProfitType")
    var takeProfitPriceType interface{} = this.safeString(params, "takeProfitPriceType")
    var takeProfitLimitPrice interface{} = this.safeString(params, "takeProfitLimitPrice")
    var takeProfitAmount interface{} = this.safeString(params, "takeProfitAmount")
    var stopLossType interface{} = this.safeString(params, "stopLossType")
    var stopLossPriceType interface{} = this.safeString(params, "stopLossPriceType")
    var stopLossLimitPrice interface{} = this.safeString(params, "stopLossLimitPrice")
    var stopLossAmount interface{} = this.safeString(params, "stopLossAmount")
    if IsTrue(!IsEqual(takeProfitType, nil)) {
        AddElementToObject(GetValue(params, "takeProfit"), "type", takeProfitType)
    }
    if IsTrue(!IsEqual(takeProfitPriceType, nil)) {
        AddElementToObject(GetValue(params, "takeProfit"), "priceType", takeProfitPriceType)
    }
    if IsTrue(!IsEqual(takeProfitLimitPrice, nil)) {
        AddElementToObject(GetValue(params, "takeProfit"), "price", this.parseToNumeric(takeProfitLimitPrice))
    }
    if IsTrue(!IsEqual(takeProfitAmount, nil)) {
        AddElementToObject(GetValue(params, "takeProfit"), "amount", this.parseToNumeric(takeProfitAmount))
    }
    if IsTrue(!IsEqual(stopLossType, nil)) {
        AddElementToObject(GetValue(params, "stopLoss"), "type", stopLossType)
    }
    if IsTrue(!IsEqual(stopLossPriceType, nil)) {
        AddElementToObject(GetValue(params, "stopLoss"), "priceType", stopLossPriceType)
    }
    if IsTrue(!IsEqual(stopLossLimitPrice, nil)) {
        AddElementToObject(GetValue(params, "stopLoss"), "price", this.parseToNumeric(stopLossLimitPrice))
    }
    if IsTrue(!IsEqual(stopLossAmount, nil)) {
        AddElementToObject(GetValue(params, "stopLoss"), "amount", this.parseToNumeric(stopLossAmount))
    }
    params = this.omit(params, []interface{}{"takeProfitType", "takeProfitPriceType", "takeProfitLimitPrice", "takeProfitAmount", "stopLossType", "stopLossPriceType", "stopLossLimitPrice", "stopLossAmount"})
    return params
}
func  (this *Exchange) createOrderWithTakeProfitAndStopLossWs(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createOrderWithTakeProfitAndStopLossWs
    * @description create an order with a stop loss or take profit attached (type 3)
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency or the number of contracts
    * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
    * @param {float} [takeProfit] the take profit price, in units of the quote currency
    * @param {float} [stopLoss] the stop loss price, in units of the quote currency
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @param {string} [params.takeProfitType] *not available on all exchanges* 'limit' or 'market'
    * @param {string} [params.stopLossType] *not available on all exchanges* 'limit' or 'market'
    * @param {string} [params.takeProfitPriceType] *not available on all exchanges* 'last', 'mark' or 'index'
    * @param {string} [params.stopLossPriceType] *not available on all exchanges* 'last', 'mark' or 'index'
    * @param {float} [params.takeProfitLimitPrice] *not available on all exchanges* limit price for a limit take profit order
    * @param {float} [params.stopLossLimitPrice] *not available on all exchanges* stop loss for a limit stop loss order
    * @param {float} [params.takeProfitAmount] *not available on all exchanges* the amount for a take profit
    * @param {float} [params.stopLossAmount] *not available on all exchanges* the amount for a stop loss
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    takeProfit := GetArg(optionalArgs, 5, nil)
    _ = takeProfit
    stopLoss := GetArg(optionalArgs, 6, nil)
    _ = stopLoss
    params := GetArg(optionalArgs, 7, map[string]interface{} {})
    _ = params
    params = this.setTakeProfitAndStopLossParams(symbol, typeVar, side, amount, price, takeProfit, stopLoss, params)
    if IsTrue(GetValue(this.has, "createOrderWithTakeProfitAndStopLossWs")) {
        return this.createOrderWs(symbol, typeVar, side, amount, price, params)
    }
    panic(NotSupported(Add(this.id, " createOrderWithTakeProfitAndStopLossWs() is not supported yet")))
}
func  (this *Exchange) createOrders(orders interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " createOrders() is not supported yet")))
}
func  (this *Exchange) createOrderWs(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    params := GetArg(optionalArgs, 5, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " createOrderWs() is not supported yet")))
}
func  (this *Exchange) cancelOrder(id interface{}, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " cancelOrder() is not supported yet")))
}
func  (this *Exchange) cancelOrderWs(id interface{}, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " cancelOrderWs() is not supported yet")))
}
func  (this *Exchange) cancelOrdersWs(ids interface{}, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " cancelOrdersWs() is not supported yet")))
}
func  (this *Exchange) cancelAllOrders(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " cancelAllOrders() is not supported yet")))
}
func  (this *Exchange) cancelAllOrdersAfter(timeout interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " cancelAllOrdersAfter() is not supported yet")))
}
func  (this *Exchange) cancelOrdersForSymbols(orders interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " cancelOrdersForSymbols() is not supported yet")))
}
func  (this *Exchange) cancelAllOrdersWs(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " cancelAllOrdersWs() is not supported yet")))
}
func  (this *Exchange) cancelUnifiedOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    return this.cancelOrder(this.safeString(order, "id"), this.safeString(order, "symbol"), params)
}
func  (this *Exchange) fetchOrders(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    if IsTrue(IsTrue(GetValue(this.has, "fetchOpenOrders")) && IsTrue(GetValue(this.has, "fetchClosedOrders"))) {
        panic(NotSupported(Add(this.id, " fetchOrders() is not supported yet, consider using fetchOpenOrders() and fetchClosedOrders() instead")))
    }
    panic(NotSupported(Add(this.id, " fetchOrders() is not supported yet")))
}
func  (this *Exchange) fetchOrdersWs(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchOrdersWs() is not supported yet")))
}
func  (this *Exchange) fetchOrderTrades(id interface{}, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchOrderTrades() is not supported yet")))
}
func  (this *Exchange) watchOrders(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchOrders() is not supported yet")))
}
func  (this *Exchange) fetchOpenOrders(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchOrders")) {
        var orders interface{} = this.fetchOrders(symbol, since, limit, params)
        return this.filterBy(orders, "status", "open")
    }
    panic(NotSupported(Add(this.id, " fetchOpenOrders() is not supported yet")))
}
func  (this *Exchange) fetchOpenOrdersWs(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchOrdersWs")) {
        var orders interface{} = this.fetchOrdersWs(symbol, since, limit, params)
        return this.filterBy(orders, "status", "open")
    }
    panic(NotSupported(Add(this.id, " fetchOpenOrdersWs() is not supported yet")))
}
func  (this *Exchange) fetchClosedOrders(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchOrders")) {
        var orders interface{} = this.fetchOrders(symbol, since, limit, params)
        return this.filterBy(orders, "status", "closed")
    }
    panic(NotSupported(Add(this.id, " fetchClosedOrders() is not supported yet")))
}
func  (this *Exchange) fetchCanceledAndClosedOrders(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchCanceledAndClosedOrders() is not supported yet")))
}
func  (this *Exchange) fetchClosedOrdersWs(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchOrdersWs")) {
        var orders interface{} = this.fetchOrdersWs(symbol, since, limit, params)
        return this.filterBy(orders, "status", "closed")
    }
    panic(NotSupported(Add(this.id, " fetchClosedOrdersWs() is not supported yet")))
}
func  (this *Exchange) fetchMyTrades(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchMyTrades() is not supported yet")))
}
func  (this *Exchange) fetchMyLiquidations(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchMyLiquidations() is not supported yet")))
}
func  (this *Exchange) fetchLiquidations(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchLiquidations() is not supported yet")))
}
func  (this *Exchange) fetchMyTradesWs(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchMyTradesWs() is not supported yet")))
}
func  (this *Exchange) watchMyTrades(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchMyTrades() is not supported yet")))
}
func  (this *Exchange) fetchGreeks(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchGreeks() is not supported yet")))
}
func  (this *Exchange) fetchOptionChain(code interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchOptionChain() is not supported yet")))
}
func  (this *Exchange) fetchOption(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchOption() is not supported yet")))
}
func  (this *Exchange) fetchConvertQuote(fromCode interface{}, toCode interface{}, optionalArgs ...interface{}) interface{}  {
    amount := GetArg(optionalArgs, 2, nil)
    _ = amount
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchConvertQuote() is not supported yet")))
}
func  (this *Exchange) fetchDepositsWithdrawals(optionalArgs ...interface{}) interface{}  {
    code := GetArg(optionalArgs, 0, nil)
    _ = code
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchDepositsWithdrawals() is not supported yet")))
}
func  (this *Exchange) fetchDeposits(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchDeposits() is not supported yet")))
}
func  (this *Exchange) fetchWithdrawals(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchWithdrawals() is not supported yet")))
}
func  (this *Exchange) fetchDepositsWs(optionalArgs ...interface{}) interface{}  {
    code := GetArg(optionalArgs, 0, nil)
    _ = code
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchDepositsWs() is not supported yet")))
}
func  (this *Exchange) fetchWithdrawalsWs(optionalArgs ...interface{}) interface{}  {
    code := GetArg(optionalArgs, 0, nil)
    _ = code
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchWithdrawalsWs() is not supported yet")))
}
func  (this *Exchange) fetchFundingRateHistory(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchFundingRateHistory() is not supported yet")))
}
func  (this *Exchange) fetchFundingHistory(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchFundingHistory() is not supported yet")))
}
func  (this *Exchange) closePosition(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    side := GetArg(optionalArgs, 1, nil)
    _ = side
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " closePosition() is not supported yet")))
}
func  (this *Exchange) closeAllPositions(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " closeAllPositions() is not supported yet")))
}
func  (this *Exchange) fetchL3OrderBook(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    limit := GetArg(optionalArgs, 1, nil)
    _ = limit
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(BadRequest(Add(this.id, " fetchL3OrderBook() is not supported yet")))
}
func  (this *Exchange) parseLastPrice(price interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseLastPrice() is not supported yet")))
}
func  (this *Exchange) fetchDepositAddress(code interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchDepositAddresses")) {
        var depositAddresses interface{} = this.fetchDepositAddresses([]interface{}{code}, params)
        var depositAddress interface{} = this.safeValue(depositAddresses, code)
        if IsTrue(IsEqual(depositAddress, nil)) {
            panic(InvalidAddress(Add(Add(Add(this.id, " fetchDepositAddress() could not find a deposit address for "), code), ", make sure you have created a corresponding deposit address in your wallet on the exchange website")))
        } else {
            return depositAddress
        }
    } else if IsTrue(GetValue(this.has, "fetchDepositAddressesByNetwork")) {
        var network interface{} = this.safeString(params, "network")
        params = this.omit(params, "network")
        var addressStructures interface{} = this.fetchDepositAddressesByNetwork(code, params)
        if IsTrue(!IsEqual(network, nil)) {
            return this.safeDict(addressStructures, network)
        } else {
            var keys interface{} = ObjectKeys(addressStructures)
            var key interface{} = this.safeString(keys, 0)
            return this.safeDict(addressStructures, key)
        }
    } else {
        panic(NotSupported(Add(this.id, " fetchDepositAddress() is not supported yet")))
    }
}
func  (this *Exchange) account() interface{}  {
    return map[string]interface{} {
        "free": nil,
        "used": nil,
        "total": nil,
    }
}
func  (this *Exchange) commonCurrencyCode(code interface{}) interface{}  {
    if !IsTrue(this.substituteCommonCurrencyCodes) {
        return code
    }
    return this.safeString(this.commonCurrencies, code, code)
}
func  (this *Exchange) currency(code interface{}) interface{}  {
    if IsTrue(IsEqual(this.currencies, nil)) {
        panic(ExchangeError(Add(this.id, " currencies not loaded")))
    }
    if IsTrue(IsString(code)) {
        if IsTrue(InOp(this.currencies, code)) {
            return GetValue(this.currencies, code)
        } else if IsTrue(InOp(this.currencies_by_id, code)) {
            return GetValue(this.currencies_by_id, code)
        }
    }
    panic(ExchangeError(Add(Add(this.id, " does not have currency code "), code)))
}
func  (this *Exchange) market(symbol interface{}) interface{}  {
    if IsTrue(IsEqual(this.markets, nil)) {
        panic(ExchangeError(Add(this.id, " markets not loaded")))
    }
    if IsTrue(InOp(this.markets, symbol)) {
        return GetValue(this.markets, symbol)
    } else if IsTrue(InOp(this.markets_by_id, symbol)) {
        var markets interface{} = GetValue(this.markets_by_id, symbol)
        var defaultType interface{} = this.safeString2(this.options, "defaultType", "defaultSubType", "spot")
        for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
            var market interface{} = GetValue(markets, i)
            if IsTrue(GetValue(market, defaultType)) {
                return market
            }
        }
        return GetValue(markets, 0)
    } else if IsTrue(IsTrue(IsTrue(IsTrue((EndsWith(symbol, "-C"))) || IsTrue((EndsWith(symbol, "-P")))) || IsTrue((StartsWith(symbol, "C-")))) || IsTrue((StartsWith(symbol, "P-")))) {
        return this.createExpiredOptionMarket(symbol)
    }
    panic(BadSymbol(Add(Add(this.id, " does not have market symbol "), symbol)))
}
func  (this *Exchange) createExpiredOptionMarket(symbol interface{}) interface{}  {
    panic(NotSupported(Add(this.id, " createExpiredOptionMarket () is not supported yet")))
}
func  (this *Exchange) handleWithdrawTagAndParams(tag interface{}, params interface{}) interface{}  {
    if IsTrue(IsTrue((!IsEqual(tag, nil))) && IsTrue((IsObject(tag)))) {
        params = this.extend(tag, params)
        tag = nil
    }
    if IsTrue(IsEqual(tag, nil)) {
        tag = this.safeString(params, "tag")
        if IsTrue(!IsEqual(tag, nil)) {
            params = this.omit(params, "tag")
        }
    }
    return []interface{}{tag, params}
}
func  (this *Exchange) createLimitOrder(symbol interface{}, side interface{}, amount interface{}, price interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    return this.createOrder(symbol, "limit", side, amount, price, params)
}
func  (this *Exchange) createLimitOrderWs(symbol interface{}, side interface{}, amount interface{}, price interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    return this.createOrderWs(symbol, "limit", side, amount, price, params)
}
func  (this *Exchange) createMarketOrder(symbol interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 3, nil)
    _ = price
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    return this.createOrder(symbol, "market", side, amount, price, params)
}
func  (this *Exchange) createMarketOrderWs(symbol interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 3, nil)
    _ = price
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    return this.createOrderWs(symbol, "market", side, amount, price, params)
}
func  (this *Exchange) createLimitBuyOrder(symbol interface{}, amount interface{}, price interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    return this.createOrder(symbol, "limit", "buy", amount, price, params)
}
func  (this *Exchange) createLimitBuyOrderWs(symbol interface{}, amount interface{}, price interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    return this.createOrderWs(symbol, "limit", "buy", amount, price, params)
}
func  (this *Exchange) createLimitSellOrder(symbol interface{}, amount interface{}, price interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    return this.createOrder(symbol, "limit", "sell", amount, price, params)
}
func  (this *Exchange) createLimitSellOrderWs(symbol interface{}, amount interface{}, price interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    return this.createOrderWs(symbol, "limit", "sell", amount, price, params)
}
func  (this *Exchange) createMarketBuyOrder(symbol interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    return this.createOrder(symbol, "market", "buy", amount, nil, params)
}
func  (this *Exchange) createMarketBuyOrderWs(symbol interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    return this.createOrderWs(symbol, "market", "buy", amount, nil, params)
}
func  (this *Exchange) createMarketSellOrder(symbol interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    return this.createOrder(symbol, "market", "sell", amount, nil, params)
}
func  (this *Exchange) createMarketSellOrderWs(symbol interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    return this.createOrderWs(symbol, "market", "sell", amount, nil, params)
}
func  (this *Exchange) costToPrecision(symbol interface{}, cost interface{}) interface{}  {
    var market interface{} = this.market(symbol)
    return this.decimalToPrecision(cost, TRUNCATE, GetValue(GetValue(market, "precision"), "price"), this.precisionMode, this.paddingMode)
}
func  (this *Exchange) priceToPrecision(symbol interface{}, price interface{}) interface{}  {
    var market interface{} = this.market(symbol)
    var result interface{} = this.decimalToPrecision(price, ROUND, GetValue(GetValue(market, "precision"), "price"), this.precisionMode, this.paddingMode)
    if IsTrue(IsEqual(result, "0")) {
        panic(InvalidOrder(Add(Add(Add(Add(this.id, " price of "), GetValue(market, "symbol")), " must be greater than minimum price precision of "), this.numberToString(GetValue(GetValue(market, "precision"), "price")))))
    }
    return result
}
func  (this *Exchange) amountToPrecision(symbol interface{}, amount interface{}) interface{}  {
    var market interface{} = this.market(symbol)
    var result interface{} = this.decimalToPrecision(amount, TRUNCATE, GetValue(GetValue(market, "precision"), "amount"), this.precisionMode, this.paddingMode)
    if IsTrue(IsEqual(result, "0")) {
        panic(InvalidOrder(Add(Add(Add(Add(this.id, " amount of "), GetValue(market, "symbol")), " must be greater than minimum amount precision of "), this.numberToString(GetValue(GetValue(market, "precision"), "amount")))))
    }
    return result
}
func  (this *Exchange) feeToPrecision(symbol interface{}, fee interface{}) interface{}  {
    var market interface{} = this.market(symbol)
    return this.decimalToPrecision(fee, ROUND, GetValue(GetValue(market, "precision"), "price"), this.precisionMode, this.paddingMode)
}
func  (this *Exchange) currencyToPrecision(code interface{}, fee interface{}, optionalArgs ...interface{}) interface{}  {
    networkCode := GetArg(optionalArgs, 2, nil)
    _ = networkCode
    var currency interface{} = GetValue(this.currencies, code)
    var precision interface{} = this.safeValue(currency, "precision")
    if IsTrue(!IsEqual(networkCode, nil)) {
        var networks interface{} = this.safeDict(currency, "networks", map[string]interface{} {})
        var networkItem interface{} = this.safeDict(networks, networkCode, map[string]interface{} {})
        precision = this.safeValue(networkItem, "precision", precision)
    }
    if IsTrue(IsEqual(precision, nil)) {
        return this.forceString(fee)
    } else {
        return this.decimalToPrecision(fee, ROUND, precision, this.precisionMode, this.paddingMode)
    }
}
func  (this *Exchange) forceString(value interface{}) interface{}  {
    if IsTrue(!IsString(value)) {
        return this.numberToString(value)
    }
    return value
}
func  (this *Exchange) isTickPrecision() interface{}  {
    return IsEqual(this.precisionMode, TICK_SIZE)
}
func  (this *Exchange) isDecimalPrecision() interface{}  {
    return IsEqual(this.precisionMode, DECIMAL_PLACES)
}
func  (this *Exchange) isSignificantPrecision() interface{}  {
    return IsEqual(this.precisionMode, SIGNIFICANT_DIGITS)
}
func  (this *Exchange) safeNumber(obj interface{}, key interface{}, optionalArgs ...interface{}) interface{}  {
    defaultNumber := GetArg(optionalArgs, 2, nil)
    _ = defaultNumber
    var value interface{} = this.safeString(obj, key)
    return this.parseNumber(value, defaultNumber)
}
func  (this *Exchange) safeNumberN(obj interface{}, arr interface{}, optionalArgs ...interface{}) interface{}  {
    defaultNumber := GetArg(optionalArgs, 2, nil)
    _ = defaultNumber
    var value interface{} = this.safeStringN(obj, arr)
    return this.parseNumber(value, defaultNumber)
}
func  (this *Exchange) parsePrecision(precision interface{}) interface{}  {
    /**
     * @ignore
     * @method
     * @param {string} precision The number of digits to the right of the decimal
     * @returns {string} a string number equal to 1e-precision
     */
    if IsTrue(IsEqual(precision, nil)) {
        return nil
    }
    var precisionNumber interface{} = parseInt(precision)
    if IsTrue(IsEqual(precisionNumber, 0)) {
        return "1"
    }
    var parsedPrecision interface{} = "0."
    for i := 0; IsLessThan(i, Subtract(precisionNumber, 1)); i++ {
        parsedPrecision = Add(parsedPrecision, "0")
    }
    return Add(parsedPrecision, "1")
}
func  (this *Exchange) integerPrecisionToAmount(precision interface{}) interface{}  {
    /**
     * @ignore
     * @method
     * @description handles positive & negative numbers too. parsePrecision() does not handle negative numbers, but this method handles
     * @param {string} precision The number of digits to the right of the decimal
     * @returns {string} a string number equal to 1e-precision
     */
    if IsTrue(IsEqual(precision, nil)) {
        return nil
    }
    if IsTrue(Precise.stringGe(precision, "0")) {
        return this.parsePrecision(precision)
    } else {
        var positivePrecisionString interface{} = Precise.stringAbs(precision)
        var positivePrecision interface{} = parseInt(positivePrecisionString)
        var parsedPrecision interface{} = "1"
        for i := 0; IsLessThan(i, Subtract(positivePrecision, 1)); i++ {
            parsedPrecision = Add(parsedPrecision, "0")
        }
        return Add(parsedPrecision, "0")
    }
}
func  (this *Exchange) loadTimeDifference(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    var serverTime interface{} = this.fetchTime(params)
    var after interface{} = this.milliseconds()
    AddElementToObject(this.options, "timeDifference", Subtract(after, serverTime))
    return GetValue(this.options, "timeDifference")
}
func  (this *Exchange) implodeHostname(url interface{}) interface{}  {
    return this.implodeParams(url, map[string]interface{} {
        "hostname": this.hostname,
    })
}
func  (this *Exchange) fetchMarketLeverageTiers(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchLeverageTiers")) {
        var market interface{} = this.market(symbol)
        if !IsTrue(GetValue(market, "contract")) {
            panic(BadSymbol(Add(this.id, " fetchMarketLeverageTiers() supports contract markets only")))
        }
        var tiers interface{} = this.fetchLeverageTiers([]interface{}{symbol})
        return this.safeValue(tiers, symbol)
    } else {
        panic(NotSupported(Add(this.id, " fetchMarketLeverageTiers() is not supported yet")))
    }
}
func  (this *Exchange) createPostOnlyOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    params := GetArg(optionalArgs, 5, map[string]interface{} {})
    _ = params
    if !IsTrue(GetValue(this.has, "createPostOnlyOrder")) {
        panic(NotSupported(Add(this.id, "createPostOnlyOrder() is not supported yet")))
    }
    var query interface{} = this.extend(params, map[string]interface{} {
        "postOnly": true,
    })
    return this.createOrder(symbol, typeVar, side, amount, price, query)
}
func  (this *Exchange) createPostOnlyOrderWs(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    params := GetArg(optionalArgs, 5, map[string]interface{} {})
    _ = params
    if !IsTrue(GetValue(this.has, "createPostOnlyOrderWs")) {
        panic(NotSupported(Add(this.id, "createPostOnlyOrderWs() is not supported yet")))
    }
    var query interface{} = this.extend(params, map[string]interface{} {
        "postOnly": true,
    })
    return this.createOrderWs(symbol, typeVar, side, amount, price, query)
}
func  (this *Exchange) createReduceOnlyOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    params := GetArg(optionalArgs, 5, map[string]interface{} {})
    _ = params
    if !IsTrue(GetValue(this.has, "createReduceOnlyOrder")) {
        panic(NotSupported(Add(this.id, "createReduceOnlyOrder() is not supported yet")))
    }
    var query interface{} = this.extend(params, map[string]interface{} {
        "reduceOnly": true,
    })
    return this.createOrder(symbol, typeVar, side, amount, price, query)
}
func  (this *Exchange) createReduceOnlyOrderWs(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    params := GetArg(optionalArgs, 5, map[string]interface{} {})
    _ = params
    if !IsTrue(GetValue(this.has, "createReduceOnlyOrderWs")) {
        panic(NotSupported(Add(this.id, "createReduceOnlyOrderWs() is not supported yet")))
    }
    var query interface{} = this.extend(params, map[string]interface{} {
        "reduceOnly": true,
    })
    return this.createOrderWs(symbol, typeVar, side, amount, price, query)
}
func  (this *Exchange) createStopOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    stopPrice := GetArg(optionalArgs, 5, nil)
    _ = stopPrice
    params := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = params
    if !IsTrue(GetValue(this.has, "createStopOrder")) {
        panic(NotSupported(Add(this.id, " createStopOrder() is not supported yet")))
    }
    if IsTrue(IsEqual(stopPrice, nil)) {
        panic(ArgumentsRequired(Add(this.id, " create_stop_order() requires a stopPrice argument")))
    }
    var query interface{} = this.extend(params, map[string]interface{} {
        "stopPrice": stopPrice,
    })
    return this.createOrder(symbol, typeVar, side, amount, price, query)
}
func  (this *Exchange) createStopOrderWs(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    stopPrice := GetArg(optionalArgs, 5, nil)
    _ = stopPrice
    params := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = params
    if !IsTrue(GetValue(this.has, "createStopOrderWs")) {
        panic(NotSupported(Add(this.id, " createStopOrderWs() is not supported yet")))
    }
    if IsTrue(IsEqual(stopPrice, nil)) {
        panic(ArgumentsRequired(Add(this.id, " createStopOrderWs() requires a stopPrice argument")))
    }
    var query interface{} = this.extend(params, map[string]interface{} {
        "stopPrice": stopPrice,
    })
    return this.createOrderWs(symbol, typeVar, side, amount, price, query)
}
func  (this *Exchange) createStopLimitOrder(symbol interface{}, side interface{}, amount interface{}, price interface{}, stopPrice interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 5, map[string]interface{} {})
    _ = params
    if !IsTrue(GetValue(this.has, "createStopLimitOrder")) {
        panic(NotSupported(Add(this.id, " createStopLimitOrder() is not supported yet")))
    }
    var query interface{} = this.extend(params, map[string]interface{} {
        "stopPrice": stopPrice,
    })
    return this.createOrder(symbol, "limit", side, amount, price, query)
}
func  (this *Exchange) createStopLimitOrderWs(symbol interface{}, side interface{}, amount interface{}, price interface{}, stopPrice interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 5, map[string]interface{} {})
    _ = params
    if !IsTrue(GetValue(this.has, "createStopLimitOrderWs")) {
        panic(NotSupported(Add(this.id, " createStopLimitOrderWs() is not supported yet")))
    }
    var query interface{} = this.extend(params, map[string]interface{} {
        "stopPrice": stopPrice,
    })
    return this.createOrderWs(symbol, "limit", side, amount, price, query)
}
func  (this *Exchange) createStopMarketOrder(symbol interface{}, side interface{}, amount interface{}, stopPrice interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    if !IsTrue(GetValue(this.has, "createStopMarketOrder")) {
        panic(NotSupported(Add(this.id, " createStopMarketOrder() is not supported yet")))
    }
    var query interface{} = this.extend(params, map[string]interface{} {
        "stopPrice": stopPrice,
    })
    return this.createOrder(symbol, "market", side, amount, nil, query)
}
func  (this *Exchange) createStopMarketOrderWs(symbol interface{}, side interface{}, amount interface{}, stopPrice interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    if !IsTrue(GetValue(this.has, "createStopMarketOrderWs")) {
        panic(NotSupported(Add(this.id, " createStopMarketOrderWs() is not supported yet")))
    }
    var query interface{} = this.extend(params, map[string]interface{} {
        "stopPrice": stopPrice,
    })
    return this.createOrderWs(symbol, "market", side, amount, nil, query)
}
func  (this *Exchange) safeCurrencyCode(currencyId interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 1, nil)
    _ = currency
    currency = this.safeCurrency(currencyId, currency)
    return GetValue(currency, "code")
}
func  (this *Exchange) filterBySymbolSinceLimit(array interface{}, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    tail := GetArg(optionalArgs, 4, false)
    _ = tail
    return this.filterByValueSinceLimit(array, "symbol", symbol, since, limit, "timestamp", tail)
}
func  (this *Exchange) filterByCurrencySinceLimit(array interface{}, optionalArgs ...interface{}) interface{}  {
    code := GetArg(optionalArgs, 1, nil)
    _ = code
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    tail := GetArg(optionalArgs, 4, false)
    _ = tail
    return this.filterByValueSinceLimit(array, "currency", code, since, limit, "timestamp", tail)
}
func  (this *Exchange) filterBySymbolsSinceLimit(array interface{}, optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 1, nil)
    _ = symbols
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    tail := GetArg(optionalArgs, 4, false)
    _ = tail
    var result interface{} = this.filterByArray(array, "symbol", symbols, false)
    return this.filterBySinceLimit(result, since, limit, "timestamp", tail)
}
func  (this *Exchange) parseLastPrices(pricesData interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // the value of tickers is either a dict or a list
    //
    // dict
    //
    //     {
    //         'marketId1': { ... },
    //         'marketId2': { ... },
    //         ...
    //     }
    //
    // list
    //
    //     [
    //         { 'market': 'marketId1', ... },
    //         { 'market': 'marketId2', ... },
    //         ...
    //     ]
    //
    symbols := GetArg(optionalArgs, 1, nil)
    _ = symbols
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    var results interface{} = []interface{}{}
    if IsTrue(IsArray(pricesData)) {
        for i := 0; IsLessThan(i, GetArrayLength(pricesData)); i++ {
            var priceData interface{} = this.extend(this.parseLastPrice(GetValue(pricesData, i)), params)
            AppendToArray(&results,priceData)
        }
    } else {
        var marketIds interface{} = ObjectKeys(pricesData)
        for i := 0; IsLessThan(i, GetArrayLength(marketIds)); i++ {
            var marketId interface{} = GetValue(marketIds, i)
            var market interface{} = this.safeMarket(marketId)
            var priceData interface{} = this.extend(this.parseLastPrice(GetValue(pricesData, marketId), market), params)
            AppendToArray(&results,priceData)
        }
    }
    symbols = this.marketSymbols(symbols)
    return this.filterByArray(results, "symbol", symbols)
}
func  (this *Exchange) parseTickers(tickers interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // the value of tickers is either a dict or a list
    //
    //
    // dict
    //
    //     {
    //         'marketId1': { ... },
    //         'marketId2': { ... },
    //         'marketId3': { ... },
    //         ...
    //     }
    //
    // list
    //
    //     [
    //         { 'market': 'marketId1', ... },
    //         { 'market': 'marketId2', ... },
    //         { 'market': 'marketId3', ... },
    //         ...
    //     ]
    //
    symbols := GetArg(optionalArgs, 1, nil)
    _ = symbols
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    var results interface{} = []interface{}{}
    if IsTrue(IsArray(tickers)) {
        for i := 0; IsLessThan(i, GetArrayLength(tickers)); i++ {
            var ticker interface{} = this.extend(this.parseTicker(GetValue(tickers, i)), params)
            AppendToArray(&results,ticker)
        }
    } else {
        var marketIds interface{} = ObjectKeys(tickers)
        for i := 0; IsLessThan(i, GetArrayLength(marketIds)); i++ {
            var marketId interface{} = GetValue(marketIds, i)
            var market interface{} = this.safeMarket(marketId)
            var ticker interface{} = this.extend(this.parseTicker(GetValue(tickers, marketId), market), params)
            AppendToArray(&results,ticker)
        }
    }
    symbols = this.marketSymbols(symbols)
    return this.filterByArray(results, "symbol", symbols)
}
func  (this *Exchange) parseDepositAddresses(addresses interface{}, optionalArgs ...interface{}) interface{}  {
    codes := GetArg(optionalArgs, 1, nil)
    _ = codes
    indexed := GetArg(optionalArgs, 2, true)
    _ = indexed
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(addresses)); i++ {
        var address interface{} = this.extend(this.parseDepositAddress(GetValue(addresses, i)), params)
        AppendToArray(&result,address)
    }
    if IsTrue(!IsEqual(codes, nil)) {
        result = this.filterByArray(result, "currency", codes, false)
    }
    if IsTrue(indexed) {
        return this.indexBy(result, "currency")
    }
    return result
}
func  (this *Exchange) parseBorrowInterests(response interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    var interests interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var row interface{} = GetValue(response, i)
        AppendToArray(&interests,this.parseBorrowInterest(row, market))
    }
    return interests
}
func  (this *Exchange) parseIsolatedBorrowRates(info interface{}) interface{}  {
    var result interface{} = map[string]interface{} {}
    for i := 0; IsLessThan(i, GetArrayLength(info)); i++ {
        var item interface{} = GetValue(info, i)
        var borrowRate interface{} = this.parseIsolatedBorrowRate(item)
        var symbol interface{} = this.safeString(borrowRate, "symbol")
        AddElementToObject(result, symbol, borrowRate)
    }
    return result
}
func  (this *Exchange) parseFundingRateHistories(response interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    var rates interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var entry interface{} = GetValue(response, i)
        AppendToArray(&rates,this.parseFundingRateHistory(entry, market))
    }
    var sorted interface{} = this.sortBy(rates, "timestamp")
    var symbol interface{} = Ternary(IsTrue((IsEqual(market, nil))), nil, GetValue(market, "symbol"))
    return this.filterBySymbolSinceLimit(sorted, symbol, since, limit)
}
func  (this *Exchange) safeSymbol(marketId interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    delimiter := GetArg(optionalArgs, 2, nil)
    _ = delimiter
    marketType := GetArg(optionalArgs, 3, nil)
    _ = marketType
    market = this.safeMarket(marketId, market, delimiter, marketType)
    return GetValue(market, "symbol")
}
func  (this *Exchange) parseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseFundingRate() is not supported yet")))
}
func  (this *Exchange) parseFundingRates(response interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    var result interface{} = map[string]interface{} {}
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var parsed interface{} = this.parseFundingRate(GetValue(response, i), market)
        AddElementToObject(result, GetValue(parsed, "symbol"), parsed)
    }
    return result
}
func  (this *Exchange) handleTriggerAndParams(params interface{}) interface{}  {
    var isTrigger interface{} = this.safeBool2(params, "trigger", "stop")
    if IsTrue(isTrigger) {
        params = this.omit(params, []interface{}{"trigger", "stop"})
    }
    return []interface{}{isTrigger, params}
}
func  (this *Exchange) isTriggerOrder(params interface{}) interface{}  {
    // for backwards compatibility
    return this.handleTriggerAndParams(params)
}
func  (this *Exchange) isPostOnly(isMarketOrder interface{}, exchangeSpecificParam interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @param {string} type Order type
    * @param {boolean} exchangeSpecificParam exchange specific postOnly
    * @param {object} [params] exchange specific params
    * @returns {boolean} true if a post only order, false otherwise
    */
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    var timeInForce interface{} = this.safeStringUpper(params, "timeInForce")
    var postOnly interface{} = this.safeBool2(params, "postOnly", "post_only", false)
    // we assume timeInForce is uppercase from safeStringUpper (params, 'timeInForce')
    var ioc interface{} = IsEqual(timeInForce, "IOC")
    var fok interface{} = IsEqual(timeInForce, "FOK")
    var timeInForcePostOnly interface{} = IsEqual(timeInForce, "PO")
    postOnly = IsTrue(IsTrue(postOnly) || IsTrue(timeInForcePostOnly)) || IsTrue(exchangeSpecificParam)
    if IsTrue(postOnly) {
        if IsTrue(IsTrue(ioc) || IsTrue(fok)) {
            panic(InvalidOrder(Add(Add(this.id, " postOnly orders cannot have timeInForce equal to "), timeInForce)))
        } else if IsTrue(isMarketOrder) {
            panic(InvalidOrder(Add(this.id, " market orders cannot be postOnly")))
        } else {
            return true
        }
    } else {
        return false
    }
}
func  (this *Exchange) handlePostOnly(isMarketOrder interface{}, exchangeSpecificPostOnlyOption interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @param {string} type Order type
    * @param {boolean} exchangeSpecificBoolean exchange specific postOnly
    * @param {object} [params] exchange specific params
    * @returns {Array}
    */
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    var timeInForce interface{} = this.safeStringUpper(params, "timeInForce")
    var postOnly interface{} = this.safeBool(params, "postOnly", false)
    var ioc interface{} = IsEqual(timeInForce, "IOC")
    var fok interface{} = IsEqual(timeInForce, "FOK")
    var po interface{} = IsEqual(timeInForce, "PO")
    postOnly = IsTrue(IsTrue(postOnly) || IsTrue(po)) || IsTrue(exchangeSpecificPostOnlyOption)
    if IsTrue(postOnly) {
        if IsTrue(IsTrue(ioc) || IsTrue(fok)) {
            panic(InvalidOrder(Add(Add(this.id, " postOnly orders cannot have timeInForce equal to "), timeInForce)))
        } else if IsTrue(isMarketOrder) {
            panic(InvalidOrder(Add(this.id, " market orders cannot be postOnly")))
        } else {
            if IsTrue(po) {
                params = this.omit(params, "timeInForce")
            }
            params = this.omit(params, "postOnly")
            return []interface{}{true, params}
        }
    }
    return []interface{}{false, params}
}
func  (this *Exchange) fetchLastPrices(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchLastPrices() is not supported yet")))
}
func  (this *Exchange) fetchTradingFees(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchTradingFees() is not supported yet")))
}
func  (this *Exchange) fetchTradingFeesWs(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchTradingFeesWs() is not supported yet")))
}
func  (this *Exchange) fetchTradingFee(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    if !IsTrue(GetValue(this.has, "fetchTradingFees")) {
        panic(NotSupported(Add(this.id, " fetchTradingFee() is not supported yet")))
    }
    var fees interface{} = this.fetchTradingFees(params)
    return this.safeDict(fees, symbol)
}
func  (this *Exchange) fetchConvertCurrencies(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchConvertCurrencies() is not supported yet")))
}
func  (this *Exchange) parseOpenInterest(interest interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseOpenInterest () is not supported yet")))
}
func  (this *Exchange) parseOpenInterests(response interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    var interests interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var entry interface{} = GetValue(response, i)
        var interest interface{} = this.parseOpenInterest(entry, market)
        AppendToArray(&interests,interest)
    }
    var sorted interface{} = this.sortBy(interests, "timestamp")
    var symbol interface{} = this.safeString(market, "symbol")
    return this.filterBySymbolSinceLimit(sorted, symbol, since, limit)
}
func  (this *Exchange) fetchFundingRate(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchFundingRates")) {
        this.loadMarkets()
        var market interface{} = this.market(symbol)
        symbol = GetValue(market, "symbol")
        if !IsTrue(GetValue(market, "contract")) {
            panic(BadSymbol(Add(this.id, " fetchFundingRate() supports contract markets only")))
        }
        var rates interface{} = this.fetchFundingRates([]interface{}{symbol}, params)
        var rate interface{} = this.safeValue(rates, symbol)
        if IsTrue(IsEqual(rate, nil)) {
            panic(NullResponse(Add(Add(this.id, " fetchFundingRate () returned no data for "), symbol)))
        } else {
            return rate
        }
    } else {
        panic(NotSupported(Add(this.id, " fetchFundingRate () is not supported yet")))
    }
}
func  (this *Exchange) fetchMarkOHLCV(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name exchange#fetchMarkOHLCV
    * @description fetches historical mark price candlestick data containing the open, high, low, and close price of a market
    * @param {string} symbol unified symbol of the market to fetch OHLCV data for
    * @param {string} timeframe the length of time each candle represents
    * @param {int} [since] timestamp in ms of the earliest candle to fetch
    * @param {int} [limit] the maximum amount of candles to fetch
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {float[][]} A list of candles ordered as timestamp, open, high, low, close, undefined
    */
    timeframe := GetArg(optionalArgs, 1, "1m")
    _ = timeframe
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchMarkOHLCV")) {
        var request interface{} = map[string]interface{} {
            "price": "mark",
        }
        return this.fetchOHLCV(symbol, timeframe, since, limit, this.extend(request, params))
    } else {
        panic(NotSupported(Add(this.id, " fetchMarkOHLCV () is not supported yet")))
    }
}
func  (this *Exchange) fetchIndexOHLCV(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name exchange#fetchIndexOHLCV
    * @description fetches historical index price candlestick data containing the open, high, low, and close price of a market
    * @param {string} symbol unified symbol of the market to fetch OHLCV data for
    * @param {string} timeframe the length of time each candle represents
    * @param {int} [since] timestamp in ms of the earliest candle to fetch
    * @param {int} [limit] the maximum amount of candles to fetch
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {} A list of candles ordered as timestamp, open, high, low, close, undefined
    */
    timeframe := GetArg(optionalArgs, 1, "1m")
    _ = timeframe
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchIndexOHLCV")) {
        var request interface{} = map[string]interface{} {
            "price": "index",
        }
        return this.fetchOHLCV(symbol, timeframe, since, limit, this.extend(request, params))
    } else {
        panic(NotSupported(Add(this.id, " fetchIndexOHLCV () is not supported yet")))
    }
}
func  (this *Exchange) fetchPremiumIndexOHLCV(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name exchange#fetchPremiumIndexOHLCV
    * @description fetches historical premium index price candlestick data containing the open, high, low, and close price of a market
    * @param {string} symbol unified symbol of the market to fetch OHLCV data for
    * @param {string} timeframe the length of time each candle represents
    * @param {int} [since] timestamp in ms of the earliest candle to fetch
    * @param {int} [limit] the maximum amount of candles to fetch
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {float[][]} A list of candles ordered as timestamp, open, high, low, close, undefined
    */
    timeframe := GetArg(optionalArgs, 1, "1m")
    _ = timeframe
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchPremiumIndexOHLCV")) {
        var request interface{} = map[string]interface{} {
            "price": "premiumIndex",
        }
        return this.fetchOHLCV(symbol, timeframe, since, limit, this.extend(request, params))
    } else {
        panic(NotSupported(Add(this.id, " fetchPremiumIndexOHLCV () is not supported yet")))
    }
}
func  (this *Exchange) handleTimeInForce(optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * Must add timeInForce to this.options to use this method
    * @returns {string} returns the exchange specific value for timeInForce
    */
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    var timeInForce interface{} = this.safeStringUpper(params, "timeInForce") // supported values GTC, IOC, PO
    if IsTrue(!IsEqual(timeInForce, nil)) {
        var exchangeValue interface{} = this.safeString(GetValue(this.options, "timeInForce"), timeInForce)
        if IsTrue(IsEqual(exchangeValue, nil)) {
            panic(ExchangeError(Add(Add(Add(this.id, " does not support timeInForce \""), timeInForce), "\"")))
        }
        return exchangeValue
    }
    return nil
}
func  (this *Exchange) convertTypeToAccount(account interface{}) interface{}  {
    /**
     * @ignore
     * @method
     * Must add accountsByType to this.options to use this method
     * @param {string} account key for account name in this.options['accountsByType']
     * @returns the exchange specific account name or the isolated margin id for transfers
     */
    var accountsByType interface{} = this.safeDict(this.options, "accountsByType", map[string]interface{} {})
    var lowercaseAccount interface{} = ToLower(account)
    if IsTrue(InOp(accountsByType, lowercaseAccount)) {
        return GetValue(accountsByType, lowercaseAccount)
    } else if IsTrue(IsTrue((InOp(this.markets, account))) || IsTrue((InOp(this.markets_by_id, account)))) {
        var market interface{} = this.market(account)
        return GetValue(market, "id")
    } else {
        return account
    }
}
func  (this *Exchange) checkRequiredArgument(methodName interface{}, argument interface{}, argumentName interface{}, optionalArgs ...interface{})  {
    /**
    * @ignore
    * @method
    * @param {string} methodName the name of the method that the argument is being checked for
    * @param {string} argument the argument's actual value provided
    * @param {string} argumentName the name of the argument being checked (for logging purposes)
    * @param {string[]} options a list of options that the argument can be
    * @returns {undefined}
    */
    options := GetArg(optionalArgs, 3, []interface{}{})
    _ = options
    var optionsLength interface{} =     GetArrayLength(options)
    if IsTrue(IsTrue((IsEqual(argument, nil))) || IsTrue((IsTrue((IsGreaterThan(optionsLength, 0))) && IsTrue((!IsTrue((this.inArray(argument, options)))))))) {
        var messageOptions interface{} = Join(options, ", ")
        var message interface{} = Add(Add(Add(Add(Add(this.id, " "), methodName), "() requires a "), argumentName), " argument")
        if IsTrue(!IsEqual(messageOptions, "")) {
            message = Add(message, Add(Add(Add(", one of ", "("), messageOptions), ")"))
        }
        panic(ArgumentsRequired(message))
    }
}
func  (this *Exchange) checkRequiredMarginArgument(methodName interface{}, symbol interface{}, marginMode interface{})  {
    /**
     * @ignore
     * @method
     * @param {string} symbol unified symbol of the market
     * @param {string} methodName name of the method that requires a symbol
     * @param {string} marginMode is either 'isolated' or 'cross'
     */
    if IsTrue(IsTrue((IsEqual(marginMode, "isolated"))) && IsTrue((IsEqual(symbol, nil)))) {
        panic(ArgumentsRequired(Add(Add(Add(this.id, " "), methodName), "() requires a symbol argument for isolated margin")))
    } else if IsTrue(IsTrue((IsEqual(marginMode, "cross"))) && IsTrue((!IsEqual(symbol, nil)))) {
        panic(ArgumentsRequired(Add(Add(Add(this.id, " "), methodName), "() cannot have a symbol argument for cross margin")))
    }
}
func  (this *Exchange) parseDepositWithdrawFees(response interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @param {object[]|object} response unparsed response from the exchange
    * @param {string[]|undefined} codes the unified currency codes to fetch transactions fees for, returns all currencies when undefined
    * @param {str} currencyIdKey *should only be undefined when response is a dictionary* the object key that corresponds to the currency id
    * @returns {object} objects with withdraw and deposit fees, indexed by currency codes
    */
    codes := GetArg(optionalArgs, 1, nil)
    _ = codes
    currencyIdKey := GetArg(optionalArgs, 2, nil)
    _ = currencyIdKey
    var depositWithdrawFees interface{} = map[string]interface{} {}
    var isArray interface{} = IsArray(response)
    var responseKeys interface{} = response
    if !IsTrue(isArray) {
        responseKeys = ObjectKeys(response)
    }
    for i := 0; IsLessThan(i, GetArrayLength(responseKeys)); i++ {
        var entry interface{} = GetValue(responseKeys, i)
        var dictionary interface{} = Ternary(IsTrue(isArray), entry, GetValue(response, entry))
        var currencyId interface{} = Ternary(IsTrue(isArray), this.safeString(dictionary, currencyIdKey), entry)
        var currency interface{} = this.safeCurrency(currencyId)
        var code interface{} = this.safeString(currency, "code")
        if IsTrue(IsTrue((IsEqual(codes, nil))) || IsTrue((this.inArray(code, codes)))) {
            AddElementToObject(depositWithdrawFees, code, this.parseDepositWithdrawFee(dictionary, currency))
        }
    }
    return depositWithdrawFees
}
func  (this *Exchange) parseDepositWithdrawFee(fee interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 1, nil)
    _ = currency
    panic(NotSupported(Add(this.id, " parseDepositWithdrawFee() is not supported yet")))
}
func  (this *Exchange) depositWithdrawFee(info interface{}) interface{}  {
    return map[string]interface{} {
        "info": info,
        "withdraw": map[string]interface{} {
            "fee": nil,
            "percentage": nil,
        },
        "deposit": map[string]interface{} {
            "fee": nil,
            "percentage": nil,
        },
        "networks": map[string]interface{} {},
    }
}
func  (this *Exchange) assignDefaultDepositWithdrawFees(fee interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description Takes a depositWithdrawFee structure and assigns the default values for withdraw and deposit
    * @param {object} fee A deposit withdraw fee structure
    * @param {object} currency A currency structure, the response from this.currency ()
    * @returns {object} A deposit withdraw fee structure
    */
    currency := GetArg(optionalArgs, 1, nil)
    _ = currency
    var networkKeys interface{} = ObjectKeys(GetValue(fee, "networks"))
    var numNetworks interface{} =     GetArrayLength(networkKeys)
    if IsTrue(IsEqual(numNetworks, 1)) {
        AddElementToObject(fee, "withdraw", GetValue(GetValue(GetValue(fee, "networks"), GetValue(networkKeys, 0)), "withdraw"))
        AddElementToObject(fee, "deposit", GetValue(GetValue(GetValue(fee, "networks"), GetValue(networkKeys, 0)), "deposit"))
        return fee
    }
    var currencyCode interface{} = this.safeString(currency, "code")
    for i := 0; IsLessThan(i, numNetworks); i++ {
        var network interface{} = GetValue(networkKeys, i)
        if IsTrue(IsEqual(network, currencyCode)) {
            AddElementToObject(fee, "withdraw", GetValue(GetValue(GetValue(fee, "networks"), GetValue(networkKeys, i)), "withdraw"))
            AddElementToObject(fee, "deposit", GetValue(GetValue(GetValue(fee, "networks"), GetValue(networkKeys, i)), "deposit"))
        }
    }
    return fee
}
func  (this *Exchange) parseIncome(info interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseIncome () is not supported yet")))
}
func  (this *Exchange) parseIncomes(incomes interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description parses funding fee info from exchange response
    * @param {object[]} incomes each item describes once instance of currency being received or paid
    * @param {object} market ccxt market
    * @param {int} [since] when defined, the response items are filtered to only include items after this timestamp
    * @param {int} [limit] limits the number of items in the response
    * @returns {object[]} an array of [funding history structures]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
    */
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(incomes)); i++ {
        var entry interface{} = GetValue(incomes, i)
        var parsed interface{} = this.parseIncome(entry, market)
        AppendToArray(&result,parsed)
    }
    var sorted interface{} = this.sortBy(result, "timestamp")
    return this.filterBySinceLimit(sorted, since, limit)
}
func  (this *Exchange) getMarketFromSymbols(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    if IsTrue(IsEqual(symbols, nil)) {
        return nil
    }
    var firstMarket interface{} = this.safeString(symbols, 0)
    var market interface{} = this.market(firstMarket)
    return market
}
func  (this *Exchange) parseWsOHLCVs(ohlcvs interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    timeframe := GetArg(optionalArgs, 2, "1m")
    _ = timeframe
    since := GetArg(optionalArgs, 3, nil)
    _ = since
    limit := GetArg(optionalArgs, 4, nil)
    _ = limit
    var results interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(ohlcvs)); i++ {
        AppendToArray(&results,this.parseWsOHLCV(GetValue(ohlcvs, i), market))
    }
    return results
}
func  (this *Exchange) fetchTransactions(optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name exchange#fetchTransactions
    * @deprecated
    * @description *DEPRECATED* use fetchDepositsWithdrawals instead
    * @param {string} code unified currency code for the currency of the deposit/withdrawals, default is undefined
    * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
    * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
    */
    code := GetArg(optionalArgs, 0, nil)
    _ = code
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchDepositsWithdrawals")) {
        return this.fetchDepositsWithdrawals(code, since, limit, params)
    } else {
        panic(NotSupported(Add(this.id, " fetchTransactions () is not supported yet")))
    }
}
func  (this *Exchange) filterByArrayPositions(objects interface{}, key interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description Typed wrapper for filterByArray that returns a list of positions
    */
    values := GetArg(optionalArgs, 2, nil)
    _ = values
    indexed := GetArg(optionalArgs, 3, true)
    _ = indexed
    return this.filterByArray(objects, key, values, indexed)
}
func  (this *Exchange) filterByArrayTickers(objects interface{}, key interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description Typed wrapper for filterByArray that returns a dictionary of tickers
    */
    values := GetArg(optionalArgs, 2, nil)
    _ = values
    indexed := GetArg(optionalArgs, 3, true)
    _ = indexed
    return this.filterByArray(objects, key, values, indexed)
}
func  (this *Exchange) createOHLCVObject(symbol interface{}, timeframe interface{}, data interface{}) interface{}  {
    var res interface{} = map[string]interface{} {}
    AddElementToObject(res, symbol, map[string]interface{} {})
    AddElementToObject(GetValue(res, symbol), timeframe, data)
    return res
}
func  (this *Exchange) handleMaxEntriesPerRequestAndParams(method interface{}, optionalArgs ...interface{}) interface{}  {
    maxEntriesPerRequest := GetArg(optionalArgs, 1, nil)
    _ = maxEntriesPerRequest
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    var newMaxEntriesPerRequest interface{} = nil
    newMaxEntriesPerRequestparamsVariable := this.handleOptionAndParams(params, method, "maxEntriesPerRequest");
    newMaxEntriesPerRequest = GetValue(newMaxEntriesPerRequestparamsVariable,0);
    params = GetValue(newMaxEntriesPerRequestparamsVariable,1)
    if IsTrue(IsTrue((!IsEqual(newMaxEntriesPerRequest, nil))) && IsTrue((!IsEqual(newMaxEntriesPerRequest, maxEntriesPerRequest)))) {
        maxEntriesPerRequest = newMaxEntriesPerRequest
    }
    if IsTrue(IsEqual(maxEntriesPerRequest, nil)) {
        maxEntriesPerRequest = 1000 // default to 1000
    }
    return []interface{}{maxEntriesPerRequest, params}
}
func  (this *Exchange) fetchPaginatedCallDynamic(method interface{}, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    maxEntriesPerRequest := GetArg(optionalArgs, 5, nil)
    _ = maxEntriesPerRequest
    var maxCalls interface{} = nil
    maxCallsparamsVariable := this.handleOptionAndParams(params, method, "paginationCalls", 10);
    maxCalls = GetValue(maxCallsparamsVariable,0);
    params = GetValue(maxCallsparamsVariable,1)
    var maxRetries interface{} = nil
    maxRetriesparamsVariable := this.handleOptionAndParams(params, method, "maxRetries", 3);
    maxRetries = GetValue(maxRetriesparamsVariable,0);
    params = GetValue(maxRetriesparamsVariable,1)
    var paginationDirection interface{} = nil
    paginationDirectionparamsVariable := this.handleOptionAndParams(params, method, "paginationDirection", "backward");
    paginationDirection = GetValue(paginationDirectionparamsVariable,0);
    params = GetValue(paginationDirectionparamsVariable,1)
    var paginationTimestamp interface{} = nil
    var calls interface{} = 0
    var result interface{} = []interface{}{}
    var errors interface{} = 0
    var until interface{} = this.safeInteger2(params, "untill", "till") // do not omit it from params here
    maxEntriesPerRequestparamsVariable := this.handleMaxEntriesPerRequestAndParams(method, maxEntriesPerRequest, params);
    maxEntriesPerRequest = GetValue(maxEntriesPerRequestparamsVariable,0);
    params = GetValue(maxEntriesPerRequestparamsVariable,1)
    if IsTrue((IsEqual(paginationDirection, "forward"))) {
        if IsTrue(IsEqual(since, nil)) {
            panic(ArgumentsRequired(Add(this.id, " pagination requires a since argument when paginationDirection set to forward")))
        }
        paginationTimestamp = since
    }
    for (IsLessThan(calls, maxCalls)) {
        calls = Add(calls, 1)
        
        {		ret__ := func(this *Exchange) (ret_ interface{}) {
        		defer func() {
        			if e := recover().(interface{}); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *Exchange) interface{} {
        					// catch block:
                                        errors = Add(errors, 1)
                    if IsTrue(IsGreaterThan(errors, maxRetries)) {
                        panic(e)
                    }
        					return nil
        				}(this)
        			}
        		}()
        		// try block:
                            if IsTrue(IsEqual(paginationDirection, "backward")) {
                        // do it backwards, starting from the last
                        // UNTIL filtering is required in order to work
                        if IsTrue(!IsEqual(paginationTimestamp, nil)) {
                            AddElementToObject(params, "until", Subtract(paginationTimestamp, 1))
                        }
                        var response interface{} = callDynamically(method, symbol, nil, maxEntriesPerRequest, params)
                        var responseLength interface{} =                 GetArrayLength(response)
                        if IsTrue(this.verbose) {
                            var backwardMessage interface{} = Add(Add(Add(Add(Add("Dynamic pagination call ", this.numberToString(calls)), " method "), method), " response length "), this.numberToString(responseLength))
                            if IsTrue(!IsEqual(paginationTimestamp, nil)) {
                                backwardMessage = Add(backwardMessage, Add(" timestamp ", this.numberToString(paginationTimestamp)))
                            }
                            this.log(backwardMessage)
                        }
                        if IsTrue(IsEqual(responseLength, 0)) {
                            panic("break")
                        }
                        errors = 0
                        result = this.arrayConcat(result, response)
                        var firstElement interface{} = this.safeValue(response, 0)
                        paginationTimestamp = this.safeInteger2(firstElement, "timestamp", 0)
                        if IsTrue(IsTrue((!IsEqual(since, nil))) && IsTrue((IsLessThanOrEqual(paginationTimestamp, since)))) {
                            panic("break")
                        }
                    } else {
                        // do it forwards, starting from the since
                        var response interface{} = callDynamically(method, symbol, paginationTimestamp, maxEntriesPerRequest, params)
                        var responseLength interface{} =                 GetArrayLength(response)
                        if IsTrue(this.verbose) {
                            var forwardMessage interface{} = Add(Add(Add(Add(Add("Dynamic pagination call ", this.numberToString(calls)), " method "), method), " response length "), this.numberToString(responseLength))
                            if IsTrue(!IsEqual(paginationTimestamp, nil)) {
                                forwardMessage = Add(forwardMessage, Add(" timestamp ", this.numberToString(paginationTimestamp)))
                            }
                            this.log(forwardMessage)
                        }
                        if IsTrue(IsEqual(responseLength, 0)) {
                            panic("break")
                        }
                        errors = 0
                        result = this.arrayConcat(result, response)
                        var last interface{} = this.safeValue(response, Subtract(responseLength, 1))
                        paginationTimestamp = Subtract(this.safeInteger(last, "timestamp"), 1)
                        if IsTrue(IsTrue((!IsEqual(until, nil))) && IsTrue((IsGreaterThanOrEqual(paginationTimestamp, until)))) {
                            panic("break")
                        }
                    }
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
    }
    var uniqueResults interface{} = this.removeRepeatedElementsFromArray(result)
    var key interface{} = Ternary(IsTrue((IsEqual(method, "fetchOHLCV"))), 0, "timestamp")
    return this.filterBySinceLimit(uniqueResults, since, limit, key)
}
func  (this *Exchange) safeDeterministicCall(method interface{}, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    timeframe := GetArg(optionalArgs, 4, nil)
    _ = timeframe
    params := GetArg(optionalArgs, 5, map[string]interface{} {})
    _ = params
    var maxRetries interface{} = nil
    maxRetriesparamsVariable := this.handleOptionAndParams(params, method, "maxRetries", 3);
    maxRetries = GetValue(maxRetriesparamsVariable,0);
    params = GetValue(maxRetriesparamsVariable,1)
    var errors interface{} = 0
    for IsLessThanOrEqual(errors, maxRetries) {
        
        {		ret__ := func(this *Exchange) (ret_ interface{}) {
        		defer func() {
        			if e := recover().(interface{}); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *Exchange) interface{} {
        					// catch block:
                                        if IsTrue(IsInstance(e, RateLimitExceeded)) {
                        panic(e)
                    }
                    errors = Add(errors, 1)
                    if IsTrue(IsGreaterThan(errors, maxRetries)) {
                        panic(e)
                    }
        					return nil
        				}(this)
        			}
        		}()
        		// try block:
                            if IsTrue(IsTrue(timeframe) && IsTrue(!IsEqual(method, "fetchFundingRateHistory"))) {
                        return callDynamically(method, symbol, timeframe, since, limit, params)
                    } else {
                        return callDynamically(method, symbol, since, limit, params)
                    }
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
    }
    return []interface{}{}
}
func  (this *Exchange) fetchPaginatedCallDeterministic(method interface{}, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    timeframe := GetArg(optionalArgs, 4, nil)
    _ = timeframe
    params := GetArg(optionalArgs, 5, map[string]interface{} {})
    _ = params
    maxEntriesPerRequest := GetArg(optionalArgs, 6, nil)
    _ = maxEntriesPerRequest
    var maxCalls interface{} = nil
    maxCallsparamsVariable := this.handleOptionAndParams(params, method, "paginationCalls", 10);
    maxCalls = GetValue(maxCallsparamsVariable,0);
    params = GetValue(maxCallsparamsVariable,1)
    maxEntriesPerRequestparamsVariable := this.handleMaxEntriesPerRequestAndParams(method, maxEntriesPerRequest, params);
    maxEntriesPerRequest = GetValue(maxEntriesPerRequestparamsVariable,0);
    params = GetValue(maxEntriesPerRequestparamsVariable,1)
    var current interface{} = this.milliseconds()
    var tasks interface{} = []interface{}{}
    var time interface{} = Multiply(this.parseTimeframe(timeframe), 1000)
    var step interface{} = Multiply(time, maxEntriesPerRequest)
    var currentSince interface{} = Subtract(Subtract(current, (Multiply(maxCalls, step))), 1)
    if IsTrue(!IsEqual(since, nil)) {
        currentSince = mathMax(currentSince, since)
    } else {
        currentSince = mathMax(currentSince, 1241440531000) // avoid timestamps older than 2009
    }
    var until interface{} = this.safeInteger2(params, "until", "till") // do not omit it here
    if IsTrue(!IsEqual(until, nil)) {
        var requiredCalls interface{} = MathCeil(Divide((Subtract(until, since)), step))
        if IsTrue(IsGreaterThan(requiredCalls, maxCalls)) {
            panic(BadRequest(Add(Add(Add(Add(this.id, " the number of required calls is greater than the max number of calls allowed, either increase the paginationCalls or decrease the since-until gap. Current paginationCalls limit is "), ToString(maxCalls)), " required calls is "), ToString(requiredCalls))))
        }
    }
    for i := 0; IsLessThan(i, maxCalls); i++ {
        if IsTrue(IsTrue((!IsEqual(until, nil))) && IsTrue((IsGreaterThanOrEqual(currentSince, until)))) {
            break
        }
        if IsTrue(IsGreaterThanOrEqual(currentSince, current)) {
            break
        }
        AppendToArray(&tasks,this.safeDeterministicCall(method, symbol, currentSince, maxEntriesPerRequest, timeframe, params))
        currentSince = Subtract(this.sum(currentSince, step), 1)
    }
    var results interface{} = promiseAll(tasks)
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(results)); i++ {
        result = this.arrayConcat(result, GetValue(results, i))
    }
    var uniqueResults interface{} = this.removeRepeatedElementsFromArray(result)
    var key interface{} = Ternary(IsTrue((IsEqual(method, "fetchOHLCV"))), 0, "timestamp")
    return this.filterBySinceLimit(uniqueResults, since, limit, key)
}
func  (this *Exchange) fetchPaginatedCallCursor(method interface{}, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    cursorReceived := GetArg(optionalArgs, 5, nil)
    _ = cursorReceived
    cursorSent := GetArg(optionalArgs, 6, nil)
    _ = cursorSent
    cursorIncrement := GetArg(optionalArgs, 7, nil)
    _ = cursorIncrement
    maxEntriesPerRequest := GetArg(optionalArgs, 8, nil)
    _ = maxEntriesPerRequest
    var maxCalls interface{} = nil
    maxCallsparamsVariable := this.handleOptionAndParams(params, method, "paginationCalls", 10);
    maxCalls = GetValue(maxCallsparamsVariable,0);
    params = GetValue(maxCallsparamsVariable,1)
    var maxRetries interface{} = nil
    maxRetriesparamsVariable := this.handleOptionAndParams(params, method, "maxRetries", 3);
    maxRetries = GetValue(maxRetriesparamsVariable,0);
    params = GetValue(maxRetriesparamsVariable,1)
    maxEntriesPerRequestparamsVariable := this.handleMaxEntriesPerRequestAndParams(method, maxEntriesPerRequest, params);
    maxEntriesPerRequest = GetValue(maxEntriesPerRequestparamsVariable,0);
    params = GetValue(maxEntriesPerRequestparamsVariable,1)
    var cursorValue interface{} = nil
    var i interface{} = 0
    var errors interface{} = 0
    var result interface{} = []interface{}{}
    for IsLessThan(i, maxCalls) {
        
        {		ret__ := func(this *Exchange) (ret_ interface{}) {
        		defer func() {
        			if e := recover().(interface{}); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *Exchange) interface{} {
        					// catch block:
                                        errors = Add(errors, 1)
                    if IsTrue(IsGreaterThan(errors, maxRetries)) {
                        panic(e)
                    }
        					return nil
        				}(this)
        			}
        		}()
        		// try block:
                            if IsTrue(!IsEqual(cursorValue, nil)) {
                        if IsTrue(!IsEqual(cursorIncrement, nil)) {
                            cursorValue = Add(this.parseToInt(cursorValue), cursorIncrement)
                        }
                        AddElementToObject(params, cursorSent, cursorValue)
                    }
                    var response interface{} = nil
                    if IsTrue(IsEqual(method, "fetchAccounts")) {
                        response = callDynamically(method, params)
                    } else if IsTrue(IsEqual(method, "getLeverageTiersPaginated")) {
                        response = callDynamically(method, symbol, params)
                    } else {
                        response = callDynamically(method, symbol, since, maxEntriesPerRequest, params)
                    }
                    errors = 0
                    var responseLength interface{} =             GetArrayLength(response)
                    if IsTrue(this.verbose) {
                        var cursorString interface{} = Ternary(IsTrue((IsEqual(cursorValue, nil))), "", cursorValue)
                        var iteration interface{} =                 (Add(i, 1))
                        var cursorMessage interface{} = Add(Add(Add(Add(Add(Add(Add("Cursor pagination call ", ToString(iteration)), " method "), method), " response length "), ToString(responseLength)), " cursor "), cursorString)
                        this.log(cursorMessage)
                    }
                    if IsTrue(IsEqual(responseLength, 0)) {
                        panic("break")
                    }
                    result = this.arrayConcat(result, response)
                    var last interface{} = this.safeValue(response, Subtract(responseLength, 1))
                    cursorValue = this.safeValue(GetValue(last, "info"), cursorReceived)
                    if IsTrue(IsEqual(cursorValue, nil)) {
                        panic("break")
                    }
                    var lastTimestamp interface{} = this.safeInteger(last, "timestamp")
                    if IsTrue(IsTrue(!IsEqual(lastTimestamp, nil)) && IsTrue(IsLessThan(lastTimestamp, since))) {
                        panic("break")
                    }
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        i = Add(i, 1)
    }
    var sorted interface{} = this.sortCursorPaginatedResult(result)
    var key interface{} = Ternary(IsTrue((IsEqual(method, "fetchOHLCV"))), 0, "timestamp")
    return this.filterBySinceLimit(sorted, since, limit, key)
}
func  (this *Exchange) fetchPaginatedCallIncremental(method interface{}, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    pageKey := GetArg(optionalArgs, 5, nil)
    _ = pageKey
    maxEntriesPerRequest := GetArg(optionalArgs, 6, nil)
    _ = maxEntriesPerRequest
    var maxCalls interface{} = nil
    maxCallsparamsVariable := this.handleOptionAndParams(params, method, "paginationCalls", 10);
    maxCalls = GetValue(maxCallsparamsVariable,0);
    params = GetValue(maxCallsparamsVariable,1)
    var maxRetries interface{} = nil
    maxRetriesparamsVariable := this.handleOptionAndParams(params, method, "maxRetries", 3);
    maxRetries = GetValue(maxRetriesparamsVariable,0);
    params = GetValue(maxRetriesparamsVariable,1)
    maxEntriesPerRequestparamsVariable := this.handleMaxEntriesPerRequestAndParams(method, maxEntriesPerRequest, params);
    maxEntriesPerRequest = GetValue(maxEntriesPerRequestparamsVariable,0);
    params = GetValue(maxEntriesPerRequestparamsVariable,1)
    var i interface{} = 0
    var errors interface{} = 0
    var result interface{} = []interface{}{}
    for IsLessThan(i, maxCalls) {
        
        {		ret__ := func(this *Exchange) (ret_ interface{}) {
        		defer func() {
        			if e := recover().(interface{}); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *Exchange) interface{} {
        					// catch block:
                                        errors = Add(errors, 1)
                    if IsTrue(IsGreaterThan(errors, maxRetries)) {
                        panic(e)
                    }
        					return nil
        				}(this)
        			}
        		}()
        		// try block:
                            AddElementToObject(params, pageKey, Add(i, 1))
                    var response interface{} = callDynamically(method, symbol, since, maxEntriesPerRequest, params)
                    errors = 0
                    var responseLength interface{} =             GetArrayLength(response)
                    if IsTrue(this.verbose) {
                        var iteration interface{} = ToString((Add(i, 1)))
                        var incrementalMessage interface{} = Add(Add(Add(Add(Add("Incremental pagination call ", iteration), " method "), method), " response length "), ToString(responseLength))
                        this.log(incrementalMessage)
                    }
                    if IsTrue(IsEqual(responseLength, 0)) {
                        panic("break")
                    }
                    result = this.arrayConcat(result, response)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        i = Add(i, 1)
    }
    var sorted interface{} = this.sortCursorPaginatedResult(result)
    var key interface{} = Ternary(IsTrue((IsEqual(method, "fetchOHLCV"))), 0, "timestamp")
    return this.filterBySinceLimit(sorted, since, limit, key)
}
func  (this *Exchange) sortCursorPaginatedResult(result interface{}) interface{}  {
    var first interface{} = this.safeValue(result, 0)
    if IsTrue(!IsEqual(first, nil)) {
        if IsTrue(InOp(first, "timestamp")) {
            return this.sortBy(result, "timestamp", true)
        }
        if IsTrue(InOp(first, "id")) {
            return this.sortBy(result, "id", true)
        }
    }
    return result
}
func  (this *Exchange) removeRepeatedElementsFromArray(input interface{}) interface{}  {
    var uniqueResult interface{} = map[string]interface{} {}
    for i := 0; IsLessThan(i, GetArrayLength(input)); i++ {
        var entry interface{} = GetValue(input, i)
        var id interface{} = this.safeString(entry, "id")
        if IsTrue(!IsEqual(id, nil)) {
            if IsTrue(IsEqual(this.safeString(uniqueResult, id), nil)) {
                AddElementToObject(uniqueResult, id, entry)
            }
        } else {
            var timestamp interface{} = this.safeInteger2(entry, "timestamp", 0)
            if IsTrue(!IsEqual(timestamp, nil)) {
                if IsTrue(IsEqual(this.safeString(uniqueResult, timestamp), nil)) {
                    AddElementToObject(uniqueResult, timestamp, entry)
                }
            }
        }
    }
    var values interface{} = ObjectValues(uniqueResult)
    var valuesLength interface{} =     GetArrayLength(values)
    if IsTrue(IsGreaterThan(valuesLength, 0)) {
        return values
    }
    return input
}
func  (this *Exchange) handleUntilOption(key interface{}, request interface{}, params interface{}, optionalArgs ...interface{}) interface{}  {
    multiplier := GetArg(optionalArgs, 3, 1)
    _ = multiplier
    var until interface{} = this.safeInteger2(params, "until", "till")
    if IsTrue(!IsEqual(until, nil)) {
        AddElementToObject(request, key, this.parseToInt(Multiply(until, multiplier)))
        params = this.omit(params, []interface{}{"until", "till"})
    }
    return []interface{}{request, params}
}
func  (this *Exchange) safeOpenInterest(interest interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    return this.extend(interest, map[string]interface{} {
        "symbol": this.safeString(market, "symbol"),
        "baseVolume": this.safeNumber(interest, "baseVolume"),
        "quoteVolume": this.safeNumber(interest, "quoteVolume"),
        "openInterestAmount": this.safeNumber(interest, "openInterestAmount"),
        "openInterestValue": this.safeNumber(interest, "openInterestValue"),
        "timestamp": this.safeInteger(interest, "timestamp"),
        "datetime": this.safeString(interest, "datetime"),
        "info": this.safeValue(interest, "info"),
    })
}
func  (this *Exchange) parseLiquidation(liquidation interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseLiquidation () is not supported yet")))
}
func  (this *Exchange) parseLiquidations(liquidations interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description parses liquidation info from the exchange response
    * @param {object[]} liquidations each item describes an instance of a liquidation event
    * @param {object} market ccxt market
    * @param {int} [since] when defined, the response items are filtered to only include items after this timestamp
    * @param {int} [limit] limits the number of items in the response
    * @returns {object[]} an array of [liquidation structures]{@link https://docs.ccxt.com/#/?id=liquidation-structure}
    */
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(liquidations)); i++ {
        var entry interface{} = GetValue(liquidations, i)
        var parsed interface{} = this.parseLiquidation(entry, market)
        AppendToArray(&result,parsed)
    }
    var sorted interface{} = this.sortBy(result, "timestamp")
    var symbol interface{} = this.safeString(market, "symbol")
    return this.filterBySymbolSinceLimit(sorted, symbol, since, limit)
}
func  (this *Exchange) parseGreeks(greeks interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseGreeks () is not supported yet")))
}
func  (this *Exchange) parseOption(chain interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 1, nil)
    _ = currency
    market := GetArg(optionalArgs, 2, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseOption () is not supported yet")))
}
func  (this *Exchange) parseOptionChain(response interface{}, optionalArgs ...interface{}) interface{}  {
    currencyKey := GetArg(optionalArgs, 1, nil)
    _ = currencyKey
    symbolKey := GetArg(optionalArgs, 2, nil)
    _ = symbolKey
    var optionStructures interface{} = map[string]interface{} {}
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var info interface{} = GetValue(response, i)
        var currencyId interface{} = this.safeString(info, currencyKey)
        var currency interface{} = this.safeCurrency(currencyId)
        var marketId interface{} = this.safeString(info, symbolKey)
        var market interface{} = this.safeMarket(marketId, nil, nil, "option")
        AddElementToObject(optionStructures, GetValue(market, "symbol"), this.parseOption(info, currency, market))
    }
    return optionStructures
}
func  (this *Exchange) parseMarginModes(response interface{}, optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 1, nil)
    _ = symbols
    symbolKey := GetArg(optionalArgs, 2, nil)
    _ = symbolKey
    marketType := GetArg(optionalArgs, 3, nil)
    _ = marketType
    var marginModeStructures interface{} = map[string]interface{} {}
    if IsTrue(IsEqual(marketType, nil)) {
        marketType = "swap" // default to swap
    }
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var info interface{} = GetValue(response, i)
        var marketId interface{} = this.safeString(info, symbolKey)
        var market interface{} = this.safeMarket(marketId, nil, nil, marketType)
        if IsTrue(IsTrue((IsEqual(symbols, nil))) || IsTrue(this.inArray(GetValue(market, "symbol"), symbols))) {
            AddElementToObject(marginModeStructures, GetValue(market, "symbol"), this.parseMarginMode(info, market))
        }
    }
    return marginModeStructures
}
func  (this *Exchange) parseMarginMode(marginMode interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseMarginMode () is not supported yet")))
}
func  (this *Exchange) parseLeverages(response interface{}, optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 1, nil)
    _ = symbols
    symbolKey := GetArg(optionalArgs, 2, nil)
    _ = symbolKey
    marketType := GetArg(optionalArgs, 3, nil)
    _ = marketType
    var leverageStructures interface{} = map[string]interface{} {}
    if IsTrue(IsEqual(marketType, nil)) {
        marketType = "swap" // default to swap
    }
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var info interface{} = GetValue(response, i)
        var marketId interface{} = this.safeString(info, symbolKey)
        var market interface{} = this.safeMarket(marketId, nil, nil, marketType)
        if IsTrue(IsTrue((IsEqual(symbols, nil))) || IsTrue(this.inArray(GetValue(market, "symbol"), symbols))) {
            AddElementToObject(leverageStructures, GetValue(market, "symbol"), this.parseLeverage(info, market))
        }
    }
    return leverageStructures
}
func  (this *Exchange) parseLeverage(leverage interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseLeverage () is not supported yet")))
}
func  (this *Exchange) parseConversions(conversions interface{}, optionalArgs ...interface{}) interface{}  {
    code := GetArg(optionalArgs, 1, nil)
    _ = code
    fromCurrencyKey := GetArg(optionalArgs, 2, nil)
    _ = fromCurrencyKey
    toCurrencyKey := GetArg(optionalArgs, 3, nil)
    _ = toCurrencyKey
    since := GetArg(optionalArgs, 4, nil)
    _ = since
    limit := GetArg(optionalArgs, 5, nil)
    _ = limit
    params := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = params
    conversions = this.toArray(conversions)
    var result interface{} = []interface{}{}
    var fromCurrency interface{} = nil
    var toCurrency interface{} = nil
    for i := 0; IsLessThan(i, GetArrayLength(conversions)); i++ {
        var entry interface{} = GetValue(conversions, i)
        var fromId interface{} = this.safeString(entry, fromCurrencyKey)
        var toId interface{} = this.safeString(entry, toCurrencyKey)
        if IsTrue(!IsEqual(fromId, nil)) {
            fromCurrency = this.safeCurrency(fromId)
        }
        if IsTrue(!IsEqual(toId, nil)) {
            toCurrency = this.safeCurrency(toId)
        }
        var conversion interface{} = this.extend(this.parseConversion(entry, fromCurrency, toCurrency), params)
        AppendToArray(&result,conversion)
    }
    var sorted interface{} = this.sortBy(result, "timestamp")
    var currency interface{} = nil
    if IsTrue(!IsEqual(code, nil)) {
        currency = this.safeCurrency(code)
        code = GetValue(currency, "code")
    }
    if IsTrue(IsEqual(code, nil)) {
        return this.filterBySinceLimit(sorted, since, limit)
    }
    var fromConversion interface{} = this.filterBy(sorted, "fromCurrency", code)
    var toConversion interface{} = this.filterBy(sorted, "toCurrency", code)
    var both interface{} = this.arrayConcat(fromConversion, toConversion)
    return this.filterBySinceLimit(both, since, limit)
}
func  (this *Exchange) parseConversion(conversion interface{}, optionalArgs ...interface{}) interface{}  {
    fromCurrency := GetArg(optionalArgs, 1, nil)
    _ = fromCurrency
    toCurrency := GetArg(optionalArgs, 2, nil)
    _ = toCurrency
    panic(NotSupported(Add(this.id, " parseConversion () is not supported yet")))
}
func  (this *Exchange) convertExpireDate(date interface{}) interface{}  {
    // parse YYMMDD to datetime string
    var year interface{} = Slice(date, 0, 2)
    var month interface{} = Slice(date, 2, 4)
    var day interface{} = Slice(date, 4, 6)
    var reconstructedDate interface{} = Add(Add(Add(Add(Add(Add("20", year), "-"), month), "-"), day), "T00:00:00Z")
    return reconstructedDate
}
func  (this *Exchange) convertExpireDateToMarketIdDate(date interface{}) interface{}  {
    // parse 240119 to 19JAN24
    var year interface{} = Slice(date, 0, 2)
    var monthRaw interface{} = Slice(date, 2, 4)
    var month interface{} = nil
    var day interface{} = Slice(date, 4, 6)
    if IsTrue(IsEqual(monthRaw, "01")) {
        month = "JAN"
    } else if IsTrue(IsEqual(monthRaw, "02")) {
        month = "FEB"
    } else if IsTrue(IsEqual(monthRaw, "03")) {
        month = "MAR"
    } else if IsTrue(IsEqual(monthRaw, "04")) {
        month = "APR"
    } else if IsTrue(IsEqual(monthRaw, "05")) {
        month = "MAY"
    } else if IsTrue(IsEqual(monthRaw, "06")) {
        month = "JUN"
    } else if IsTrue(IsEqual(monthRaw, "07")) {
        month = "JUL"
    } else if IsTrue(IsEqual(monthRaw, "08")) {
        month = "AUG"
    } else if IsTrue(IsEqual(monthRaw, "09")) {
        month = "SEP"
    } else if IsTrue(IsEqual(monthRaw, "10")) {
        month = "OCT"
    } else if IsTrue(IsEqual(monthRaw, "11")) {
        month = "NOV"
    } else if IsTrue(IsEqual(monthRaw, "12")) {
        month = "DEC"
    }
    var reconstructedDate interface{} = Add(Add(day, month), year)
    return reconstructedDate
}
func  (this *Exchange) convertMarketIdExpireDate(date interface{}) interface{}  {
    // parse 03JAN24 to 240103
    var monthMappping interface{} = map[string]interface{} {
        "JAN": "01",
        "FEB": "02",
        "MAR": "03",
        "APR": "04",
        "MAY": "05",
        "JUN": "06",
        "JUL": "07",
        "AUG": "08",
        "SEP": "09",
        "OCT": "10",
        "NOV": "11",
        "DEC": "12",
    }
    // if exchange omits first zero and provides i.e. '3JAN24' instead of '03JAN24'
    if IsTrue(IsEqual(GetLength(date), 6)) {
        date = Add("0", date)
    }
    var year interface{} = Slice(date, 0, 2)
    var monthName interface{} = Slice(date, 2, 5)
    var month interface{} = this.safeString(monthMappping, monthName)
    var day interface{} = Slice(date, 5, 7)
    var reconstructedDate interface{} = Add(Add(day, month), year)
    return reconstructedDate
}
func  (this *Exchange) fetchPositionHistory(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name exchange#fetchPositionHistory
    * @description fetches the history of margin added or reduced from contract isolated positions
    * @param {string} [symbol] unified market symbol
    * @param {int} [since] timestamp in ms of the position
    * @param {int} [limit] the maximum amount of candles to fetch, default=1000
    * @param {object} params extra parameters specific to the exchange api endpoint
    * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
    */
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchPositionsHistory")) {
        var positions interface{} = this.fetchPositionsHistory([]interface{}{symbol}, since, limit, params)
        return this.safeDict(positions, 0)
    } else {
        panic(NotSupported(Add(this.id, " fetchPositionHistory () is not supported yet")))
    }
}
func  (this *Exchange) fetchPositionsHistory(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchPositionsHistory () is not supported yet")))
}
func  (this *Exchange) parseMarginModification(data interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseMarginModification() is not supported yet")))
}
func  (this *Exchange) parseMarginModifications(response interface{}, optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 1, nil)
    _ = symbols
    symbolKey := GetArg(optionalArgs, 2, nil)
    _ = symbolKey
    marketType := GetArg(optionalArgs, 3, nil)
    _ = marketType
    var marginModifications interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var info interface{} = GetValue(response, i)
        var marketId interface{} = this.safeString(info, symbolKey)
        var market interface{} = this.safeMarket(marketId, nil, nil, marketType)
        if IsTrue(IsTrue((IsEqual(symbols, nil))) || IsTrue(this.inArray(GetValue(market, "symbol"), symbols))) {
            AppendToArray(&marginModifications,this.parseMarginModification(info, market))
        }
    }
    return marginModifications
}
func  (this *Exchange) fetchTransfer(id interface{}, optionalArgs ...interface{}) interface{}  {
    code := GetArg(optionalArgs, 1, nil)
    _ = code
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchTransfer () is not supported yet")))
}
func  (this *Exchange) fetchTransfers(optionalArgs ...interface{}) interface{}  {
    code := GetArg(optionalArgs, 0, nil)
    _ = code
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchTransfers () is not supported yet")))
}

