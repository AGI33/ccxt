package ccxt
import "helpers"
// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

func  (this *Exchange) safeBoolN(dictionaryOrList interface{}, keys interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description safely extract boolean value from dictionary or list
    * @returns {bool | undefined}
    */
    defaultValue := GetArg(optionalArgs, 2, nil)
    _ = defaultValue
    value := this.safeValueN(dictionaryOrList, keys, defaultValue)
    if IsTrue(IsBool(value)) {
        return value
    }
    return defaultValue
}
func  (this *Exchange) safeBool2(dictionary interface{}, key1 interface{}, key2 interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description safely extract boolean value from dictionary or list
    * @returns {bool | undefined}
    */
    defaultValue := GetArg(optionalArgs, 3, nil)
    _ = defaultValue
    return this.safeBoolN(dictionary, []interface{}{key1, key2}, defaultValue)
}
func  (this *Exchange) safeBool(dictionary interface{}, key interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description safely extract boolean value from dictionary or list
    * @returns {bool | undefined}
    */
    defaultValue := GetArg(optionalArgs, 2, nil)
    _ = defaultValue
    return this.safeBoolN(dictionary, []interface{}{key}, defaultValue)
}
func  (this *Exchange) safeDictN(dictionaryOrList interface{}, keys interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description safely extract a dictionary from dictionary or list
    * @returns {object | undefined}
    */
    defaultValue := GetArg(optionalArgs, 2, nil)
    _ = defaultValue
    value := this.safeValueN(dictionaryOrList, keys, defaultValue)
    if IsTrue(IsEqual(value, nil)) {
        return defaultValue
    }
    if IsTrue(IsObject(value)) {
        return value
    }
    return defaultValue
}
func  (this *Exchange) safeDict(dictionary interface{}, key interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description safely extract a dictionary from dictionary or list
    * @returns {object | undefined}
    */
    defaultValue := GetArg(optionalArgs, 2, nil)
    _ = defaultValue
    return this.safeDictN(dictionary, []interface{}{key}, defaultValue)
}
func  (this *Exchange) safeDict2(dictionary interface{}, key1 interface{}, key2 string, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description safely extract a dictionary from dictionary or list
    * @returns {object | undefined}
    */
    defaultValue := GetArg(optionalArgs, 3, nil)
    _ = defaultValue
    return this.safeDictN(dictionary, []interface{}{key1, key2}, defaultValue)
}
func  (this *Exchange) safeListN(dictionaryOrList interface{}, keys interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description safely extract an Array from dictionary or list
    * @returns {Array | undefined}
    */
    defaultValue := GetArg(optionalArgs, 2, nil)
    _ = defaultValue
    value := this.safeValueN(dictionaryOrList, keys, defaultValue)
    if IsTrue(IsEqual(value, nil)) {
        return defaultValue
    }
    if IsTrue(IsArray(value)) {
        return value
    }
    return defaultValue
}
func  (this *Exchange) safeList2(dictionaryOrList interface{}, key1 interface{}, key2 string, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description safely extract an Array from dictionary or list
    * @returns {Array | undefined}
    */
    defaultValue := GetArg(optionalArgs, 3, nil)
    _ = defaultValue
    return this.safeListN(dictionaryOrList, []interface{}{key1, key2}, defaultValue)
}
func  (this *Exchange) safeList(dictionaryOrList interface{}, key interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description safely extract an Array from dictionary or list
    * @returns {Array | undefined}
    */
    defaultValue := GetArg(optionalArgs, 2, nil)
    _ = defaultValue
    return this.safeListN(dictionaryOrList, []interface{}{key}, defaultValue)
}
func  (this *Exchange) handleDeltas(orderbook interface{}, deltas interface{})  {
    for i := 0; IsLessThan(i, GetArrayLength(deltas)); i++ {
        this.handleDelta(orderbook, GetValue(deltas, i))
    }
}
func  (this *Exchange) handleDelta(bookside interface{}, delta interface{})  {
    panic(NotSupported(Add(this.id, " handleDelta not supported yet")))
}
func  (this *Exchange) getCacheIndex(orderbook interface{}, deltas interface{}) interface{}  {
    // return the first index of the cache that can be applied to the orderbook or -1 if not possible
    return -1
}
func  (this *Exchange) findTimeframe(timeframe interface{}, optionalArgs ...interface{}) interface{}  {
    timeframes := GetArg(optionalArgs, 1, nil)
    _ = timeframes
    if IsTrue(IsEqual(timeframes, nil)) {
        timeframes = this.timeframes
    }
    keys := ObjectKeys(timeframes)
    for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
        key := GetValue(keys, i)
        if IsTrue(IsEqual(GetValue(timeframes, key), timeframe)) {
            return key
        }
    }
    return nil
}
func  (this *Exchange) checkProxyUrlSettings(optionalArgs ...interface{}) interface{}  {
    url := GetArg(optionalArgs, 0, nil)
    _ = url
    method := GetArg(optionalArgs, 1, nil)
    _ = method
    headers := GetArg(optionalArgs, 2, nil)
    _ = headers
    body := GetArg(optionalArgs, 3, nil)
    _ = body
    usedProxies := []interface{}{}
    var proxyUrl interface{} = nil
    if IsTrue(!IsEqual(this.proxyUrl, nil)) {
        usedProxies = AppendToArray(usedProxies,"proxyUrl").([]interface{})
        proxyUrl = this.proxyUrl
    }
    if IsTrue(!IsEqual(this.proxy_url, nil)) {
        usedProxies = AppendToArray(usedProxies,"proxy_url").([]interface{})
        proxyUrl = this.proxy_url
    }
    if IsTrue(!IsEqual(this.proxyUrlCallback, nil)) {
        usedProxies = AppendToArray(usedProxies,"proxyUrlCallback").([]interface{})
        proxyUrl = callDynamically("proxyUrlCallback", url, method, headers, body)
    }
    if IsTrue(!IsEqual(this.proxy_url_callback, nil)) {
        usedProxies = AppendToArray(usedProxies,"proxy_url_callback").([]interface{})
        proxyUrl = callDynamically("proxy_url_callback", url, method, headers, body)
    }
    // backwards-compatibility
    if IsTrue(!IsEqual(this.proxy, nil)) {
        usedProxies = AppendToArray(usedProxies,"proxy").([]interface{})
        if IsTrue(IsFunction(this.proxy)) {
            proxyUrl = callDynamically("proxy", url, method, headers, body)
        } else {
            proxyUrl = this.proxy
        }
    }
    length := GetArrayLength(usedProxies)
    if IsTrue(IsGreaterThan(length, 1)) {
        joinedProxyNames := Join(usedProxies, ",")
        panic(ProxyError(Add(Add(Add(this.id, " you have multiple conflicting proxy settings ("), joinedProxyNames), "), please use only one from : proxyUrl, proxy_url, proxyUrlCallback, proxy_url_callback")))
    }
    return proxyUrl
}
func  (this *Exchange) checkProxySettings(optionalArgs ...interface{}) interface{}  {
    url := GetArg(optionalArgs, 0, nil)
    _ = url
    method := GetArg(optionalArgs, 1, nil)
    _ = method
    headers := GetArg(optionalArgs, 2, nil)
    _ = headers
    body := GetArg(optionalArgs, 3, nil)
    _ = body
    usedProxies := []interface{}{}
    var httpProxy interface{} = nil
    var httpsProxy interface{} = nil
    var socksProxy interface{} = nil
    // httpProxy
    if IsTrue(this.valueIsDefined(this.httpProxy)) {
        usedProxies = AppendToArray(usedProxies,"httpProxy").([]interface{})
        httpProxy = this.httpProxy
    }
    if IsTrue(this.valueIsDefined(this.http_proxy)) {
        usedProxies = AppendToArray(usedProxies,"http_proxy").([]interface{})
        httpProxy = this.http_proxy
    }
    if IsTrue(!IsEqual(this.httpProxyCallback, nil)) {
        usedProxies = AppendToArray(usedProxies,"httpProxyCallback").([]interface{})
        httpProxy = callDynamically("httpProxyCallback", url, method, headers, body)
    }
    if IsTrue(!IsEqual(this.http_proxy_callback, nil)) {
        usedProxies = AppendToArray(usedProxies,"http_proxy_callback").([]interface{})
        httpProxy = callDynamically("http_proxy_callback", url, method, headers, body)
    }
    // httpsProxy
    if IsTrue(this.valueIsDefined(this.httpsProxy)) {
        usedProxies = AppendToArray(usedProxies,"httpsProxy").([]interface{})
        httpsProxy = this.httpsProxy
    }
    if IsTrue(this.valueIsDefined(this.https_proxy)) {
        usedProxies = AppendToArray(usedProxies,"https_proxy").([]interface{})
        httpsProxy = this.https_proxy
    }
    if IsTrue(!IsEqual(this.httpsProxyCallback, nil)) {
        usedProxies = AppendToArray(usedProxies,"httpsProxyCallback").([]interface{})
        httpsProxy = callDynamically("httpsProxyCallback", url, method, headers, body)
    }
    if IsTrue(!IsEqual(this.https_proxy_callback, nil)) {
        usedProxies = AppendToArray(usedProxies,"https_proxy_callback").([]interface{})
        httpsProxy = callDynamically("https_proxy_callback", url, method, headers, body)
    }
    // socksProxy
    if IsTrue(this.valueIsDefined(this.socksProxy)) {
        usedProxies = AppendToArray(usedProxies,"socksProxy").([]interface{})
        socksProxy = this.socksProxy
    }
    if IsTrue(this.valueIsDefined(this.socks_proxy)) {
        usedProxies = AppendToArray(usedProxies,"socks_proxy").([]interface{})
        socksProxy = this.socks_proxy
    }
    if IsTrue(!IsEqual(this.socksProxyCallback, nil)) {
        usedProxies = AppendToArray(usedProxies,"socksProxyCallback").([]interface{})
        socksProxy = callDynamically("socksProxyCallback", url, method, headers, body)
    }
    if IsTrue(!IsEqual(this.socks_proxy_callback, nil)) {
        usedProxies = AppendToArray(usedProxies,"socks_proxy_callback").([]interface{})
        socksProxy = callDynamically("socks_proxy_callback", url, method, headers, body)
    }
    // check
    length := GetArrayLength(usedProxies)
    if IsTrue(IsGreaterThan(length, 1)) {
        joinedProxyNames := Join(usedProxies, ",")
        panic(ProxyError(Add(Add(Add(this.id, " you have multiple conflicting proxy settings ("), joinedProxyNames), "), please use only one from: httpProxy, httpsProxy, httpProxyCallback, httpsProxyCallback, socksProxy, socksProxyCallback")))
    }
    return []interface{}{httpProxy, httpsProxy, socksProxy}
}
func  (this *Exchange) checkWsProxySettings() interface{}  {
    usedProxies := []interface{}{}
    var wsProxy interface{} = nil
    var wssProxy interface{} = nil
    var wsSocksProxy interface{} = nil
    // ws proxy
    if IsTrue(this.valueIsDefined(this.wsProxy)) {
        usedProxies = AppendToArray(usedProxies,"wsProxy").([]interface{})
        wsProxy = this.wsProxy
    }
    if IsTrue(this.valueIsDefined(this.ws_proxy)) {
        usedProxies = AppendToArray(usedProxies,"ws_proxy").([]interface{})
        wsProxy = this.ws_proxy
    }
    // wss proxy
    if IsTrue(this.valueIsDefined(this.wssProxy)) {
        usedProxies = AppendToArray(usedProxies,"wssProxy").([]interface{})
        wssProxy = this.wssProxy
    }
    if IsTrue(this.valueIsDefined(this.wss_proxy)) {
        usedProxies = AppendToArray(usedProxies,"wss_proxy").([]interface{})
        wssProxy = this.wss_proxy
    }
    // ws socks proxy
    if IsTrue(this.valueIsDefined(this.wsSocksProxy)) {
        usedProxies = AppendToArray(usedProxies,"wsSocksProxy").([]interface{})
        wsSocksProxy = this.wsSocksProxy
    }
    if IsTrue(this.valueIsDefined(this.ws_socks_proxy)) {
        usedProxies = AppendToArray(usedProxies,"ws_socks_proxy").([]interface{})
        wsSocksProxy = this.ws_socks_proxy
    }
    // check
    length := GetArrayLength(usedProxies)
    if IsTrue(IsGreaterThan(length, 1)) {
        joinedProxyNames := Join(usedProxies, ",")
        panic(ProxyError(Add(Add(Add(this.id, " you have multiple conflicting proxy settings ("), joinedProxyNames), "), please use only one from: wsProxy, wssProxy, wsSocksProxy")))
    }
    return []interface{}{wsProxy, wssProxy, wsSocksProxy}
}
func  (this *Exchange) checkConflictingProxies(proxyAgentSet interface{}, proxyUrlSet interface{})  {
    if IsTrue(IsTrue(proxyAgentSet) && IsTrue(proxyUrlSet)) {
        panic(ProxyError(Add(this.id, " you have multiple conflicting proxy settings, please use only one from : proxyUrl, httpProxy, httpsProxy, socksProxy")))
    }
}
func  (this *Exchange) findMessageHashes(client interface{}, element string) interface{}  {
    result := []interface{}{}
    messageHashes := ObjectKeys(client.futures)
    for i := 0; IsLessThan(i, GetArrayLength(messageHashes)); i++ {
        messageHash := GetValue(messageHashes, i)
        if IsTrue(IsGreaterThanOrEqual(GetIndexOf(messageHash, element), 0)) {
            result = AppendToArray(result,messageHash).([]interface{})
        }
    }
    return result
}
func  (this *Exchange) filterByLimit(array interface{}, optionalArgs ...interface{}) interface{}  {
    limit := GetArg(optionalArgs, 1, nil)
    _ = limit
    key := GetArg(optionalArgs, 2, "timestamp")
    _ = key
    fromStart := GetArg(optionalArgs, 3, false)
    _ = fromStart
    if IsTrue(this.valueIsDefined(limit)) {
        arrayLength := GetArrayLength(array)
        if IsTrue(IsGreaterThan(arrayLength, 0)) {
            ascending := true
            if IsTrue((InOp(GetValue(array, 0), key))) {
                first := GetValue(GetValue(array, 0), key)
                last := GetValue(GetValue(array, Subtract(arrayLength, 1)), key)
                if IsTrue(IsTrue(!IsEqual(first, nil)) && IsTrue(!IsEqual(last, nil))) {
                    ascending = IsLessThanOrEqual(first, last) // true if array is sorted in ascending order based on 'timestamp'
                }
            }
            if IsTrue(fromStart) {
                if IsTrue(IsGreaterThan(limit, arrayLength)) {
                    limit = arrayLength
                }
                array = Ternary(IsTrue(ascending), this.arraySlice(array, 0, limit), this.arraySlice(array, -limit))
            } else {
                array = Ternary(IsTrue(ascending), this.arraySlice(array, -limit), this.arraySlice(array, 0, limit))
            }
        }
    }
    return array
}
func  (this *Exchange) filterBySinceLimit(array interface{}, optionalArgs ...interface{}) interface{}  {
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    key := GetArg(optionalArgs, 3, "timestamp")
    _ = key
    tail := GetArg(optionalArgs, 4, false)
    _ = tail
    sinceIsDefined := this.valueIsDefined(since)
    parsedArray := this.toArray(array)
    result := parsedArray
    if IsTrue(sinceIsDefined) {
        result = []interface{}{}
        for i := 0; IsLessThan(i, GetArrayLength(parsedArray)); i++ {
            entry := GetValue(parsedArray, i)
            value := this.safeValue(entry, key)
            if IsTrue(IsTrue(value) && IsTrue((IsGreaterThanOrEqual(value, since)))) {
                result = AppendToArray(result,entry).([]interface{})
            }
        }
    }
    if IsTrue(IsTrue(tail) && IsTrue(!IsEqual(limit, nil))) {
        return this.arraySlice(result, -limit)
    }
    // if the user provided a 'since' argument
    // we want to limit the result starting from the 'since'
    shouldFilterFromStart := !IsTrue(tail) && IsTrue(sinceIsDefined)
    return this.filterByLimit(result, limit, key, shouldFilterFromStart)
}
func  (this *Exchange) filterByValueSinceLimit(array interface{}, field interface{}, optionalArgs ...interface{}) interface{}  {
    value := GetArg(optionalArgs, 2, nil)
    _ = value
    since := GetArg(optionalArgs, 3, nil)
    _ = since
    limit := GetArg(optionalArgs, 4, nil)
    _ = limit
    key := GetArg(optionalArgs, 5, "timestamp")
    _ = key
    tail := GetArg(optionalArgs, 6, false)
    _ = tail
    valueIsDefined := this.valueIsDefined(value)
    sinceIsDefined := this.valueIsDefined(since)
    parsedArray := this.toArray(array)
    result := parsedArray
    // single-pass filter for both symbol and since
    if IsTrue(IsTrue(valueIsDefined) || IsTrue(sinceIsDefined)) {
        result = []interface{}{}
        for i := 0; IsLessThan(i, GetArrayLength(parsedArray)); i++ {
            entry := GetValue(parsedArray, i)
            entryFiledEqualValue := IsEqual(GetValue(entry, field), value)
            firstCondition := Ternary(IsTrue(valueIsDefined), entryFiledEqualValue, true)
            entryKeyValue := this.safeValue(entry, key)
            entryKeyGESince := IsTrue(IsTrue((entryKeyValue)) && IsTrue(since)) && IsTrue((IsGreaterThanOrEqual(entryKeyValue, since)))
            secondCondition := Ternary(IsTrue(sinceIsDefined), entryKeyGESince, true)
            if IsTrue(IsTrue(firstCondition) && IsTrue(secondCondition)) {
                result = AppendToArray(result,entry).([]interface{})
            }
        }
    }
    if IsTrue(IsTrue(tail) && IsTrue(!IsEqual(limit, nil))) {
        return this.arraySlice(result, -limit)
    }
    return this.filterByLimit(result, limit, key, sinceIsDefined)
}
func  (this *Exchange) setSandboxMode(enabled bool)  {
    if IsTrue(enabled) {
        if IsTrue(InOp(this.urls, "test")) {
            if IsTrue(IsString(GetValue(this.urls, "api"))) {
                AddElementToObject(this.urls, "apiBackup", GetValue(this.urls, "api"))
                AddElementToObject(this.urls, "api", GetValue(this.urls, "test"))
            } else {
                AddElementToObject(this.urls, "apiBackup", this.clone(GetValue(this.urls, "api")))
                AddElementToObject(this.urls, "api", this.clone(GetValue(this.urls, "test")))
            }
        } else {
            panic(NotSupported(Add(this.id, " does not have a sandbox URL")))
        }
    } else if IsTrue(InOp(this.urls, "apiBackup")) {
        if IsTrue(IsString(GetValue(this.urls, "api"))) {
            AddElementToObject(this.urls, "api", GetValue(this.urls, "apiBackup"))
        } else {
            AddElementToObject(this.urls, "api", this.clone(GetValue(this.urls, "apiBackup")))
        }
        newUrls := this.omit(this.urls, "apiBackup")
        this.urls = newUrls
    }
}
func  (this *Exchange) sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 1, "public")
    _ = api
    method := GetArg(optionalArgs, 2, "GET")
    _ = method
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 4, nil)
    _ = headers
    body := GetArg(optionalArgs, 5, nil)
    _ = body
    return map[string]interface{} {}
}
func  (this *Exchange) fetchAccounts(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchAccounts() is not supported yet")))
}
func  (this *Exchange) fetchTrades(symbol string, optionalArgs ...interface{}) interface{}  {
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchTrades() is not supported yet")))
}
func  (this *Exchange) fetchTradesWs(symbol string, optionalArgs ...interface{}) interface{}  {
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchTradesWs() is not supported yet")))
}
func  (this *Exchange) watchLiquidations(symbol string, optionalArgs ...interface{}) interface{}  {
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "watchLiquidationsForSymbols")) {
        return this.watchLiquidationsForSymbols([]interface{}{symbol}, since, limit, params)
    }
    panic(NotSupported(Add(this.id, " watchLiquidations() is not supported yet")))
}
func  (this *Exchange) watchLiquidationsForSymbols(symbols interface{}, optionalArgs ...interface{}) interface{}  {
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchLiquidationsForSymbols() is not supported yet")))
}
func  (this *Exchange) watchMyLiquidations(symbol string, optionalArgs ...interface{}) interface{}  {
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "watchMyLiquidationsForSymbols")) {
        return this.watchMyLiquidationsForSymbols([]interface{}{symbol}, since, limit, params)
    }
    panic(NotSupported(Add(this.id, " watchMyLiquidations() is not supported yet")))
}
func  (this *Exchange) watchMyLiquidationsForSymbols(symbols interface{}, optionalArgs ...interface{}) interface{}  {
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchMyLiquidationsForSymbols() is not supported yet")))
}
func  (this *Exchange) watchTrades(symbol string, optionalArgs ...interface{}) interface{}  {
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchTrades() is not supported yet")))
}
func  (this *Exchange) watchTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) interface{}  {
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchTradesForSymbols() is not supported yet")))
}
func  (this *Exchange) watchMyTradesForSymbols(symbols interface{}, optionalArgs ...interface{}) interface{}  {
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchMyTradesForSymbols() is not supported yet")))
}
func  (this *Exchange) watchOrdersForSymbols(symbols interface{}, optionalArgs ...interface{}) interface{}  {
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchOrdersForSymbols() is not supported yet")))
}
func  (this *Exchange) watchOHLCVForSymbols(symbolsAndTimeframes interface{}, optionalArgs ...interface{}) interface{}  {
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchOHLCVForSymbols() is not supported yet")))
}
func  (this *Exchange) watchOrderBookForSymbols(symbols interface{}, optionalArgs ...interface{}) interface{}  {
    limit := GetArg(optionalArgs, 1, nil)
    _ = limit
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchOrderBookForSymbols() is not supported yet")))
}
func  (this *Exchange) fetchDepositAddresses(optionalArgs ...interface{}) interface{}  {
    codes := GetArg(optionalArgs, 0, nil)
    _ = codes
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchDepositAddresses() is not supported yet")))
}
func  (this *Exchange) fetchOrderBook(symbol string, optionalArgs ...interface{}) interface{}  {
    limit := GetArg(optionalArgs, 1, nil)
    _ = limit
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchOrderBook() is not supported yet")))
}
func  (this *Exchange) fetchMarginMode(symbol string, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchMarginModes")) {
        marginModes := this.fetchMarginModes([]interface{}{symbol}, params)
        return this.safeDict(marginModes, symbol)
    } else {
        panic(NotSupported(Add(this.id, " fetchMarginMode() is not supported yet")))
    }
}
func  (this *Exchange) fetchMarginModes(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchMarginModes () is not supported yet")))
}
func  (this *Exchange) fetchRestOrderBookSafe(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    limit := GetArg(optionalArgs, 1, nil)
    _ = limit
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    fetchSnapshotMaxRetries := this.handleOption("watchOrderBook", "maxRetries", 3)
    for i := 0; IsLessThan(i, fetchSnapshotMaxRetries); i++ {
        
        {		ret__ := func(this *Exchange) (ret_ interface{}) {
        		defer func() {
        			if e := recover().(interface{}); e != nil {
        				ret_ = func(this *Exchange) interface{} {
        					// catch block:
                                        if IsTrue(IsEqual((Add(i, 1)), fetchSnapshotMaxRetries)) {
                        panic(e)
                    }
        					return nil
        				}(this)
        			}
        		}()
        		// try block:
                            orderBook := this.fetchOrderBook(symbol, limit, params)
                    return orderBook
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
    }
    return nil
}
func  (this *Exchange) watchOrderBook(symbol string, optionalArgs ...interface{}) interface{}  {
    limit := GetArg(optionalArgs, 1, nil)
    _ = limit
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchOrderBook() is not supported yet")))
}
func  (this *Exchange) fetchTime(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchTime() is not supported yet")))
}
func  (this *Exchange) fetchTradingLimits(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchTradingLimits() is not supported yet")))
}
func  (this *Exchange) parseMarket(market interface{}) interface{}  {
    panic(NotSupported(Add(this.id, " parseMarket() is not supported yet")))
}
func  (this *Exchange) parseMarkets(markets interface{}) interface{}  {
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
        result = AppendToArray(result,this.parseMarket(GetValue(markets, i))).([]interface{})
    }
    return result
}
func  (this *Exchange) parseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseTicker() is not supported yet")))
}
func  (this *Exchange) parseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 1, nil)
    _ = currency
    panic(NotSupported(Add(this.id, " parseDepositAddress() is not supported yet")))
}
func  (this *Exchange) parseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseTrade() is not supported yet")))
}
func  (this *Exchange) parseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 1, nil)
    _ = currency
    panic(NotSupported(Add(this.id, " parseTransaction() is not supported yet")))
}
func  (this *Exchange) parseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 1, nil)
    _ = currency
    panic(NotSupported(Add(this.id, " parseTransfer() is not supported yet")))
}
func  (this *Exchange) parseAccount(account interface{}) interface{}  {
    panic(NotSupported(Add(this.id, " parseAccount() is not supported yet")))
}
func  (this *Exchange) parseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 1, nil)
    _ = currency
    panic(NotSupported(Add(this.id, " parseLedgerEntry() is not supported yet")))
}
func  (this *Exchange) parseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseOrder() is not supported yet")))
}
func  (this *Exchange) fetchCrossBorrowRates(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchCrossBorrowRates() is not supported yet")))
}
func  (this *Exchange) fetchIsolatedBorrowRates(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchIsolatedBorrowRates() is not supported yet")))
}
func  (this *Exchange) parseMarketLeverageTiers(info interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseMarketLeverageTiers() is not supported yet")))
}
func  (this *Exchange) fetchLeverageTiers(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchLeverageTiers() is not supported yet")))
}
func  (this *Exchange) parsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parsePosition() is not supported yet")))
}
func  (this *Exchange) parseFundingRateHistory(info interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseFundingRateHistory() is not supported yet")))
}
func  (this *Exchange) parseBorrowInterest(info interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseBorrowInterest() is not supported yet")))
}
func  (this *Exchange) parseIsolatedBorrowRate(info interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseIsolatedBorrowRate() is not supported yet")))
}
func  (this *Exchange) parseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseWsTrade() is not supported yet")))
}
func  (this *Exchange) parseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseWsOrder() is not supported yet")))
}
func  (this *Exchange) parseWsOrderTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseWsOrderTrade() is not supported yet")))
}
func  (this *Exchange) parseWsOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    return this.parseOHLCV(ohlcv, market)
}
func  (this *Exchange) fetchFundingRates(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchFundingRates() is not supported yet")))
}
func  (this *Exchange) watchFundingRate(symbol string, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchFundingRate() is not supported yet")))
}
func  (this *Exchange) watchFundingRates(symbols interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchFundingRates() is not supported yet")))
}
func  (this *Exchange) watchFundingRatesForSymbols(symbols interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    return this.watchFundingRates(symbols, params)
}
func  (this *Exchange) transfer(code string, amount interface{}, fromAccount string, toAccount string, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " transfer() is not supported yet")))
}
func  (this *Exchange) withdraw(code string, amount interface{}, address string, optionalArgs ...interface{}) interface{}  {
    tag := GetArg(optionalArgs, 3, nil)
    _ = tag
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " withdraw() is not supported yet")))
}
func  (this *Exchange) createDepositAddress(code string, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " createDepositAddress() is not supported yet")))
}
func  (this *Exchange) setLeverage(leverage interface{}, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " setLeverage() is not supported yet")))
}
func  (this *Exchange) fetchLeverage(symbol string, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchLeverages")) {
        leverages := this.fetchLeverages([]interface{}{symbol}, params)
        return this.safeDict(leverages, symbol)
    } else {
        panic(NotSupported(Add(this.id, " fetchLeverage() is not supported yet")))
    }
}
func  (this *Exchange) fetchLeverages(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchLeverages() is not supported yet")))
}
func  (this *Exchange) setPositionMode(hedged bool, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " setPositionMode() is not supported yet")))
}
func  (this *Exchange) addMargin(symbol string, amount interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " addMargin() is not supported yet")))
}
func  (this *Exchange) reduceMargin(symbol string, amount interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " reduceMargin() is not supported yet")))
}
func  (this *Exchange) setMargin(symbol string, amount interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " setMargin() is not supported yet")))
}
func  (this *Exchange) fetchMarginAdjustmentHistory(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    typeVar := GetArg(optionalArgs, 1, nil)
    _ = typeVar
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchMarginAdjustmentHistory() is not supported yet")))
}
func  (this *Exchange) setMarginMode(marginMode string, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " setMarginMode() is not supported yet")))
}
func  (this *Exchange) fetchDepositAddressesByNetwork(code string, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchDepositAddressesByNetwork() is not supported yet")))
}
func  (this *Exchange) fetchOpenInterestHistory(symbol string, optionalArgs ...interface{}) interface{}  {
    timeframe := GetArg(optionalArgs, 1, "1h")
    _ = timeframe
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchOpenInterestHistory() is not supported yet")))
}
func  (this *Exchange) fetchOpenInterest(symbol string, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchOpenInterest() is not supported yet")))
}
func  (this *Exchange) signIn(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " signIn() is not supported yet")))
}
func  (this *Exchange) fetchPaymentMethods(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchPaymentMethods() is not supported yet")))
}
func  (this *Exchange) parseToInt(number interface{}) interface{}  {
    // Solve Common parseInt misuse ex: parseInt ((since / 1000).toString ())
    // using a number as parameter which is not valid in ts
    stringifiedNumber := this.numberToString(number)
    convertedNumber := parseFloat(stringifiedNumber)
    return parseInt(convertedNumber)
}
func  (this *Exchange) parseToNumeric(number interface{}) interface{}  {
    stringVersion := this.numberToString(number) // this will convert 1.0 and 1 to "1" and 1.1 to "1.1"
    // keep this in mind:
    // in JS: 1 == 1.0 is true;  1 === 1.0 is true
    // in Python: 1 == 1.0 is true
    // in PHP 1 == 1.0 is true, but 1 === 1.0 is false
    if IsTrue(IsGreaterThanOrEqual(GetIndexOf(stringVersion, "."), 0)) {
        return parseFloat(stringVersion)
    }
    return parseInt(stringVersion)
}
func  (this *Exchange) isRoundNumber(value interface{}) interface{}  {
    // this method is similar to isInteger, but this is more loyal and does not check for types.
    // i.e. isRoundNumber(1.000) returns true, while isInteger(1.000) returns false
    res := this.parseToNumeric((Mod(value, 1)))
    return IsEqual(res, 0)
}
func  (this *Exchange) safeIntegerOmitZero(obj interface{}, key interface{}, optionalArgs ...interface{}) interface{}  {
    defaultValue := GetArg(optionalArgs, 2, nil)
    _ = defaultValue
    timestamp := this.safeInteger(obj, key, defaultValue)
    if IsTrue(IsTrue(IsEqual(timestamp, nil)) || IsTrue(IsEqual(timestamp, 0))) {
        return nil
    }
    return timestamp
}
func  (this *Exchange) afterConstruct()  {
    this.createNetworksByIdObject()
}
func  (this *Exchange) createNetworksByIdObject()  {
    // automatically generate network-id-to-code mappings
    networkIdsToCodesGenerated := this.invertFlatStringDictionary(this.safeValue(this.options, "networks", map[string]interface{} {})) // invert defined networks dictionary
    AddElementToObject(this.options, "networksById", this.extend(networkIdsToCodesGenerated, this.safeValue(this.options, "networksById", map[string]interface{} {}))) // support manually overriden "networksById" dictionary too
}
func  (this *Exchange) getDefaultOptions() interface{}  {
    return map[string]interface{} {
        "defaultNetworkCodeReplacements": map[string]interface{} {
            "ETH": map[string]interface{} {
                "ERC20": "ETH",
            },
            "TRX": map[string]interface{} {
                "TRC20": "TRX",
            },
            "CRO": map[string]interface{} {
                "CRC20": "CRONOS",
            },
        },
    }
}
func  (this *Exchange) safeLedgerEntry(entry interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 1, nil)
    _ = currency
    currency = this.safeCurrency(nil, currency)
    direction := this.safeString(entry, "direction")
    before := this.safeString(entry, "before")
    after := this.safeString(entry, "after")
    amount := this.safeString(entry, "amount")
    if IsTrue(!IsEqual(amount, nil)) {
        if IsTrue(IsTrue(IsEqual(before, nil)) && IsTrue(!IsEqual(after, nil))) {
            before = Precise.stringSub(after, amount)
        } else if IsTrue(IsTrue(!IsEqual(before, nil)) && IsTrue(IsEqual(after, nil))) {
            after = Precise.stringAdd(before, amount)
        }
    }
    if IsTrue(IsTrue(!IsEqual(before, nil)) && IsTrue(!IsEqual(after, nil))) {
        if IsTrue(IsEqual(direction, nil)) {
            if IsTrue(Precise.stringGt(before, after)) {
                direction = "out"
            }
            if IsTrue(Precise.stringGt(after, before)) {
                direction = "in"
            }
        }
    }
    fee := this.safeValue(entry, "fee")
    if IsTrue(!IsEqual(fee, nil)) {
        AddElementToObject(fee, "cost", this.safeNumber(fee, "cost"))
    }
    timestamp := this.safeInteger(entry, "timestamp")
    info := this.safeDict(entry, "info", map[string]interface{} {})
    return map[string]interface{} {
        "id": this.safeString(entry, "id"),
        "timestamp": timestamp,
        "datetime": this.iso8601(timestamp),
        "direction": direction,
        "account": this.safeString(entry, "account"),
        "referenceId": this.safeString(entry, "referenceId"),
        "referenceAccount": this.safeString(entry, "referenceAccount"),
        "type": this.safeString(entry, "type"),
        "currency": GetValue(currency, "code"),
        "amount": this.parseNumber(amount),
        "before": this.parseNumber(before),
        "after": this.parseNumber(after),
        "status": this.safeString(entry, "status"),
        "fee": fee,
        "info": info,
    }
}
func  (this *Exchange) safeCurrencyStructure(currency interface{}) interface{}  {
    return this.extend(map[string]interface{} {
        "info": nil,
        "id": nil,
        "numericId": nil,
        "code": nil,
        "precision": nil,
        "type": nil,
        "name": nil,
        "active": nil,
        "deposit": nil,
        "withdraw": nil,
        "fee": nil,
        "fees": map[string]interface{} {},
        "networks": map[string]interface{} {},
        "limits": map[string]interface{} {
            "deposit": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "withdraw": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
    }, currency)
}
func  (this *Exchange) safeMarketStructure(optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    cleanStructure := map[string]interface{} {
        "id": nil,
        "lowercaseId": nil,
        "symbol": nil,
        "base": nil,
        "quote": nil,
        "settle": nil,
        "baseId": nil,
        "quoteId": nil,
        "settleId": nil,
        "type": nil,
        "spot": nil,
        "margin": nil,
        "swap": nil,
        "future": nil,
        "option": nil,
        "index": nil,
        "active": nil,
        "contract": nil,
        "linear": nil,
        "inverse": nil,
        "subType": nil,
        "taker": nil,
        "maker": nil,
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": nil,
            "price": nil,
            "cost": nil,
            "base": nil,
            "quote": nil,
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "created": nil,
        "info": nil,
    }
    if IsTrue(!IsEqual(market, nil)) {
        result := this.extend(cleanStructure, market)
        // set undefined swap/future/etc
        if IsTrue(GetValue(result, "spot")) {
            if IsTrue(IsEqual(GetValue(result, "contract"), nil)) {
                AddElementToObject(result, "contract", false)
            }
            if IsTrue(IsEqual(GetValue(result, "swap"), nil)) {
                AddElementToObject(result, "swap", false)
            }
            if IsTrue(IsEqual(GetValue(result, "future"), nil)) {
                AddElementToObject(result, "future", false)
            }
            if IsTrue(IsEqual(GetValue(result, "option"), nil)) {
                AddElementToObject(result, "option", false)
            }
            if IsTrue(IsEqual(GetValue(result, "index"), nil)) {
                AddElementToObject(result, "index", false)
            }
        }
        return result
    }
    return cleanStructure
}
func  (this *Exchange) setMarkets(markets interface{}, optionalArgs ...interface{}) interface{}  {
    currencies := GetArg(optionalArgs, 1, nil)
    _ = currencies
    values := []interface{}{}
    this.markets_by_id = map[string]interface{} {}
    // handle marketId conflicts
    // we insert spot markets first
    marketValues := this.sortBy(this.toArray(markets), "spot", true, true)
    for i := 0; IsLessThan(i, GetArrayLength(marketValues)); i++ {
        value := GetValue(marketValues, i)
        if IsTrue(InOp(this.markets_by_id, GetValue(value, "id"))) {
            GetValue(this.markets_by_id, GetValue(value, "id")) = AppendToArray(GetValue(this.markets_by_id, GetValue(value, "id")),value).([]interface{})
        } else {
            AddElementToObject(this.markets_by_id, GetValue(value, "id"), []interface{}{value})
        }
        market := this.deepExtend(this.safeMarketStructure(), map[string]interface{} {
            "precision": this.precision,
            "limits": this.limits,
        }, GetValue(this.fees, "trading"), value)
        if IsTrue(GetValue(market, "linear")) {
            AddElementToObject(market, "subType", "linear")
        } else if IsTrue(GetValue(market, "inverse")) {
            AddElementToObject(market, "subType", "inverse")
        } else {
            AddElementToObject(market, "subType", nil)
        }
        values = AppendToArray(values,market).([]interface{})
    }
    this.markets = this.indexBy(values, "symbol")
    marketsSortedBySymbol := this.keysort(this.markets)
    marketsSortedById := this.keysort(this.markets_by_id)
    this.symbols = ObjectKeys(marketsSortedBySymbol)
    this.ids = ObjectKeys(marketsSortedById)
    if IsTrue(!IsEqual(currencies, nil)) {
        // currencies is always undefined when called in constructor but not when called from loadMarkets
        this.currencies = this.deepExtend(this.currencies, currencies)
    } else {
        baseCurrencies := []interface{}{}
        quoteCurrencies := []interface{}{}
        for i := 0; IsLessThan(i, GetArrayLength(values)); i++ {
            market := GetValue(values, i)
            defaultCurrencyPrecision := Ternary(IsTrue((IsEqual(this.precisionMode, DECIMAL_PLACES))), 8, this.parseNumber("1e-8"))
            marketPrecision := this.safeDict(market, "precision", map[string]interface{} {})
            if IsTrue(InOp(market, "base")) {
                currency := this.safeCurrencyStructure(map[string]interface{} {
                    "id": this.safeString2(market, "baseId", "base"),
                    "numericId": this.safeInteger(market, "baseNumericId"),
                    "code": this.safeString(market, "base"),
                    "precision": this.safeValue2(marketPrecision, "base", "amount", defaultCurrencyPrecision),
                })
                baseCurrencies = AppendToArray(baseCurrencies,currency).([]interface{})
            }
            if IsTrue(InOp(market, "quote")) {
                currency := this.safeCurrencyStructure(map[string]interface{} {
                    "id": this.safeString2(market, "quoteId", "quote"),
                    "numericId": this.safeInteger(market, "quoteNumericId"),
                    "code": this.safeString(market, "quote"),
                    "precision": this.safeValue2(marketPrecision, "quote", "price", defaultCurrencyPrecision),
                })
                quoteCurrencies = AppendToArray(quoteCurrencies,currency).([]interface{})
            }
        }
        baseCurrencies = this.sortBy(baseCurrencies, "code", false, "")
        quoteCurrencies = this.sortBy(quoteCurrencies, "code", false, "")
        this.baseCurrencies = this.indexBy(baseCurrencies, "code")
        this.quoteCurrencies = this.indexBy(quoteCurrencies, "code")
        allCurrencies := this.arrayConcat(baseCurrencies, quoteCurrencies)
        groupedCurrencies := this.groupBy(allCurrencies, "code")
        codes := ObjectKeys(groupedCurrencies)
        resultingCurrencies := []interface{}{}
        for i := 0; IsLessThan(i, GetArrayLength(codes)); i++ {
            code := GetValue(codes, i)
            groupedCurrenciesCode := this.safeList(groupedCurrencies, code, []interface{}{})
            highestPrecisionCurrency := this.safeValue(groupedCurrenciesCode, 0)
            for j := 1; IsLessThan(j, GetArrayLength(groupedCurrenciesCode)); j++ {
                currentCurrency := GetValue(groupedCurrenciesCode, j)
                if IsTrue(IsEqual(this.precisionMode, TICK_SIZE)) {
                    highestPrecisionCurrency = Ternary(IsTrue((IsLessThan(GetValue(currentCurrency, "precision"), GetValue(highestPrecisionCurrency, "precision")))), currentCurrency, highestPrecisionCurrency)
                } else {
                    highestPrecisionCurrency = Ternary(IsTrue((IsGreaterThan(GetValue(currentCurrency, "precision"), GetValue(highestPrecisionCurrency, "precision")))), currentCurrency, highestPrecisionCurrency)
                }
            }
            resultingCurrencies = AppendToArray(resultingCurrencies,highestPrecisionCurrency).([]interface{})
        }
        sortedCurrencies := this.sortBy(resultingCurrencies, "code")
        this.currencies = this.deepExtend(this.currencies, this.indexBy(sortedCurrencies, "code"))
    }
    this.currencies_by_id = this.indexBy(this.currencies, "id")
    currenciesSortedByCode := this.keysort(this.currencies)
    this.codes = ObjectKeys(currenciesSortedByCode)
    return this.markets
}
func  (this *Exchange) getDescribeForExtendedWsExchange(currentRestInstance interface{}, parentRestInstance interface{}, wsBaseDescribe interface{}) interface{}  {
    extendedRestDescribe := this.deepExtend(parentRestInstance.describe(), currentRestInstance.describe())
    superWithRestDescribe := this.deepExtend(extendedRestDescribe, wsBaseDescribe)
    return superWithRestDescribe
}
func  (this *Exchange) safeBalance(balance interface{}) interface{}  {
    balances := this.omit(balance, []interface{}{"info", "timestamp", "datetime", "free", "used", "total"})
    codes := ObjectKeys(balances)
    AddElementToObject(balance, "free", map[string]interface{} {})
    AddElementToObject(balance, "used", map[string]interface{} {})
    AddElementToObject(balance, "total", map[string]interface{} {})
    debtBalance := map[string]interface{} {}
    for i := 0; IsLessThan(i, GetArrayLength(codes)); i++ {
        code := GetValue(codes, i)
        total := this.safeString(GetValue(balance, code), "total")
        free := this.safeString(GetValue(balance, code), "free")
        used := this.safeString(GetValue(balance, code), "used")
        debt := this.safeString(GetValue(balance, code), "debt")
        if IsTrue(IsTrue(IsTrue((IsEqual(total, nil))) && IsTrue((!IsEqual(free, nil)))) && IsTrue((!IsEqual(used, nil)))) {
            total = Precise.stringAdd(free, used)
        }
        if IsTrue(IsTrue(IsTrue((IsEqual(free, nil))) && IsTrue((!IsEqual(total, nil)))) && IsTrue((!IsEqual(used, nil)))) {
            free = Precise.stringSub(total, used)
        }
        if IsTrue(IsTrue(IsTrue((IsEqual(used, nil))) && IsTrue((!IsEqual(total, nil)))) && IsTrue((!IsEqual(free, nil)))) {
            used = Precise.stringSub(total, free)
        }
        AddElementToObject(GetValue(balance, code), "free", this.parseNumber(free))
        AddElementToObject(GetValue(balance, code), "used", this.parseNumber(used))
        AddElementToObject(GetValue(balance, code), "total", this.parseNumber(total))
        AddElementToObject(GetValue(balance, "free"), code, GetValue(GetValue(balance, code), "free"))
        AddElementToObject(GetValue(balance, "used"), code, GetValue(GetValue(balance, code), "used"))
        AddElementToObject(GetValue(balance, "total"), code, GetValue(GetValue(balance, code), "total"))
        if IsTrue(!IsEqual(debt, nil)) {
            AddElementToObject(GetValue(balance, code), "debt", this.parseNumber(debt))
            AddElementToObject(debtBalance, code, GetValue(GetValue(balance, code), "debt"))
        }
    }
    debtBalanceArray := ObjectKeys(debtBalance)
    length := GetArrayLength(debtBalanceArray)
    if IsTrue(length) {
        AddElementToObject(balance, "debt", debtBalance)
    }
    return balance
}
func  (this *Exchange) safeOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    // parses numbers as strings
    // * it is important pass the trades as unparsed rawTrades
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    amount := this.omitZero(this.safeString(order, "amount"))
    remaining := this.safeString(order, "remaining")
    filled := this.safeString(order, "filled")
    cost := this.safeString(order, "cost")
    average := this.omitZero(this.safeString(order, "average"))
    price := this.omitZero(this.safeString(order, "price"))
    lastTradeTimeTimestamp := this.safeInteger(order, "lastTradeTimestamp")
    symbol := this.safeString(order, "symbol")
    side := this.safeString(order, "side")
    status := this.safeString(order, "status")
    parseFilled := (IsEqual(filled, nil))
    parseCost := (IsEqual(cost, nil))
    parseLastTradeTimeTimestamp := (IsEqual(lastTradeTimeTimestamp, nil))
    fee := this.safeValue(order, "fee")
    parseFee := (IsEqual(fee, nil))
    parseFees := IsEqual(this.safeValue(order, "fees"), nil)
    parseSymbol := IsEqual(symbol, nil)
    parseSide := IsEqual(side, nil)
    shouldParseFees := IsTrue(parseFee) || IsTrue(parseFees)
    fees := this.safeList(order, "fees", []interface{}{})
    trades := []interface{}{}
    isTriggerOrSLTpOrder := (IsTrue((IsTrue(!IsEqual(this.safeString(order, "triggerPrice"), nil)) || IsTrue((!IsEqual(this.safeString(order, "stopLossPrice"), nil))))) || IsTrue((!IsEqual(this.safeString(order, "takeProfitPrice"), nil))))
    if IsTrue(IsTrue(IsTrue(parseFilled) || IsTrue(parseCost)) || IsTrue(shouldParseFees)) {
        rawTrades := this.safeValue(order, "trades", trades)
        oldNumber := this.number
        // we parse trades as strings here!
        this.number = String
        firstTrade := this.safeValue(rawTrades, 0)
        // parse trades if they haven't already been parsed
        tradesAreParsed := (IsTrue(IsTrue((!IsEqual(firstTrade, nil))) && IsTrue((InOp(firstTrade, "info")))) && IsTrue((InOp(firstTrade, "id"))))
        if !IsTrue(tradesAreParsed) {
            trades = this.parseTrades(rawTrades, market)
        } else {
            trades = rawTrades
        }
        this.number = oldNumber
        tradesLength := 0
        isArray := IsArray(trades)
        if IsTrue(isArray) {
            tradesLength = GetArrayLength(trades)
        }
        if IsTrue(IsTrue(isArray) && IsTrue((IsGreaterThan(tradesLength, 0)))) {
            // move properties that are defined in trades up into the order
            if IsTrue(IsEqual(GetValue(order, "symbol"), nil)) {
                AddElementToObject(order, "symbol", GetValue(GetValue(trades, 0), "symbol"))
            }
            if IsTrue(IsEqual(GetValue(order, "side"), nil)) {
                AddElementToObject(order, "side", GetValue(GetValue(trades, 0), "side"))
            }
            if IsTrue(IsEqual(GetValue(order, "type"), nil)) {
                AddElementToObject(order, "type", GetValue(GetValue(trades, 0), "type"))
            }
            if IsTrue(IsEqual(GetValue(order, "id"), nil)) {
                AddElementToObject(order, "id", GetValue(GetValue(trades, 0), "order"))
            }
            if IsTrue(parseFilled) {
                filled = "0"
            }
            if IsTrue(parseCost) {
                cost = "0"
            }
            for i := 0; IsLessThan(i, GetArrayLength(trades)); i++ {
                trade := GetValue(trades, i)
                tradeAmount := this.safeString(trade, "amount")
                if IsTrue(IsTrue(parseFilled) && IsTrue((!IsEqual(tradeAmount, nil)))) {
                    filled = Precise.stringAdd(filled, tradeAmount)
                }
                tradeCost := this.safeString(trade, "cost")
                if IsTrue(IsTrue(parseCost) && IsTrue((!IsEqual(tradeCost, nil)))) {
                    cost = Precise.stringAdd(cost, tradeCost)
                }
                if IsTrue(parseSymbol) {
                    symbol = this.safeString(trade, "symbol")
                }
                if IsTrue(parseSide) {
                    side = this.safeString(trade, "side")
                }
                tradeTimestamp := this.safeValue(trade, "timestamp")
                if IsTrue(IsTrue(parseLastTradeTimeTimestamp) && IsTrue((!IsEqual(tradeTimestamp, nil)))) {
                    if IsTrue(IsEqual(lastTradeTimeTimestamp, nil)) {
                        lastTradeTimeTimestamp = tradeTimestamp
                    } else {
                        lastTradeTimeTimestamp = mathMax(lastTradeTimeTimestamp, tradeTimestamp)
                    }
                }
                if IsTrue(shouldParseFees) {
                    tradeFees := this.safeValue(trade, "fees")
                    if IsTrue(!IsEqual(tradeFees, nil)) {
                        for j := 0; IsLessThan(j, GetArrayLength(tradeFees)); j++ {
                            tradeFee := GetValue(tradeFees, j)
                            fees = AppendToArray(fees,this.extend(map[string]interface{} {}, tradeFee)).([]interface{})
                        }
                    } else {
                        tradeFee := this.safeValue(trade, "fee")
                        if IsTrue(!IsEqual(tradeFee, nil)) {
                            fees = AppendToArray(fees,this.extend(map[string]interface{} {}, tradeFee)).([]interface{})
                        }
                    }
                }
            }
        }
    }
    if IsTrue(shouldParseFees) {
        reducedFees := Ternary(IsTrue(this.reduceFees), this.reduceFeesByCurrency(fees), fees)
        reducedLength := GetArrayLength(reducedFees)
        for i := 0; IsLessThan(i, reducedLength); i++ {
            AddElementToObject(GetValue(reducedFees, i), "cost", this.safeNumber(GetValue(reducedFees, i), "cost"))
            if IsTrue(InOp(GetValue(reducedFees, i), "rate")) {
                AddElementToObject(GetValue(reducedFees, i), "rate", this.safeNumber(GetValue(reducedFees, i), "rate"))
            }
        }
        if IsTrue(!IsTrue(parseFee) && IsTrue((IsEqual(reducedLength, 0)))) {
            // copy fee to avoid modification by reference
            feeCopy := this.deepExtend(fee)
            AddElementToObject(feeCopy, "cost", this.safeNumber(feeCopy, "cost"))
            if IsTrue(InOp(feeCopy, "rate")) {
                AddElementToObject(feeCopy, "rate", this.safeNumber(feeCopy, "rate"))
            }
            reducedFees = AppendToArray(reducedFees,feeCopy).([]interface{})
        }
        AddElementToObject(order, "fees", reducedFees)
        if IsTrue(IsTrue(parseFee) && IsTrue((IsEqual(reducedLength, 1)))) {
            AddElementToObject(order, "fee", GetValue(reducedFees, 0))
        }
    }
    if IsTrue(IsEqual(amount, nil)) {
        // ensure amount = filled + remaining
        if IsTrue(IsTrue(!IsEqual(filled, nil)) && IsTrue(!IsEqual(remaining, nil))) {
            amount = Precise.stringAdd(filled, remaining)
        } else if IsTrue(IsEqual(status, "closed")) {
            amount = filled
        }
    }
    if IsTrue(IsEqual(filled, nil)) {
        if IsTrue(IsTrue(!IsEqual(amount, nil)) && IsTrue(!IsEqual(remaining, nil))) {
            filled = Precise.stringSub(amount, remaining)
        } else if IsTrue(IsTrue(IsEqual(status, "closed")) && IsTrue(!IsEqual(amount, nil))) {
            filled = amount
        }
    }
    if IsTrue(IsEqual(remaining, nil)) {
        if IsTrue(IsTrue(!IsEqual(amount, nil)) && IsTrue(!IsEqual(filled, nil))) {
            remaining = Precise.stringSub(amount, filled)
        } else if IsTrue(IsEqual(status, "closed")) {
            remaining = "0"
        }
    }
    // ensure that the average field is calculated correctly
    inverse := this.safeBool(market, "inverse", false)
    contractSize := this.numberToString(this.safeValue(market, "contractSize", 1))
    // inverse
    // price = filled * contract size / cost
    //
    // linear
    // price = cost / (filled * contract size)
    if IsTrue(IsEqual(average, nil)) {
        if IsTrue(IsTrue(IsTrue((!IsEqual(filled, nil))) && IsTrue((!IsEqual(cost, nil)))) && IsTrue(Precise.stringGt(filled, "0"))) {
            filledTimesContractSize := Precise.stringMul(filled, contractSize)
            if IsTrue(inverse) {
                average = Precise.stringDiv(filledTimesContractSize, cost)
            } else {
                average = Precise.stringDiv(cost, filledTimesContractSize)
            }
        }
    }
    // similarly
    // inverse
    // cost = filled * contract size / price
    //
    // linear
    // cost = filled * contract size * price
    costPriceExists := IsTrue((!IsEqual(average, nil))) || IsTrue((!IsEqual(price, nil)))
    if IsTrue(IsTrue(IsTrue(parseCost) && IsTrue((!IsEqual(filled, nil)))) && IsTrue(costPriceExists)) {
        var multiplyPrice interface{} = nil
        if IsTrue(IsEqual(average, nil)) {
            multiplyPrice = price
        } else {
            multiplyPrice = average
        }
        // contract trading
        filledTimesContractSize := Precise.stringMul(filled, contractSize)
        if IsTrue(inverse) {
            cost = Precise.stringDiv(filledTimesContractSize, multiplyPrice)
        } else {
            cost = Precise.stringMul(filledTimesContractSize, multiplyPrice)
        }
    }
    // support for market orders
    orderType := this.safeValue(order, "type")
    emptyPrice := IsTrue((IsEqual(price, nil))) || IsTrue(Precise.stringEquals(price, "0"))
    if IsTrue(IsTrue(emptyPrice) && IsTrue((IsEqual(orderType, "market")))) {
        price = average
    }
    // we have trades with string values at this point so we will mutate them
    for i := 0; IsLessThan(i, GetArrayLength(trades)); i++ {
        entry := GetValue(trades, i)
        AddElementToObject(entry, "amount", this.safeNumber(entry, "amount"))
        AddElementToObject(entry, "price", this.safeNumber(entry, "price"))
        AddElementToObject(entry, "cost", this.safeNumber(entry, "cost"))
        tradeFee := this.safeDict(entry, "fee", map[string]interface{} {})
        AddElementToObject(tradeFee, "cost", this.safeNumber(tradeFee, "cost"))
        if IsTrue(InOp(tradeFee, "rate")) {
            AddElementToObject(tradeFee, "rate", this.safeNumber(tradeFee, "rate"))
        }
        entryFees := this.safeList(entry, "fees", []interface{}{})
        for j := 0; IsLessThan(j, GetArrayLength(entryFees)); j++ {
            AddElementToObject(GetValue(entryFees, j), "cost", this.safeNumber(GetValue(entryFees, j), "cost"))
        }
        AddElementToObject(entry, "fees", entryFees)
        AddElementToObject(entry, "fee", tradeFee)
    }
    timeInForce := this.safeString(order, "timeInForce")
    postOnly := this.safeValue(order, "postOnly")
    // timeInForceHandling
    if IsTrue(IsEqual(timeInForce, nil)) {
        if IsTrue(!IsTrue(isTriggerOrSLTpOrder) && IsTrue((IsEqual(this.safeString(order, "type"), "market")))) {
            timeInForce = "IOC"
        }
        // allow postOnly override
        if IsTrue(postOnly) {
            timeInForce = "PO"
        }
    } else if IsTrue(IsEqual(postOnly, nil)) {
        // timeInForce is not undefined here
        postOnly = IsEqual(timeInForce, "PO")
    }
    timestamp := this.safeInteger(order, "timestamp")
    lastUpdateTimestamp := this.safeInteger(order, "lastUpdateTimestamp")
    datetime := this.safeString(order, "datetime")
    if IsTrue(IsEqual(datetime, nil)) {
        datetime = this.iso8601(timestamp)
    }
    triggerPrice := this.parseNumber(this.safeString2(order, "triggerPrice", "stopPrice"))
    takeProfitPrice := this.parseNumber(this.safeString(order, "takeProfitPrice"))
    stopLossPrice := this.parseNumber(this.safeString(order, "stopLossPrice"))
    return this.extend(order, map[string]interface{} {
        "id": this.safeString(order, "id"),
        "clientOrderId": this.safeString(order, "clientOrderId"),
        "timestamp": timestamp,
        "datetime": datetime,
        "symbol": symbol,
        "type": this.safeString(order, "type"),
        "side": side,
        "lastTradeTimestamp": lastTradeTimeTimestamp,
        "lastUpdateTimestamp": lastUpdateTimestamp,
        "price": this.parseNumber(price),
        "amount": this.parseNumber(amount),
        "cost": this.parseNumber(cost),
        "average": this.parseNumber(average),
        "filled": this.parseNumber(filled),
        "remaining": this.parseNumber(remaining),
        "timeInForce": timeInForce,
        "postOnly": postOnly,
        "trades": trades,
        "reduceOnly": this.safeValue(order, "reduceOnly"),
        "stopPrice": triggerPrice,
        "triggerPrice": triggerPrice,
        "takeProfitPrice": takeProfitPrice,
        "stopLossPrice": stopLossPrice,
        "status": status,
        "fee": this.safeValue(order, "fee"),
    })
}
func  (this *Exchange) parseOrders(orders interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // the value of orders is either a dict or a list
    //
    // dict
    //
    //     {
    //         'id1': { ... },
    //         'id2': { ... },
    //         'id3': { ... },
    //         ...
    //     }
    //
    // list
    //
    //     [
    //         { 'id': 'id1', ... },
    //         { 'id': 'id2', ... },
    //         { 'id': 'id3', ... },
    //         ...
    //     ]
    //
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    results := []interface{}{}
    if IsTrue(IsArray(orders)) {
        for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
            order := this.extend(this.parseOrder(GetValue(orders, i), market), params)
            results = AppendToArray(results,order).([]interface{})
        }
    } else {
        ids := ObjectKeys(orders)
        for i := 0; IsLessThan(i, GetArrayLength(ids)); i++ {
            id := GetValue(ids, i)
            order := this.extend(this.parseOrder(this.extend(map[string]interface{} {
                "id": id,
            }, GetValue(orders, id)), market), params)
            results = AppendToArray(results,order).([]interface{})
        }
    }
    results = this.sortBy(results, "timestamp")
    symbol := Ternary(IsTrue((!IsEqual(market, nil))), GetValue(market, "symbol"), nil)
    return this.filterBySymbolSinceLimit(results, symbol, since, limit)
}
func  (this *Exchange) calculateFee(symbol string, typeVar string, side string, amount interface{}, price interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @description calculates the presumptive fee that would be charged for an order
    * @param {string} symbol unified market symbol
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade, in units of the base currency on most exchanges, or number of contracts
    * @param {float} price the price for the order to be filled at, in units of the quote currency
    * @param {string} takerOrMaker 'taker' or 'maker'
    * @param {object} params
    * @returns {object} contains the rate, the percentage multiplied to the order amount to obtain the fee amount, and cost, the total value of the fee in units of the quote currency, for the order
    */
    takerOrMaker := GetArg(optionalArgs, 5, "taker")
    _ = takerOrMaker
    params := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = params
    if IsTrue(IsTrue(IsEqual(typeVar, "market")) && IsTrue(IsEqual(takerOrMaker, "maker"))) {
        panic(ArgumentsRequired(Add(this.id, " calculateFee() - you have provided incompatible arguments - \"market\" type order can not be \"maker\". Change either the \"type\" or the \"takerOrMaker\" argument to calculate the fee.")))
    }
    market := GetValue(this.markets, symbol)
    feeSide := this.safeString(market, "feeSide", "quote")
    var useQuote interface{} = nil
    if IsTrue(IsEqual(feeSide, "get")) {
        // the fee is always in the currency you get
        useQuote = IsEqual(side, "sell")
    } else if IsTrue(IsEqual(feeSide, "give")) {
        // the fee is always in the currency you give
        useQuote = IsEqual(side, "buy")
    } else {
        // the fee is always in feeSide currency
        useQuote = IsEqual(feeSide, "quote")
    }
    cost := this.numberToString(amount)
    var key interface{} = nil
    if IsTrue(useQuote) {
        priceString := this.numberToString(price)
        cost = Precise.stringMul(cost, priceString)
        key = "quote"
    } else {
        key = "base"
    }
    // for derivatives, the fee is in 'settle' currency
    if !IsTrue(GetValue(market, "spot")) {
        key = "settle"
    }
    // even if `takerOrMaker` argument was set to 'maker', for 'market' orders we should forcefully override it to 'taker'
    if IsTrue(IsEqual(typeVar, "market")) {
        takerOrMaker = "taker"
    }
    rate := this.safeString(market, takerOrMaker)
    cost = Precise.stringMul(cost, rate)
    return map[string]interface{} {
        "type": takerOrMaker,
        "currency": GetValue(market, key),
        "rate": this.parseNumber(rate),
        "cost": this.parseNumber(cost),
    }
}
func  (this *Exchange) safeLiquidation(liquidation interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    contracts := this.safeString(liquidation, "contracts")
    contractSize := this.safeString(market, "contractSize")
    price := this.safeString(liquidation, "price")
    baseValue := this.safeString(liquidation, "baseValue")
    quoteValue := this.safeString(liquidation, "quoteValue")
    if IsTrue(IsTrue(IsTrue(IsTrue((IsEqual(baseValue, nil))) && IsTrue((!IsEqual(contracts, nil)))) && IsTrue((!IsEqual(contractSize, nil)))) && IsTrue((!IsEqual(price, nil)))) {
        baseValue = Precise.stringMul(contracts, contractSize)
    }
    if IsTrue(IsTrue(IsTrue((IsEqual(quoteValue, nil))) && IsTrue((!IsEqual(baseValue, nil)))) && IsTrue((!IsEqual(price, nil)))) {
        quoteValue = Precise.stringMul(baseValue, price)
    }
    AddElementToObject(liquidation, "contracts", this.parseNumber(contracts))
    AddElementToObject(liquidation, "contractSize", this.parseNumber(contractSize))
    AddElementToObject(liquidation, "price", this.parseNumber(price))
    AddElementToObject(liquidation, "baseValue", this.parseNumber(baseValue))
    AddElementToObject(liquidation, "quoteValue", this.parseNumber(quoteValue))
    return liquidation
}
func  (this *Exchange) safeTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    amount := this.safeString(trade, "amount")
    price := this.safeString(trade, "price")
    cost := this.safeString(trade, "cost")
    if IsTrue(IsEqual(cost, nil)) {
        // contract trading
        contractSize := this.safeString(market, "contractSize")
        multiplyPrice := price
        if IsTrue(!IsEqual(contractSize, nil)) {
            inverse := this.safeBool(market, "inverse", false)
            if IsTrue(inverse) {
                multiplyPrice = Precise.stringDiv("1", price)
            }
            multiplyPrice = Precise.stringMul(multiplyPrice, contractSize)
        }
        cost = Precise.stringMul(multiplyPrice, amount)
    }
    parseFee := IsEqual(this.safeValue(trade, "fee"), nil)
    parseFees := IsEqual(this.safeValue(trade, "fees"), nil)
    shouldParseFees := IsTrue(parseFee) || IsTrue(parseFees)
    fees := []interface{}{}
    fee := this.safeValue(trade, "fee")
    if IsTrue(shouldParseFees) {
        reducedFees := Ternary(IsTrue(this.reduceFees), this.reduceFeesByCurrency(fees), fees)
        reducedLength := GetArrayLength(reducedFees)
        for i := 0; IsLessThan(i, reducedLength); i++ {
            AddElementToObject(GetValue(reducedFees, i), "cost", this.safeNumber(GetValue(reducedFees, i), "cost"))
            if IsTrue(InOp(GetValue(reducedFees, i), "rate")) {
                AddElementToObject(GetValue(reducedFees, i), "rate", this.safeNumber(GetValue(reducedFees, i), "rate"))
            }
        }
        if IsTrue(!IsTrue(parseFee) && IsTrue((IsEqual(reducedLength, 0)))) {
            // copy fee to avoid modification by reference
            feeCopy := this.deepExtend(fee)
            AddElementToObject(feeCopy, "cost", this.safeNumber(feeCopy, "cost"))
            if IsTrue(InOp(feeCopy, "rate")) {
                AddElementToObject(feeCopy, "rate", this.safeNumber(feeCopy, "rate"))
            }
            reducedFees = AppendToArray(reducedFees,feeCopy).([]interface{})
        }
        if IsTrue(parseFees) {
            AddElementToObject(trade, "fees", reducedFees)
        }
        if IsTrue(IsTrue(parseFee) && IsTrue((IsEqual(reducedLength, 1)))) {
            AddElementToObject(trade, "fee", GetValue(reducedFees, 0))
        }
        tradeFee := this.safeValue(trade, "fee")
        if IsTrue(!IsEqual(tradeFee, nil)) {
            AddElementToObject(tradeFee, "cost", this.safeNumber(tradeFee, "cost"))
            if IsTrue(InOp(tradeFee, "rate")) {
                AddElementToObject(tradeFee, "rate", this.safeNumber(tradeFee, "rate"))
            }
            AddElementToObject(trade, "fee", tradeFee)
        }
    }
    AddElementToObject(trade, "amount", this.parseNumber(amount))
    AddElementToObject(trade, "price", this.parseNumber(price))
    AddElementToObject(trade, "cost", this.parseNumber(cost))
    return trade
}
func  (this *Exchange) findNearestCeiling(arr interface{}, providedValue interface{}) interface{}  {
    //  i.e. findNearestCeiling ([ 10, 30, 50],  23) returns 30
    length := GetArrayLength(arr)
    for i := 0; IsLessThan(i, length); i++ {
        current := GetValue(arr, i)
        if IsTrue(IsLessThanOrEqual(providedValue, current)) {
            return current
        }
    }
    return GetValue(arr, Subtract(length, 1))
}
func  (this *Exchange) invertFlatStringDictionary(dict interface{}) interface{}  {
    reversed := map[string]interface{} {}
    keys := ObjectKeys(dict)
    for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
        key := GetValue(keys, i)
        value := GetValue(dict, key)
        if IsTrue(IsString(value)) {
            AddElementToObject(reversed, value, key)
        }
    }
    return reversed
}
func  (this *Exchange) reduceFeesByCurrency(fees interface{}) interface{}  {
    //
    // this function takes a list of fee structures having the following format
    //
    //     string = true
    //
    //     [
    //         { 'currency': 'BTC', 'cost': '0.1' },
    //         { 'currency': 'BTC', 'cost': '0.2'  },
    //         { 'currency': 'BTC', 'cost': '0.2', 'rate': '0.00123' },
    //         { 'currency': 'BTC', 'cost': '0.4', 'rate': '0.00123' },
    //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
    //         { 'currency': 'USDT', 'cost': '12.3456' },
    //     ]
    //
    //     string = false
    //
    //     [
    //         { 'currency': 'BTC', 'cost': 0.1 },
    //         { 'currency': 'BTC', 'cost': 0.2 },
    //         { 'currency': 'BTC', 'cost': 0.2, 'rate': 0.00123 },
    //         { 'currency': 'BTC', 'cost': 0.4, 'rate': 0.00123 },
    //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
    //         { 'currency': 'USDT', 'cost': 12.3456 },
    //     ]
    //
    // and returns a reduced fee list, where fees are summed per currency and rate (if any)
    //
    //     string = true
    //
    //     [
    //         { 'currency': 'BTC', 'cost': '0.4'  },
    //         { 'currency': 'BTC', 'cost': '0.6', 'rate': '0.00123' },
    //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
    //         { 'currency': 'USDT', 'cost': '12.3456' },
    //     ]
    //
    //     string  = false
    //
    //     [
    //         { 'currency': 'BTC', 'cost': 0.3  },
    //         { 'currency': 'BTC', 'cost': 0.6, 'rate': 0.00123 },
    //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
    //         { 'currency': 'USDT', 'cost': 12.3456 },
    //     ]
    //
    reduced := map[string]interface{} {}
    for i := 0; IsLessThan(i, GetArrayLength(fees)); i++ {
        fee := GetValue(fees, i)
        feeCurrencyCode := this.safeString(fee, "currency")
        if IsTrue(!IsEqual(feeCurrencyCode, nil)) {
            rate := this.safeString(fee, "rate")
            cost := this.safeValue(fee, "cost")
            if IsTrue(Precise.stringEq(cost, "0")) {
                continue
            }
            if !IsTrue((InOp(reduced, feeCurrencyCode))) {
                AddElementToObject(reduced, feeCurrencyCode, map[string]interface{} {})
            }
            rateKey := Ternary(IsTrue((IsEqual(rate, nil))), "", rate)
            if IsTrue(InOp(GetValue(reduced, feeCurrencyCode), rateKey)) {
                AddElementToObject(GetValue(GetValue(reduced, feeCurrencyCode), rateKey), "cost", Precise.stringAdd(GetValue(GetValue(GetValue(reduced, feeCurrencyCode), rateKey), "cost"), cost))
            } else {
                AddElementToObject(GetValue(reduced, feeCurrencyCode), rateKey, map[string]interface{} {
    "currency": feeCurrencyCode,
    "cost": cost,
})
                if IsTrue(!IsEqual(rate, nil)) {
                    AddElementToObject(GetValue(GetValue(reduced, feeCurrencyCode), rateKey), "rate", rate)
                }
            }
        }
    }
    result := []interface{}{}
    feeValues := ObjectValues(reduced)
    for i := 0; IsLessThan(i, GetArrayLength(feeValues)); i++ {
        reducedFeeValues := ObjectValues(GetValue(feeValues, i))
        result = this.arrayConcat(result, reducedFeeValues)
    }
    return result
}
func  (this *Exchange) safeTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    open := this.omitZero(this.safeString(ticker, "open"))
    close := this.omitZero(this.safeString(ticker, "close"))
    last := this.omitZero(this.safeString(ticker, "last"))
    change := this.omitZero(this.safeString(ticker, "change"))
    percentage := this.omitZero(this.safeString(ticker, "percentage"))
    average := this.omitZero(this.safeString(ticker, "average"))
    vwap := this.omitZero(this.safeString(ticker, "vwap"))
    baseVolume := this.safeString(ticker, "baseVolume")
    quoteVolume := this.safeString(ticker, "quoteVolume")
    if IsTrue(IsEqual(vwap, nil)) {
        vwap = Precise.stringDiv(this.omitZero(quoteVolume), baseVolume)
    }
    if IsTrue(IsTrue((!IsEqual(last, nil))) && IsTrue((IsEqual(close, nil)))) {
        close = last
    } else if IsTrue(IsTrue((IsEqual(last, nil))) && IsTrue((!IsEqual(close, nil)))) {
        last = close
    }
    if IsTrue(IsTrue((!IsEqual(last, nil))) && IsTrue((!IsEqual(open, nil)))) {
        if IsTrue(IsEqual(change, nil)) {
            change = Precise.stringSub(last, open)
        }
        if IsTrue(IsEqual(average, nil)) {
            average = Precise.stringDiv(Precise.stringAdd(last, open), "2")
        }
    }
    if IsTrue(IsTrue(IsTrue(IsTrue((IsEqual(percentage, nil))) && IsTrue((!IsEqual(change, nil)))) && IsTrue((!IsEqual(open, nil)))) && IsTrue(Precise.stringGt(open, "0"))) {
        percentage = Precise.stringMul(Precise.stringDiv(change, open), "100")
    }
    if IsTrue(IsTrue(IsTrue((IsEqual(change, nil))) && IsTrue((!IsEqual(percentage, nil)))) && IsTrue((!IsEqual(open, nil)))) {
        change = Precise.stringDiv(Precise.stringMul(percentage, open), "100")
    }
    if IsTrue(IsTrue(IsTrue((IsEqual(open, nil))) && IsTrue((!IsEqual(last, nil)))) && IsTrue((!IsEqual(change, nil)))) {
        open = Precise.stringSub(last, change)
    }
    // timestamp and symbol operations don't belong in safeTicker
    // they should be done in the derived classes
    return this.extend(ticker, map[string]interface{} {
        "bid": this.parseNumber(this.omitZero(this.safeString(ticker, "bid"))),
        "bidVolume": this.safeNumber(ticker, "bidVolume"),
        "ask": this.parseNumber(this.omitZero(this.safeString(ticker, "ask"))),
        "askVolume": this.safeNumber(ticker, "askVolume"),
        "high": this.parseNumber(this.omitZero(this.safeString(ticker, "high"))),
        "low": this.parseNumber(this.omitZero(this.safeString(ticker, "low"))),
        "open": this.parseNumber(this.omitZero(open)),
        "close": this.parseNumber(this.omitZero(close)),
        "last": this.parseNumber(this.omitZero(last)),
        "change": this.parseNumber(change),
        "percentage": this.parseNumber(percentage),
        "average": this.parseNumber(average),
        "vwap": this.parseNumber(vwap),
        "baseVolume": this.parseNumber(baseVolume),
        "quoteVolume": this.parseNumber(quoteVolume),
        "previousClose": this.safeNumber(ticker, "previousClose"),
    })
}
func  (this *Exchange) fetchBorrowRate(code string, amount interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchBorrowRate is deprecated, please use fetchCrossBorrowRate or fetchIsolatedBorrowRate instead")))
}
func  (this *Exchange) repayCrossMargin(code string, amount interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " repayCrossMargin is not support yet")))
}
func  (this *Exchange) repayIsolatedMargin(symbol string, code string, amount interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " repayIsolatedMargin is not support yet")))
}
func  (this *Exchange) borrowCrossMargin(code string, amount interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " borrowCrossMargin is not support yet")))
}
func  (this *Exchange) borrowIsolatedMargin(symbol string, code string, amount interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " borrowIsolatedMargin is not support yet")))
}
func  (this *Exchange) borrowMargin(code string, amount interface{}, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 2, nil)
    _ = symbol
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " borrowMargin is deprecated, please use borrowCrossMargin or borrowIsolatedMargin instead")))
}
func  (this *Exchange) repayMargin(code string, amount interface{}, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 2, nil)
    _ = symbol
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " repayMargin is deprecated, please use repayCrossMargin or repayIsolatedMargin instead")))
}
func  (this *Exchange) fetchOHLCV(symbol string, optionalArgs ...interface{}) interface{}  {
    timeframe := GetArg(optionalArgs, 1, "1m")
    _ = timeframe
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    message := ""
    if IsTrue(GetValue(this.has, "fetchTrades")) {
        message = ". If you want to build OHLCV candles from trade executions data, visit https://github.com/ccxt/ccxt/tree/master/examples/ and see \"build-ohlcv-bars\" file"
    }
    panic(NotSupported(Add(Add(this.id, " fetchOHLCV() is not supported yet"), message)))
}
func  (this *Exchange) fetchOHLCVWs(symbol string, optionalArgs ...interface{}) interface{}  {
    timeframe := GetArg(optionalArgs, 1, "1m")
    _ = timeframe
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    message := ""
    if IsTrue(GetValue(this.has, "fetchTradesWs")) {
        message = ". If you want to build OHLCV candles from trade executions data, visit https://github.com/ccxt/ccxt/tree/master/examples/ and see \"build-ohlcv-bars\" file"
    }
    panic(NotSupported(Add(Add(this.id, " fetchOHLCVWs() is not supported yet. Try using fetchOHLCV instead."), message)))
}
func  (this *Exchange) watchOHLCV(symbol string, optionalArgs ...interface{}) interface{}  {
    timeframe := GetArg(optionalArgs, 1, "1m")
    _ = timeframe
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchOHLCV() is not supported yet")))
}
func  (this *Exchange) convertTradingViewToOHLCV(ohlcvs interface{}, optionalArgs ...interface{}) interface{}  {
    timestamp := GetArg(optionalArgs, 1, "t")
    _ = timestamp
    open := GetArg(optionalArgs, 2, "o")
    _ = open
    high := GetArg(optionalArgs, 3, "h")
    _ = high
    low := GetArg(optionalArgs, 4, "l")
    _ = low
    close := GetArg(optionalArgs, 5, "c")
    _ = close
    volume := GetArg(optionalArgs, 6, "v")
    _ = volume
    ms := GetArg(optionalArgs, 7, false)
    _ = ms
    result := []interface{}{}
    timestamps := this.safeList(ohlcvs, timestamp, []interface{}{})
    opens := this.safeList(ohlcvs, open, []interface{}{})
    highs := this.safeList(ohlcvs, high, []interface{}{})
    lows := this.safeList(ohlcvs, low, []interface{}{})
    closes := this.safeList(ohlcvs, close, []interface{}{})
    volumes := this.safeList(ohlcvs, volume, []interface{}{})
    for i := 0; IsLessThan(i, GetArrayLength(timestamps)); i++ {
        result = AppendToArray(result,[]interface{}{Ternary(IsTrue(ms), this.safeInteger(timestamps, i), this.safeTimestamp(timestamps, i)), this.safeValue(opens, i), this.safeValue(highs, i), this.safeValue(lows, i), this.safeValue(closes, i), this.safeValue(volumes, i)}).([]interface{})
    }
    return result
}
func  (this *Exchange) convertOHLCVToTradingView(ohlcvs interface{}, optionalArgs ...interface{}) interface{}  {
    timestamp := GetArg(optionalArgs, 1, "t")
    _ = timestamp
    open := GetArg(optionalArgs, 2, "o")
    _ = open
    high := GetArg(optionalArgs, 3, "h")
    _ = high
    low := GetArg(optionalArgs, 4, "l")
    _ = low
    close := GetArg(optionalArgs, 5, "c")
    _ = close
    volume := GetArg(optionalArgs, 6, "v")
    _ = volume
    ms := GetArg(optionalArgs, 7, false)
    _ = ms
    result := map[string]interface{} {}
    AddElementToObject(result, timestamp, []interface{}{})
    AddElementToObject(result, open, []interface{}{})
    AddElementToObject(result, high, []interface{}{})
    AddElementToObject(result, low, []interface{}{})
    AddElementToObject(result, close, []interface{}{})
    AddElementToObject(result, volume, []interface{}{})
    for i := 0; IsLessThan(i, GetArrayLength(ohlcvs)); i++ {
        ts := Ternary(IsTrue(ms), GetValue(GetValue(ohlcvs, i), 0), this.parseToInt(Divide(GetValue(GetValue(ohlcvs, i), 0), 1000)))
        GetValue(result, timestamp) = AppendToArray(GetValue(result, timestamp),ts).([]interface{})
        GetValue(result, open) = AppendToArray(GetValue(result, open),GetValue(GetValue(ohlcvs, i), 1)).([]interface{})
        GetValue(result, high) = AppendToArray(GetValue(result, high),GetValue(GetValue(ohlcvs, i), 2)).([]interface{})
        GetValue(result, low) = AppendToArray(GetValue(result, low),GetValue(GetValue(ohlcvs, i), 3)).([]interface{})
        GetValue(result, close) = AppendToArray(GetValue(result, close),GetValue(GetValue(ohlcvs, i), 4)).([]interface{})
        GetValue(result, volume) = AppendToArray(GetValue(result, volume),GetValue(GetValue(ohlcvs, i), 5)).([]interface{})
    }
    return result
}
func  (this *Exchange) fetchWebEndpoint(method interface{}, endpointMethod interface{}, returnAsJson interface{}, optionalArgs ...interface{}) interface{}  {
    startRegex := GetArg(optionalArgs, 3, nil)
    _ = startRegex
    endRegex := GetArg(optionalArgs, 4, nil)
    _ = endRegex
    errorMessage := ""
    options := this.safeValue(this.options, method, map[string]interface{} {})
    muteOnFailure := this.safeBool(options, "webApiMuteFailure", true)
    
    {		ret__ := func(this *Exchange) (ret_ interface{}) {
    		defer func() {
    			if e := recover().(interface{}); e != nil {
    				ret_ = func(this *Exchange) interface{} {
    					// catch block:
                                errorMessage = Add(Add(Add(this.id, " "), method), "() failed to fetch correct data from website. Probably webpage markup has been changed, breaking the page custom parser.")
    					return nil
    				}(this)
    			}
    		}()
    		// try block:
                    // if it was not explicitly disabled, then don't fetch
            if IsTrue(!IsEqual(this.safeBool(options, "webApiEnable", true), true)) {
                return nil
            }
            maxRetries := this.safeValue(options, "webApiRetries", 10)
            var response interface{} = nil
            retry := 0
            for IsLessThan(retry, maxRetries) {
                
                {		ret__ := func(this *Exchange) (ret_ interface{}) {
                		defer func() {
                			if e := recover().(interface{}); e != nil {
                				ret_ = func(this *Exchange) interface{} {
                					// catch block:
                                                    retry = Add(retry, 1)
                                if IsTrue(IsEqual(retry, maxRetries)) {
                                    panic(e)
                                }
                					return nil
                				}(this)
                			}
                		}()
                		// try block:
                                        response = callDynamically(endpointMethod, map[string]interface{} {})
                                break
                		return nil
                	}(this)
                	if ret__ != nil {
                		return ret__
                	}
                }
            }
            content := response
            if IsTrue(!IsEqual(startRegex, nil)) {
                splitted_by_start := Split(content, startRegex)
                content = GetValue(splitted_by_start, 1) // we need second part after start
            }
            if IsTrue(!IsEqual(endRegex, nil)) {
                splitted_by_end := Split(content, endRegex)
                content = GetValue(splitted_by_end, 0) // we need first part after start
            }
            if IsTrue(IsTrue(returnAsJson) && IsTrue((IsString(content)))) {
                jsoned := this.parseJson(Trim(content)) // content should be trimmed before json parsing
                if IsTrue(jsoned) {
                    return jsoned  // if parsing was not successfull, exception should be thrown
                } else {
                    panic(BadResponse("could not parse the response into json"))
                }
            } else {
                return content
            }
    		return nil
    	}(this)
    	if ret__ != nil {
    		return ret__
    	}
    }
    if IsTrue(muteOnFailure) {
        return nil
    } else {
        panic(BadResponse(errorMessage))
    }
}
func  (this *Exchange) marketIds(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    if IsTrue(IsEqual(symbols, nil)) {
        return symbols
    }
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
        result = AppendToArray(result,this.marketId(GetValue(symbols, i))).([]interface{})
    }
    return result
}
func  (this *Exchange) marketsForSymbols(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    if IsTrue(IsEqual(symbols, nil)) {
        return symbols
    }
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
        result = AppendToArray(result,this.market(GetValue(symbols, i))).([]interface{})
    }
    return result
}
func  (this *Exchange) marketSymbols(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    typeVar := GetArg(optionalArgs, 1, nil)
    _ = typeVar
    allowEmpty := GetArg(optionalArgs, 2, true)
    _ = allowEmpty
    sameTypeOnly := GetArg(optionalArgs, 3, false)
    _ = sameTypeOnly
    sameSubTypeOnly := GetArg(optionalArgs, 4, false)
    _ = sameSubTypeOnly
    if IsTrue(IsEqual(symbols, nil)) {
        if !IsTrue(allowEmpty) {
            panic(ArgumentsRequired(Add(this.id, " empty list of symbols is not supported")))
        }
        return symbols
    }
    symbolsLength := GetArrayLength(symbols)
    if IsTrue(IsEqual(symbolsLength, 0)) {
        if !IsTrue(allowEmpty) {
            panic(ArgumentsRequired(Add(this.id, " empty list of symbols is not supported")))
        }
        return symbols
    }
    result := []interface{}{}
    var marketType interface{} = nil
    var isLinearSubType interface{} = nil
    for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
        market := this.market(GetValue(symbols, i))
        if IsTrue(IsTrue(sameTypeOnly) && IsTrue((!IsEqual(marketType, nil)))) {
            if IsTrue(!IsEqual(GetValue(market, "type"), marketType)) {
                panic(BadRequest(Add(Add(Add(Add(Add(this.id, " symbols must be of the same type, either "), marketType), " or "), GetValue(market, "type")), ".")))
            }
        }
        if IsTrue(IsTrue(sameSubTypeOnly) && IsTrue((!IsEqual(isLinearSubType, nil)))) {
            if IsTrue(!IsEqual(GetValue(market, "linear"), isLinearSubType)) {
                panic(BadRequest(Add(this.id, " symbols must be of the same subType, either linear or inverse.")))
            }
        }
        if IsTrue(IsTrue(!IsEqual(typeVar, nil)) && IsTrue(!IsEqual(GetValue(market, "type"), typeVar))) {
            panic(BadRequest(Add(Add(Add(this.id, " symbols must be of the same type "), typeVar), ". If the type is incorrect you can change it in options or the params of the request")))
        }
        marketType = GetValue(market, "type")
        if !IsTrue(GetValue(market, "spot")) {
            isLinearSubType = GetValue(market, "linear")
        }
        symbol := this.safeString(market, "symbol", GetValue(symbols, i))
        result = AppendToArray(result,symbol).([]interface{})
    }
    return result
}
func  (this *Exchange) marketCodes(optionalArgs ...interface{}) interface{}  {
    codes := GetArg(optionalArgs, 0, nil)
    _ = codes
    if IsTrue(IsEqual(codes, nil)) {
        return codes
    }
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(codes)); i++ {
        result = AppendToArray(result,this.commonCurrencyCode(GetValue(codes, i))).([]interface{})
    }
    return result
}
func  (this *Exchange) parseBidsAsks(bidasks interface{}, optionalArgs ...interface{}) interface{}  {
    priceKey := GetArg(optionalArgs, 1, 0)
    _ = priceKey
    amountKey := GetArg(optionalArgs, 2, 1)
    _ = amountKey
    countOrIdKey := GetArg(optionalArgs, 3, 2)
    _ = countOrIdKey
    bidasks = this.toArray(bidasks)
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(bidasks)); i++ {
        result = AppendToArray(result,this.parseBidAsk(GetValue(bidasks, i), priceKey, amountKey, countOrIdKey)).([]interface{})
    }
    return result
}
func  (this *Exchange) fetchL2OrderBook(symbol string, optionalArgs ...interface{}) interface{}  {
    limit := GetArg(optionalArgs, 1, nil)
    _ = limit
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    orderbook := this.fetchOrderBook(symbol, limit, params)
    return this.extend(orderbook, map[string]interface{} {
        "asks": this.sortBy(this.aggregate(GetValue(orderbook, "asks")), 0),
        "bids": this.sortBy(this.aggregate(GetValue(orderbook, "bids")), 0, true),
    })
}
func  (this *Exchange) filterBySymbol(objects interface{}, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    if IsTrue(IsEqual(symbol, nil)) {
        return objects
    }
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(objects)); i++ {
        objectSymbol := this.safeString(GetValue(objects, i), "symbol")
        if IsTrue(IsEqual(objectSymbol, symbol)) {
            result = AppendToArray(result,GetValue(objects, i)).([]interface{})
        }
    }
    return result
}
func  (this *Exchange) parseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    if IsTrue(IsArray(ohlcv)) {
        return []interface{}{this.safeInteger(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 5)}
    }
    return ohlcv
}
func  (this *Exchange) networkCodeToId(networkCode string, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @name exchange#networkCodeToId
    * @description tries to convert the provided networkCode (which is expected to be an unified network code) to a network id. In order to achieve this, derived class needs to have 'options->networks' defined.
    * @param {string} networkCode unified network code
    * @param {string} currencyCode unified currency code, but this argument is not required by default, unless there is an exchange (like huobi) that needs an override of the method to be able to pass currencyCode argument additionally
    * @returns {string|undefined} exchange-specific network id
    */
    currencyCode := GetArg(optionalArgs, 1, nil)
    _ = currencyCode
    if IsTrue(IsEqual(networkCode, nil)) {
        return nil
    }
    networkIdsByCodes := this.safeValue(this.options, "networks", map[string]interface{} {})
    networkId := this.safeString(networkIdsByCodes, networkCode)
    // for example, if 'ETH' is passed for networkCode, but 'ETH' key not defined in `options->networks` object
    if IsTrue(IsEqual(networkId, nil)) {
        if IsTrue(IsEqual(currencyCode, nil)) {
            currencies := ObjectValues(this.currencies)
            for i := 0; IsLessThan(i, GetArrayLength(currencies)); i++ {
                currency := []interface{}{i}
                networks := this.safeDict(currency, "networks")
                network := this.safeDict(networks, networkCode)
                networkId = this.safeString(network, "id")
                if IsTrue(!IsEqual(networkId, nil)) {
                    break
                }
            }
        } else {
            // if currencyCode was provided, then we try to find if that currencyCode has a replacement (i.e. ERC20 for ETH) or is in the currency
            defaultNetworkCodeReplacements := this.safeValue(this.options, "defaultNetworkCodeReplacements", map[string]interface{} {})
            if IsTrue(InOp(defaultNetworkCodeReplacements, currencyCode)) {
                // if there is a replacement for the passed networkCode, then we use it to find network-id in `options->networks` object
                replacementObject := GetValue(defaultNetworkCodeReplacements, currencyCode) // i.e. { 'ERC20': 'ETH' }
                keys := ObjectKeys(replacementObject)
                for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
                    key := GetValue(keys, i)
                    value := GetValue(replacementObject, key)
                    // if value matches to provided unified networkCode, then we use it's key to find network-id in `options->networks` object
                    if IsTrue(IsEqual(value, networkCode)) {
                        networkId = this.safeString(networkIdsByCodes, key)
                        break
                    }
                }
            } else {
                // serach for network inside currency
                currency := this.safeDict(this.currencies, currencyCode)
                networks := this.safeDict(currency, "networks")
                network := this.safeDict(networks, networkCode)
                networkId = this.safeString(network, "id")
            }
        }
        // if it wasn't found, we just set the provided value to network-id
        if IsTrue(IsEqual(networkId, nil)) {
            networkId = networkCode
        }
    }
    return networkId
}
func  (this *Exchange) networkIdToCode(optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @name exchange#networkIdToCode
    * @description tries to convert the provided exchange-specific networkId to an unified network Code. In order to achieve this, derived class needs to have "options['networksById']" defined.
    * @param {string} networkId exchange specific network id/title, like: TRON, Trc-20, usdt-erc20, etc
    * @param {string|undefined} currencyCode unified currency code, but this argument is not required by default, unless there is an exchange (like huobi) that needs an override of the method to be able to pass currencyCode argument additionally
    * @returns {string|undefined} unified network code
    */
    networkId := GetArg(optionalArgs, 0, nil)
    _ = networkId
    currencyCode := GetArg(optionalArgs, 1, nil)
    _ = currencyCode
    if IsTrue(IsEqual(networkId, nil)) {
        return nil
    }
    networkCodesByIds := this.safeDict(this.options, "networksById", map[string]interface{} {})
    networkCode := this.safeString(networkCodesByIds, networkId, networkId)
    // replace mainnet network-codes (i.e. ERC20->ETH)
    if IsTrue(!IsEqual(currencyCode, nil)) {
        defaultNetworkCodeReplacements := this.safeDict(this.options, "defaultNetworkCodeReplacements", map[string]interface{} {})
        if IsTrue(InOp(defaultNetworkCodeReplacements, currencyCode)) {
            replacementObject := this.safeDict(defaultNetworkCodeReplacements, currencyCode, map[string]interface{} {})
            networkCode = this.safeString(replacementObject, networkCode, networkCode)
        }
    }
    return networkCode
}
func  (this *Exchange) handleNetworkCodeAndParams(params interface{}) interface{}  {
    networkCodeInParams := this.safeString2(params, "networkCode", "network")
    if IsTrue(!IsEqual(networkCodeInParams, nil)) {
        params = this.omit(params, []interface{}{"networkCode", "network"})
    }
    // if it was not defined by user, we should not set it from 'defaultNetworks', because handleNetworkCodeAndParams is for only request-side and thus we do not fill it with anything. We can only use 'defaultNetworks' after parsing response-side
    return []interface{}{networkCodeInParams, params}
}
func  (this *Exchange) defaultNetworkCode(currencyCode string) interface{}  {
    var defaultNetworkCode interface{} = nil
    defaultNetworks := this.safeDict(this.options, "defaultNetworks", map[string]interface{} {})
    if IsTrue(InOp(defaultNetworks, currencyCode)) {
        // if currency had set its network in "defaultNetworks", use it
        defaultNetworkCode = GetValue(defaultNetworks, currencyCode)
    } else {
        // otherwise, try to use the global-scope 'defaultNetwork' value (even if that network is not supported by currency, it doesn't make any problem, this will be just used "at first" if currency supports this network at all)
        defaultNetwork := this.safeDict(this.options, "defaultNetwork")
        if IsTrue(!IsEqual(defaultNetwork, nil)) {
            defaultNetworkCode = defaultNetwork
        }
    }
    return defaultNetworkCode
}
func  (this *Exchange) selectNetworkCodeFromUnifiedNetworks(currencyCode interface{}, networkCode interface{}, indexedNetworkEntries interface{}) interface{}  {
    return this.selectNetworkKeyFromNetworks(currencyCode, networkCode, indexedNetworkEntries, true)
}
func  (this *Exchange) selectNetworkIdFromRawNetworks(currencyCode interface{}, networkCode interface{}, indexedNetworkEntries interface{}) interface{}  {
    return this.selectNetworkKeyFromNetworks(currencyCode, networkCode, indexedNetworkEntries, false)
}
func  (this *Exchange) selectNetworkKeyFromNetworks(currencyCode interface{}, networkCode interface{}, indexedNetworkEntries interface{}, optionalArgs ...interface{}) interface{}  {
    // this method is used against raw & unparse network entries, which are just indexed by network id
    isIndexedByUnifiedNetworkCode := GetArg(optionalArgs, 3, false)
    _ = isIndexedByUnifiedNetworkCode
    var chosenNetworkId interface{} = nil
    availableNetworkIds := ObjectKeys(indexedNetworkEntries)
    responseNetworksLength := GetArrayLength(availableNetworkIds)
    if IsTrue(!IsEqual(networkCode, nil)) {
        if IsTrue(IsEqual(responseNetworksLength, 0)) {
            panic(NotSupported(Add(Add(Add(Add(this.id, " - "), networkCode), " network did not return any result for "), currencyCode)))
        } else {
            // if networkCode was provided by user, we should check it after response, as the referenced exchange doesn't support network-code during request
            networkId := Ternary(IsTrue(isIndexedByUnifiedNetworkCode), networkCode, this.networkCodeToId(networkCode, currencyCode))
            if IsTrue(InOp(indexedNetworkEntries, networkId)) {
                chosenNetworkId = networkId
            } else {
                panic(NotSupported(Add(Add(Add(Add(Add(Add(this.id, " - "), networkId), " network was not found for "), currencyCode), ", use one of "), Join(availableNetworkIds, ", "))))
            }
        }
    } else {
        if IsTrue(IsEqual(responseNetworksLength, 0)) {
            panic(NotSupported(Add(Add(this.id, " - no networks were returned for "), currencyCode)))
        } else {
            // if networkCode was not provided by user, then we try to use the default network (if it was defined in "defaultNetworks"), otherwise, we just return the first network entry
            defaultNetworkCode := this.defaultNetworkCode(currencyCode)
            defaultNetworkId := Ternary(IsTrue(isIndexedByUnifiedNetworkCode), defaultNetworkCode, this.networkCodeToId(defaultNetworkCode, currencyCode))
            chosenNetworkId = Ternary(IsTrue((InOp(indexedNetworkEntries, defaultNetworkId))), defaultNetworkId, GetValue(availableNetworkIds, 0))
        }
    }
    return chosenNetworkId
}
func  (this *Exchange) safeNumber2(dictionary interface{}, key1 interface{}, key2 interface{}, optionalArgs ...interface{}) interface{}  {
    d := GetArg(optionalArgs, 3, nil)
    _ = d
    value := this.safeString2(dictionary, key1, key2)
    return this.parseNumber(value, d)
}
func  (this *Exchange) parseOrderBook(orderbook interface{}, symbol string, optionalArgs ...interface{}) interface{}  {
    timestamp := GetArg(optionalArgs, 2, nil)
    _ = timestamp
    bidsKey := GetArg(optionalArgs, 3, "bids")
    _ = bidsKey
    asksKey := GetArg(optionalArgs, 4, "asks")
    _ = asksKey
    priceKey := GetArg(optionalArgs, 5, 0)
    _ = priceKey
    amountKey := GetArg(optionalArgs, 6, 1)
    _ = amountKey
    countOrIdKey := GetArg(optionalArgs, 7, 2)
    _ = countOrIdKey
    bids := this.parseBidsAsks(this.safeValue(orderbook, bidsKey, []interface{}{}), priceKey, amountKey, countOrIdKey)
    asks := this.parseBidsAsks(this.safeValue(orderbook, asksKey, []interface{}{}), priceKey, amountKey, countOrIdKey)
    return map[string]interface{} {
        "symbol": symbol,
        "bids": this.sortBy(bids, 0, true),
        "asks": this.sortBy(asks, 0),
        "timestamp": timestamp,
        "datetime": this.iso8601(timestamp),
        "nonce": nil,
    }
}
func  (this *Exchange) parseOHLCVs(ohlcvs interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    timeframe := GetArg(optionalArgs, 2, "1m")
    _ = timeframe
    since := GetArg(optionalArgs, 3, nil)
    _ = since
    limit := GetArg(optionalArgs, 4, nil)
    _ = limit
    results := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(ohlcvs)); i++ {
        results = AppendToArray(results,this.parseOHLCV(GetValue(ohlcvs, i), market)).([]interface{})
    }
    sorted := this.sortBy(results, 0)
    return this.filterBySinceLimit(sorted, since, limit, 0)
}
func  (this *Exchange) parseLeverageTiers(response interface{}, optionalArgs ...interface{}) interface{}  {
    // marketIdKey should only be undefined when response is a dictionary
    symbols := GetArg(optionalArgs, 1, nil)
    _ = symbols
    marketIdKey := GetArg(optionalArgs, 2, nil)
    _ = marketIdKey
    symbols = this.marketSymbols(symbols)
    tiers := map[string]interface{} {}
    symbolsLength := 0
    if IsTrue(!IsEqual(symbols, nil)) {
        symbolsLength = GetArrayLength(symbols)
    }
    noSymbols := IsTrue((IsEqual(symbols, nil))) || IsTrue((IsEqual(symbolsLength, 0)))
    if IsTrue(IsArray(response)) {
        for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
            item := GetValue(response, i)
            id := this.safeString(item, marketIdKey)
            market := this.safeMarket(id, nil, nil, "swap")
            symbol := GetValue(market, "symbol")
            contract := this.safeBool(market, "contract", false)
            if IsTrue(IsTrue(contract) && IsTrue((IsTrue(noSymbols) || IsTrue(this.inArray(symbol, symbols))))) {
                AddElementToObject(tiers, symbol, this.parseMarketLeverageTiers(item, market))
            }
        }
    } else {
        keys := ObjectKeys(response)
        for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
            marketId := GetValue(keys, i)
            item := GetValue(response, marketId)
            market := this.safeMarket(marketId, nil, nil, "swap")
            symbol := GetValue(market, "symbol")
            contract := this.safeBool(market, "contract", false)
            if IsTrue(IsTrue(contract) && IsTrue((IsTrue(noSymbols) || IsTrue(this.inArray(symbol, symbols))))) {
                AddElementToObject(tiers, symbol, this.parseMarketLeverageTiers(item, market))
            }
        }
    }
    return tiers
}
func  (this *Exchange) loadTradingLimits(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    reload := GetArg(optionalArgs, 1, false)
    _ = reload
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchTradingLimits")) {
        if IsTrue(IsTrue(reload) || !IsTrue((InOp(this.options, "limitsLoaded")))) {
            response := this.fetchTradingLimits(symbols)
            for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
                symbol := GetValue(symbols, i)
                AddElementToObject(this.markets, symbol, this.deepExtend(GetValue(this.markets, symbol), GetValue(response, symbol)))
            }
            AddElementToObject(this.options, "limitsLoaded", this.milliseconds())
        }
    }
    return this.markets
}
func  (this *Exchange) safePosition(position interface{}) interface{}  {
    // simplified version of: /pull/12765/
    unrealizedPnlString := this.safeString(position, "unrealisedPnl")
    initialMarginString := this.safeString(position, "initialMargin")
    //
    // PERCENTAGE
    //
    percentage := this.safeValue(position, "percentage")
    if IsTrue(IsTrue(IsTrue((IsEqual(percentage, nil))) && IsTrue((!IsEqual(unrealizedPnlString, nil)))) && IsTrue((!IsEqual(initialMarginString, nil)))) {
        // as it was done in all implementations ( aax, btcex, bybit, deribit, ftx, gate, kucoinfutures, phemex )
        percentageString := Precise.stringMul(Precise.stringDiv(unrealizedPnlString, initialMarginString, 4), "100")
        AddElementToObject(position, "percentage", this.parseNumber(percentageString))
    }
    // if contractSize is undefined get from market
    contractSize := this.safeNumber(position, "contractSize")
    symbol := this.safeString(position, "symbol")
    var market interface{} = nil
    if IsTrue(!IsEqual(symbol, nil)) {
        market = this.safeValue(this.markets, symbol)
    }
    if IsTrue(IsTrue(IsEqual(contractSize, nil)) && IsTrue(!IsEqual(market, nil))) {
        contractSize = this.safeNumber(market, "contractSize")
        AddElementToObject(position, "contractSize", contractSize)
    }
    return position
}
func  (this *Exchange) parsePositions(positions interface{}, optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 1, nil)
    _ = symbols
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    symbols = this.marketSymbols(symbols)
    positions = this.toArray(positions)
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(positions)); i++ {
        position := this.extend(this.parsePosition(GetValue(positions, i), nil), params)
        result = AppendToArray(result,position).([]interface{})
    }
    return this.filterByArrayPositions(result, "symbol", symbols, false)
}
func  (this *Exchange) parseAccounts(accounts interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    accounts = this.toArray(accounts)
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(accounts)); i++ {
        account := this.extend(this.parseAccount(GetValue(accounts, i)), params)
        result = AppendToArray(result,account).([]interface{})
    }
    return result
}
func  (this *Exchange) parseTrades(trades interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    trades = this.toArray(trades)
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(trades)); i++ {
        trade := this.extend(this.parseTrade(GetValue(trades, i), market), params)
        result = AppendToArray(result,trade).([]interface{})
    }
    result = this.sortBy2(result, "timestamp", "id")
    symbol := Ternary(IsTrue((!IsEqual(market, nil))), GetValue(market, "symbol"), nil)
    return this.filterBySymbolSinceLimit(result, symbol, since, limit)
}
func  (this *Exchange) parseTransactions(transactions interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 1, nil)
    _ = currency
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    transactions = this.toArray(transactions)
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(transactions)); i++ {
        transaction := this.extend(this.parseTransaction(GetValue(transactions, i), currency), params)
        result = AppendToArray(result,transaction).([]interface{})
    }
    result = this.sortBy(result, "timestamp")
    code := Ternary(IsTrue((!IsEqual(currency, nil))), GetValue(currency, "code"), nil)
    return this.filterByCurrencySinceLimit(result, code, since, limit)
}
func  (this *Exchange) parseTransfers(transfers interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 1, nil)
    _ = currency
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    transfers = this.toArray(transfers)
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(transfers)); i++ {
        transfer := this.extend(this.parseTransfer(GetValue(transfers, i), currency), params)
        result = AppendToArray(result,transfer).([]interface{})
    }
    result = this.sortBy(result, "timestamp")
    code := Ternary(IsTrue((!IsEqual(currency, nil))), GetValue(currency, "code"), nil)
    return this.filterByCurrencySinceLimit(result, code, since, limit)
}
func  (this *Exchange) parseLedger(data interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 1, nil)
    _ = currency
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    result := []interface{}{}
    arrayData := this.toArray(data)
    for i := 0; IsLessThan(i, GetArrayLength(arrayData)); i++ {
        itemOrItems := this.parseLedgerEntry(GetValue(arrayData, i), currency)
        if IsTrue(IsArray(itemOrItems)) {
            for j := 0; IsLessThan(j, GetArrayLength(itemOrItems)); j++ {
                result = AppendToArray(result,this.extend(GetValue(itemOrItems, j), params)).([]interface{})
            }
        } else {
            result = AppendToArray(result,this.extend(itemOrItems, params)).([]interface{})
        }
    }
    result = this.sortBy(result, "timestamp")
    code := Ternary(IsTrue((!IsEqual(currency, nil))), GetValue(currency, "code"), nil)
    return this.filterByCurrencySinceLimit(result, code, since, limit)
}
func  (this *Exchange) nonce() interface{}  {
    return this.seconds()
}
func  (this *Exchange) setHeaders(headers interface{}) interface{}  {
    return headers
}
func  (this *Exchange) marketId(symbol string) interface{}  {
    market := this.market(symbol)
    if IsTrue(!IsEqual(market, nil)) {
        return GetValue(market, "id")
    }
    return symbol
}
func  (this *Exchange) symbol(symbol string) interface{}  {
    market := this.market(symbol)
    return this.safeString(market, "symbol", symbol)
}
func  (this *Exchange) handleParamString(params interface{}, paramName string, optionalArgs ...interface{}) interface{}  {
    defaultValue := GetArg(optionalArgs, 2, nil)
    _ = defaultValue
    value := this.safeString(params, paramName, defaultValue)
    if IsTrue(!IsEqual(value, nil)) {
        params = this.omit(params, paramName)
    }
    return []interface{}{value, params}
}
func  (this *Exchange) handleParamString2(params interface{}, paramName1 string, paramName2 string, optionalArgs ...interface{}) interface{}  {
    defaultValue := GetArg(optionalArgs, 3, nil)
    _ = defaultValue
    value := this.safeString2(params, paramName1, paramName2, defaultValue)
    if IsTrue(!IsEqual(value, nil)) {
        params = this.omit(params, []interface{}{paramName1, paramName2})
    }
    return []interface{}{value, params}
}
func  (this *Exchange) handleParamInteger(params interface{}, paramName string, optionalArgs ...interface{}) interface{}  {
    defaultValue := GetArg(optionalArgs, 2, nil)
    _ = defaultValue
    value := this.safeInteger(params, paramName, defaultValue)
    if IsTrue(!IsEqual(value, nil)) {
        params = this.omit(params, paramName)
    }
    return []interface{}{value, params}
}
func  (this *Exchange) handleParamInteger2(params interface{}, paramName1 string, paramName2 string, optionalArgs ...interface{}) interface{}  {
    defaultValue := GetArg(optionalArgs, 3, nil)
    _ = defaultValue
    value := this.safeInteger2(params, paramName1, paramName2, defaultValue)
    if IsTrue(!IsEqual(value, nil)) {
        params = this.omit(params, []interface{}{paramName1, paramName2})
    }
    return []interface{}{value, params}
}
func  (this *Exchange) handleParamBool(params interface{}, paramName string, optionalArgs ...interface{}) interface{}  {
    defaultValue := GetArg(optionalArgs, 2, nil)
    _ = defaultValue
    value := this.safeBool(params, paramName, defaultValue)
    if IsTrue(!IsEqual(value, nil)) {
        params = this.omit(params, paramName)
    }
    return []interface{}{value, params}
}
func  (this *Exchange) handleParamBool2(params interface{}, paramName1 string, paramName2 string, optionalArgs ...interface{}) interface{}  {
    defaultValue := GetArg(optionalArgs, 3, nil)
    _ = defaultValue
    value := this.safeBool2(params, paramName1, paramName2, defaultValue)
    if IsTrue(!IsEqual(value, nil)) {
        params = this.omit(params, []interface{}{paramName1, paramName2})
    }
    return []interface{}{value, params}
}
func  (this *Exchange) resolvePath(path interface{}, params interface{}) interface{}  {
    return []interface{}{this.implodeParams(path, params), this.omit(params, this.extractParams(path))}
}
func  (this *Exchange) getListFromObjectValues(objects interface{}, key interface{}) interface{}  {
    newArray := this.toArray(objects)
    results := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(newArray)); i++ {
        results = AppendToArray(results,GetValue(GetValue(newArray, i), key)).([]interface{})
    }
    return results
}
func  (this *Exchange) getSymbolsForMarketType(optionalArgs ...interface{}) interface{}  {
    marketType := GetArg(optionalArgs, 0, nil)
    _ = marketType
    subType := GetArg(optionalArgs, 1, nil)
    _ = subType
    symbolWithActiveStatus := GetArg(optionalArgs, 2, true)
    _ = symbolWithActiveStatus
    symbolWithUnknownStatus := GetArg(optionalArgs, 3, true)
    _ = symbolWithUnknownStatus
    filteredMarkets := this.markets
    if IsTrue(!IsEqual(marketType, nil)) {
        filteredMarkets = this.filterBy(filteredMarkets, "type", marketType)
    }
    if IsTrue(!IsEqual(subType, nil)) {
        this.checkRequiredArgument("getSymbolsForMarketType", subType, "subType", []interface{}{"linear", "inverse", "quanto"})
        filteredMarkets = this.filterBy(filteredMarkets, "subType", subType)
    }
    activeStatuses := []interface{}{}
    if IsTrue(symbolWithActiveStatus) {
        activeStatuses = AppendToArray(activeStatuses,true).([]interface{})
    }
    if IsTrue(symbolWithUnknownStatus) {
        activeStatuses = AppendToArray(activeStatuses,nil).([]interface{})
    }
    filteredMarkets = this.filterByArray(filteredMarkets, "active", activeStatuses, false)
    return this.getListFromObjectValues(filteredMarkets, "symbol")
}
func  (this *Exchange) filterByArray(objects interface{}, key interface{}, optionalArgs ...interface{}) interface{}  {
    values := GetArg(optionalArgs, 2, nil)
    _ = values
    indexed := GetArg(optionalArgs, 3, true)
    _ = indexed
    objects = this.toArray(objects)
    // return all of them if no values were passed
    if IsTrue(IsTrue(IsEqual(values, nil)) || !IsTrue(values)) {
        return Ternary(IsTrue(indexed), this.indexBy(objects, key), objects)
    }
    results := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(objects)); i++ {
        if IsTrue(this.inArray(GetValue(GetValue(objects, i), key), values)) {
            results = AppendToArray(results,GetValue(objects, i)).([]interface{})
        }
    }
    return Ternary(IsTrue(indexed), this.indexBy(results, key), results)
}
func  (this *Exchange) fetch2(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 1, "public")
    _ = api
    method := GetArg(optionalArgs, 2, "GET")
    _ = method
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 4, nil)
    _ = headers
    body := GetArg(optionalArgs, 5, nil)
    _ = body
    config := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = config
    if IsTrue(this.enableRateLimit) {
        cost := this.calculateRateLimiterCost(api, method, path, params, config)
        this.throttle(cost)
    }
    this.lastRestRequestTimestamp = this.milliseconds()
    request := this.sign(path, api, method, params, headers, body)
    this.last_request_headers = GetValue(request, "headers")
    this.last_request_body = GetValue(request, "body")
    this.last_request_url = GetValue(request, "url")
    return this.fetch(GetValue(request, "url"), GetValue(request, "method"), GetValue(request, "headers"), GetValue(request, "body"))
}
func  (this *Exchange) request(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 1, "public")
    _ = api
    method := GetArg(optionalArgs, 2, "GET")
    _ = method
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 4, nil)
    _ = headers
    body := GetArg(optionalArgs, 5, nil)
    _ = body
    config := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = config
    return this.fetch2(path, api, method, params, headers, body, config)
}
func  (this *Exchange) loadAccounts(optionalArgs ...interface{}) interface{}  {
    reload := GetArg(optionalArgs, 0, false)
    _ = reload
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    if IsTrue(reload) {
        this.accounts = this.fetchAccounts(params)
    } else {
        if IsTrue(this.accounts) {
            return this.accounts
        } else {
            this.accounts = this.fetchAccounts(params)
        }
    }
    this.accountsById = this.indexBy(this.accounts, "id")
    return this.accounts
}
func  (this *Exchange) buildOHLCVC(trades interface{}, optionalArgs ...interface{}) interface{}  {
    // given a sorted arrays of trades (recent last) and a timeframe builds an array of OHLCV candles
    // note, default limit value (2147483647) is max int32 value
    timeframe := GetArg(optionalArgs, 1, "1m")
    _ = timeframe
    since := GetArg(optionalArgs, 2, 0)
    _ = since
    limit := GetArg(optionalArgs, 3, 2147483647)
    _ = limit
    ms := Multiply(this.parseTimeframe(timeframe), 1000)
    ohlcvs := []interface{}{}
    i_timestamp := 0
    // const open = 1;
    i_high := 2
    i_low := 3
    i_close := 4
    i_volume := 5
    i_count := 6
    tradesLength := GetArrayLength(trades)
    oldest := mathMin(tradesLength, limit)
    for i := 0; IsLessThan(i, oldest); i++ {
        trade := GetValue(trades, i)
        ts := GetValue(trade, "timestamp")
        if IsTrue(IsLessThan(ts, since)) {
            continue
        }
        openingTime := Multiply(MathFloor(Divide(ts, ms)), ms) // shift to the edge of m/h/d (but not M)
        if IsTrue(IsLessThan(openingTime, since)) {
            continue
        }
        ohlcv_length := GetArrayLength(ohlcvs)
        candle := Subtract(ohlcv_length, 1)
        if IsTrue(IsTrue((IsEqual(candle, -1))) || IsTrue((IsGreaterThanOrEqual(openingTime, this.sum(GetValue(GetValue(ohlcvs, candle), i_timestamp), ms))))) {
            // moved to a new timeframe -> create a new candle from opening trade
            ohlcvs = AppendToArray(ohlcvs,[]interface{}{openingTime, GetValue(trade, "price"), GetValue(trade, "price"), GetValue(trade, "price"), GetValue(trade, "price"), GetValue(trade, "amount"), 1}).([]interface{})
        } else {
            // still processing the same timeframe -> update opening trade
            AddElementToObject(GetValue(ohlcvs, candle), i_high, mathMax(GetValue(GetValue(ohlcvs, candle), i_high), GetValue(trade, "price")))
            AddElementToObject(GetValue(ohlcvs, candle), i_low, mathMin(GetValue(GetValue(ohlcvs, candle), i_low), GetValue(trade, "price")))
            AddElementToObject(GetValue(ohlcvs, candle), i_close, GetValue(trade, "price"))
            AddElementToObject(GetValue(ohlcvs, candle), i_volume, this.sum(GetValue(GetValue(ohlcvs, candle), i_volume), GetValue(trade, "amount")))
            AddElementToObject(GetValue(ohlcvs, candle), i_count, this.sum(GetValue(GetValue(ohlcvs, candle), i_count), 1))
        }
    }
    return ohlcvs
}
func  (this *Exchange) parseTradingViewOHLCV(ohlcvs interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    timeframe := GetArg(optionalArgs, 2, "1m")
    _ = timeframe
    since := GetArg(optionalArgs, 3, nil)
    _ = since
    limit := GetArg(optionalArgs, 4, nil)
    _ = limit
    result := this.convertTradingViewToOHLCV(ohlcvs)
    return this.parseOHLCVs(result, market, timeframe, since, limit)
}
func  (this *Exchange) editLimitBuyOrder(id string, symbol string, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 3, nil)
    _ = price
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    return this.editLimitOrder(id, symbol, "buy", amount, price, params)
}
func  (this *Exchange) editLimitSellOrder(id string, symbol string, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 3, nil)
    _ = price
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    return this.editLimitOrder(id, symbol, "sell", amount, price, params)
}
func  (this *Exchange) editLimitOrder(id string, symbol string, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    params := GetArg(optionalArgs, 5, map[string]interface{} {})
    _ = params
    return this.editOrder(id, symbol, "limit", side, amount, price, params)
}
func  (this *Exchange) editOrder(id string, symbol string, typeVar interface{}, side interface{}, optionalArgs ...interface{}) interface{}  {
    amount := GetArg(optionalArgs, 4, nil)
    _ = amount
    price := GetArg(optionalArgs, 5, nil)
    _ = price
    params := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = params
    this.cancelOrder(id, symbol)
    return this.createOrder(symbol, typeVar, side, amount, price, params)
}
func  (this *Exchange) editOrderWs(id string, symbol string, typeVar interface{}, side interface{}, optionalArgs ...interface{}) interface{}  {
    amount := GetArg(optionalArgs, 4, nil)
    _ = amount
    price := GetArg(optionalArgs, 5, nil)
    _ = price
    params := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = params
    this.cancelOrderWs(id, symbol)
    return this.createOrderWs(symbol, typeVar, side, amount, price, params)
}
func  (this *Exchange) fetchPermissions(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchPermissions() is not supported yet")))
}
func  (this *Exchange) fetchPosition(symbol string, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchPosition() is not supported yet")))
}
func  (this *Exchange) fetchPositionWs(symbol string, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchPositionWs() is not supported yet")))
}
func  (this *Exchange) watchPosition(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchPosition() is not supported yet")))
}
func  (this *Exchange) watchPositions(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchPositions() is not supported yet")))
}
func  (this *Exchange) watchPositionForSymbols(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    return this.watchPositions(symbols, since, limit, params)
}
func  (this *Exchange) fetchPositionsForSymbol(symbol string, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchPositionsForSymbol() is not supported yet")))
}
func  (this *Exchange) fetchPositionsForSymbolWs(symbol string, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchPositionsForSymbol() is not supported yet")))
}
func  (this *Exchange) fetchPositions(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchPositions() is not supported yet")))
}
func  (this *Exchange) fetchPositionsWs(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchPositions() is not supported yet")))
}
func  (this *Exchange) fetchPositionsRisk(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchPositionsRisk() is not supported yet")))
}
func  (this *Exchange) fetchBidsAsks(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchBidsAsks() is not supported yet")))
}
func  (this *Exchange) fetchBorrowInterest(optionalArgs ...interface{}) interface{}  {
    code := GetArg(optionalArgs, 0, nil)
    _ = code
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchBorrowInterest() is not supported yet")))
}
func  (this *Exchange) fetchLedger(optionalArgs ...interface{}) interface{}  {
    code := GetArg(optionalArgs, 0, nil)
    _ = code
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchLedger() is not supported yet")))
}
func  (this *Exchange) fetchLedgerEntry(id string, optionalArgs ...interface{}) interface{}  {
    code := GetArg(optionalArgs, 1, nil)
    _ = code
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchLedgerEntry() is not supported yet")))
}
func  (this *Exchange) parseBidAsk(bidask interface{}, optionalArgs ...interface{}) interface{}  {
    priceKey := GetArg(optionalArgs, 1, 0)
    _ = priceKey
    amountKey := GetArg(optionalArgs, 2, 1)
    _ = amountKey
    countOrIdKey := GetArg(optionalArgs, 3, 2)
    _ = countOrIdKey
    price := this.safeNumber(bidask, priceKey)
    amount := this.safeNumber(bidask, amountKey)
    countOrId := this.safeInteger(bidask, countOrIdKey)
    bidAsk := []interface{}{price, amount}
    if IsTrue(!IsEqual(countOrId, nil)) {
        bidAsk = AppendToArray(bidAsk,countOrId).([]interface{})
    }
    return bidAsk
}
func  (this *Exchange) safeCurrency(currencyId interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 1, nil)
    _ = currency
    if IsTrue(IsTrue((IsEqual(currencyId, nil))) && IsTrue((!IsEqual(currency, nil)))) {
        return currency
    }
    if IsTrue(IsTrue(IsTrue((!IsEqual(this.currencies_by_id, nil))) && IsTrue((InOp(this.currencies_by_id, currencyId)))) && IsTrue((!IsEqual(GetValue(this.currencies_by_id, currencyId), nil)))) {
        return GetValue(this.currencies_by_id, currencyId)
    }
    code := currencyId
    if IsTrue(!IsEqual(currencyId, nil)) {
        code = this.commonCurrencyCode(ToUpper(currencyId))
    }
    return this.safeCurrencyStructure(map[string]interface{} {
        "id": currencyId,
        "code": code,
        "precision": nil,
    })
}
func  (this *Exchange) safeMarket(marketId interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    delimiter := GetArg(optionalArgs, 2, nil)
    _ = delimiter
    marketType := GetArg(optionalArgs, 3, nil)
    _ = marketType
    result := this.safeMarketStructure(map[string]interface{} {
        "symbol": marketId,
        "marketId": marketId,
    })
    if IsTrue(!IsEqual(marketId, nil)) {
        if IsTrue(IsTrue((!IsEqual(this.markets_by_id, nil))) && IsTrue((InOp(this.markets_by_id, marketId)))) {
            markets := GetValue(this.markets_by_id, marketId)
            numMarkets := GetArrayLength(markets)
            if IsTrue(IsEqual(numMarkets, 1)) {
                return GetValue(markets, 0)
            } else {
                if IsTrue(IsEqual(marketType, nil)) {
                    if IsTrue(IsEqual(market, nil)) {
                        panic(ArgumentsRequired(Add(Add(Add(this.id, " safeMarket() requires a fourth argument for "), marketId), " to disambiguate between different markets with the same market id")))
                    } else {
                        marketType = GetValue(market, "type")
                    }
                }
                for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
                    currentMarket := GetValue(markets, i)
                    if IsTrue(GetValue(currentMarket, marketType)) {
                        return currentMarket
                    }
                }
            }
        } else if IsTrue(IsTrue(!IsEqual(delimiter, nil)) && IsTrue(!IsEqual(delimiter, ""))) {
            parts := Split(marketId, delimiter)
            partsLength := GetArrayLength(parts)
            if IsTrue(IsEqual(partsLength, 2)) {
                AddElementToObject(result, "baseId", this.safeString(parts, 0))
                AddElementToObject(result, "quoteId", this.safeString(parts, 1))
                AddElementToObject(result, "base", this.safeCurrencyCode(GetValue(result, "baseId")))
                AddElementToObject(result, "quote", this.safeCurrencyCode(GetValue(result, "quoteId")))
                AddElementToObject(result, "symbol", Add(Add(GetValue(result, "base"), "/"), GetValue(result, "quote")))
                return result
            } else {
                return result
            }
        }
    }
    if IsTrue(!IsEqual(market, nil)) {
        return market
    }
    return result
}
func  (this *Exchange) checkRequiredCredentials(optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @param {boolean} error throw an error that a credential is required if true
    * @returns {boolean} true if all required credentials have been set, otherwise false or an error is thrown is param error=true
    */
    error := GetArg(optionalArgs, 0, true)
    _ = error
    keys := ObjectKeys(this.requiredCredentials)
    for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
        key := GetValue(keys, i)
        if IsTrue(IsTrue(GetValue(this.requiredCredentials, key)) && !IsTrue(GetValue(this, key))) {
            if IsTrue(error) {
                panic(AuthenticationError(Add(Add(Add(this.id, " requires \""), key), "\" credential")))
            } else {
                return false
            }
        }
    }
    return true
}
func  (this *Exchange) oath() interface{}  {
    if IsTrue(!IsEqual(this.twofa, nil)) {
        return totp(this.twofa)
    } else {
        panic(ExchangeError(Add(this.id, " exchange.twofa has not been set for 2FA Two-Factor Authentication")))
    }
}
func  (this *Exchange) fetchBalance(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchBalance() is not supported yet")))
}
func  (this *Exchange) fetchBalanceWs(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchBalanceWs() is not supported yet")))
}
func  (this *Exchange) parseBalance(response interface{}) interface{}  {
    panic(NotSupported(Add(this.id, " parseBalance() is not supported yet")))
}
func  (this *Exchange) watchBalance(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchBalance() is not supported yet")))
}
func  (this *Exchange) fetchPartialBalance(part interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    balance := this.fetchBalance(params)
    return GetValue(balance, part)
}
func  (this *Exchange) fetchFreeBalance(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    return this.fetchPartialBalance("free", params)
}
func  (this *Exchange) fetchUsedBalance(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    return this.fetchPartialBalance("used", params)
}
func  (this *Exchange) fetchTotalBalance(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    return this.fetchPartialBalance("total", params)
}
func  (this *Exchange) fetchStatus(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchStatus() is not supported yet")))
}
func  (this *Exchange) fetchTransactionFee(code string, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    if !IsTrue(GetValue(this.has, "fetchTransactionFees")) {
        panic(NotSupported(Add(this.id, " fetchTransactionFee() is not supported yet")))
    }
    return this.fetchTransactionFees([]interface{}{code}, params)
}
func  (this *Exchange) fetchTransactionFees(optionalArgs ...interface{}) interface{}  {
    codes := GetArg(optionalArgs, 0, nil)
    _ = codes
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchTransactionFees() is not supported yet")))
}
func  (this *Exchange) fetchDepositWithdrawFees(optionalArgs ...interface{}) interface{}  {
    codes := GetArg(optionalArgs, 0, nil)
    _ = codes
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchDepositWithdrawFees() is not supported yet")))
}
func  (this *Exchange) fetchDepositWithdrawFee(code string, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    if !IsTrue(GetValue(this.has, "fetchDepositWithdrawFees")) {
        panic(NotSupported(Add(this.id, " fetchDepositWithdrawFee() is not supported yet")))
    }
    fees := this.fetchDepositWithdrawFees([]interface{}{code}, params)
    return this.safeValue(fees, code)
}
func  (this *Exchange) getSupportedMapping(key interface{}, optionalArgs ...interface{}) interface{}  {
    mapping := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = mapping
    if IsTrue(InOp(mapping, key)) {
        return GetValue(mapping, key)
    } else {
        panic(NotSupported(Add(Add(Add(this.id, " "), key), " does not have a value in mapping")))
    }
}
func  (this *Exchange) fetchCrossBorrowRate(code string, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    this.loadMarkets()
    if !IsTrue(GetValue(this.has, "fetchBorrowRates")) {
        panic(NotSupported(Add(this.id, " fetchCrossBorrowRate() is not supported yet")))
    }
    borrowRates := this.fetchCrossBorrowRates(params)
    rate := this.safeValue(borrowRates, code)
    if IsTrue(IsEqual(rate, nil)) {
        panic(ExchangeError(Add(Add(this.id, " fetchCrossBorrowRate() could not find the borrow rate for currency code "), code)))
    }
    return rate
}
func  (this *Exchange) fetchIsolatedBorrowRate(symbol string, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    this.loadMarkets()
    if !IsTrue(GetValue(this.has, "fetchBorrowRates")) {
        panic(NotSupported(Add(this.id, " fetchIsolatedBorrowRate() is not supported yet")))
    }
    borrowRates := this.fetchIsolatedBorrowRates(params)
    rate := this.safeDict(borrowRates, symbol)
    if IsTrue(IsEqual(rate, nil)) {
        panic(ExchangeError(Add(Add(this.id, " fetchIsolatedBorrowRate() could not find the borrow rate for market symbol "), symbol)))
    }
    return rate
}
func  (this *Exchange) handleOptionAndParams(params interface{}, methodName string, optionName string, optionalArgs ...interface{}) interface{}  {
    // This method can be used to obtain method specific properties, i.e: this.handleOptionAndParams (params, 'fetchPosition', 'marginMode', 'isolated')
    defaultValue := GetArg(optionalArgs, 3, nil)
    _ = defaultValue
    defaultOptionName := Add("default", this.capitalize(optionName)) // we also need to check the 'defaultXyzWhatever'
    // check if params contain the key
    value := this.safeValue2(params, optionName, defaultOptionName)
    if IsTrue(!IsEqual(value, nil)) {
        params = this.omit(params, []interface{}{optionName, defaultOptionName})
    } else {
        // handle routed methods like "watchTrades > watchTradesForSymbols" (or "watchTicker > watchTickers")
        methodNameparamsVariable := this.handleParamString(params, "callerMethodName", methodName);
        methodName = GetValue(methodNameparamsVariable,0);
        params = GetValue(methodNameparamsVariable,1)
        // check if exchange has properties for this method
        exchangeWideMethodOptions := this.safeValue(this.options, methodName)
        if IsTrue(!IsEqual(exchangeWideMethodOptions, nil)) {
            // check if the option is defined inside this method's props
            value = this.safeValue2(exchangeWideMethodOptions, optionName, defaultOptionName)
        }
        if IsTrue(IsEqual(value, nil)) {
            // if it's still undefined, check if global exchange-wide option exists
            value = this.safeValue2(this.options, optionName, defaultOptionName)
        }
        // if it's still undefined, use the default value
        value = Ternary(IsTrue((!IsEqual(value, nil))), value, defaultValue)
    }
    return []interface{}{value, params}
}
func  (this *Exchange) handleOptionAndParams2(params interface{}, methodName1 string, optionName1 string, optionName2 string, optionalArgs ...interface{}) interface{}  {
    defaultValue := GetArg(optionalArgs, 4, nil)
    _ = defaultValue
    var value interface{} = nil
    valueparamsVariable := this.handleOptionAndParams(params, methodName1, optionName1, defaultValue);
    value = GetValue(valueparamsVariable,0);
    params = GetValue(valueparamsVariable,1)
    // if still undefined, try optionName2
    var value2 interface{} = nil
    value2paramsVariable := this.handleOptionAndParams(params, methodName1, optionName2, value);
    value2 = GetValue(value2paramsVariable,0);
    params = GetValue(value2paramsVariable,1)
    return []interface{}{value2, params}
}
func  (this *Exchange) handleOption(methodName string, optionName string, optionalArgs ...interface{}) interface{}  {
    // eslint-disable-next-line no-unused-vars
    defaultValue := GetArg(optionalArgs, 2, nil)
    _ = defaultValue
    resultemptyVariable := this.handleOptionAndParams(map[string]interface{} {}, methodName, optionName, defaultValue);
    result := GetValue(resultemptyVariable,0);
    empty := GetValue(resultemptyVariable,1)
    return result
}
func  (this *Exchange) handleMarketTypeAndParams(methodName string, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @name exchange#handleMarketTypeAndParams
    * @param methodName the method calling handleMarketTypeAndParams
    * @param {Market} market
    * @param {object} params
    * @param {string} [params.type] type assigned by user
    * @param {string} [params.defaultType] same as params.type
    * @param {string} [defaultValue] assigned programatically in the method calling handleMarketTypeAndParams
    * @returns {[string, object]} the market type and params with type and defaultType omitted
    */
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    defaultValue := GetArg(optionalArgs, 3, nil)
    _ = defaultValue
    defaultType := this.safeString2(this.options, "defaultType", "type", "spot")
    if IsTrue(IsEqual(defaultValue, nil)) {
        defaultValue = defaultType
    }
    methodOptions := this.safeDict(this.options, methodName)
    methodType := defaultValue
    if IsTrue(!IsEqual(methodOptions, nil)) {
        if IsTrue(IsString(methodOptions)) {
            methodType = methodOptions
        } else {
            methodType = this.safeString2(methodOptions, "defaultType", "type", methodType)
        }
    }
    marketType := Ternary(IsTrue((IsEqual(market, nil))), methodType, GetValue(market, "type"))
    typeVar := this.safeString2(params, "defaultType", "type", marketType)
    params = this.omit(params, []interface{}{"defaultType", "type"})
    return []interface{}{typeVar, params}
}
func  (this *Exchange) handleSubTypeAndParams(methodName string, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    defaultValue := GetArg(optionalArgs, 3, nil)
    _ = defaultValue
    var subType interface{} = nil
    // if set in params, it takes precedence
    subTypeInParams := this.safeString2(params, "subType", "defaultSubType")
    // avoid omitting if it's not present
    if IsTrue(!IsEqual(subTypeInParams, nil)) {
        subType = subTypeInParams
        params = this.omit(params, []interface{}{"subType", "defaultSubType"})
    } else {
        // at first, check from market object
        if IsTrue(!IsEqual(market, nil)) {
            if IsTrue(GetValue(market, "linear")) {
                subType = "linear"
            } else if IsTrue(GetValue(market, "inverse")) {
                subType = "inverse"
            }
        }
        // if it was not defined in market object
        if IsTrue(IsEqual(subType, nil)) {
            values := this.handleOptionAndParams(map[string]interface{} {}, methodName, "subType", defaultValue) // no need to re-test params here
            subType = GetValue(values, 0)
        }
    }
    return []interface{}{subType, params}
}
func  (this *Exchange) handleMarginModeAndParams(methodName string, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {Array} the marginMode in lowercase as specified by params["marginMode"], params["defaultMarginMode"] this.options["marginMode"] or this.options["defaultMarginMode"]
    */
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    defaultValue := GetArg(optionalArgs, 2, nil)
    _ = defaultValue
    return this.handleOptionAndParams(params, methodName, "marginMode", defaultValue)
}
func  (this *Exchange) throwExactlyMatchedException(exact interface{}, string interface{}, message interface{})  {
    if IsTrue(IsEqual(string, nil)) {
        return
    }
    if IsTrue(InOp(exact, string)) {
        throwDynamicException(GetValue(exact, string), message);
    }
}
func  (this *Exchange) throwBroadlyMatchedException(broad interface{}, string interface{}, message interface{})  {
    broadKey := this.findBroadlyMatchedKey(broad, string)
    if IsTrue(!IsEqual(broadKey, nil)) {
        throwDynamicException(GetValue(broad, broadKey), message);
    }
}
func  (this *Exchange) findBroadlyMatchedKey(broad interface{}, string interface{}) interface{}  {
    // a helper for matching error strings exactly vs broadly
    keys := ObjectKeys(broad)
    for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
        key := GetValue(keys, i)
        if IsTrue(!IsEqual(string, nil)) {
            if IsTrue(IsGreaterThanOrEqual(GetIndexOf(string, key), 0)) {
                return key
            }
        }
    }
    return nil
}
func  (this *Exchange) handleErrors(statusCode interface{}, statusText string, url string, method string, responseHeaders interface{}, responseBody string, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    // it is a stub method that must be overrided in the derived exchange classes
    // throw new NotSupported (this.id + ' handleErrors() not implemented yet');
    return nil
}
func  (this *Exchange) calculateRateLimiterCost(api interface{}, method interface{}, path interface{}, params interface{}, optionalArgs ...interface{}) interface{}  {
    config := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = config
    return this.safeValue(config, "cost", 1)
}
func  (this *Exchange) fetchTicker(symbol string, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchTickers")) {
        this.loadMarkets()
        market := this.market(symbol)
        symbol = GetValue(market, "symbol")
        tickers := this.fetchTickers([]interface{}{symbol}, params)
        ticker := this.safeDict(tickers, symbol)
        if IsTrue(IsEqual(ticker, nil)) {
            panic(NullResponse(Add(Add(this.id, " fetchTickers() could not find a ticker for "), symbol)))
        } else {
            return ticker
        }
    } else {
        panic(NotSupported(Add(this.id, " fetchTicker() is not supported yet")))
    }
}
func  (this *Exchange) fetchTickerWs(symbol string, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchTickersWs")) {
        this.loadMarkets()
        market := this.market(symbol)
        symbol = GetValue(market, "symbol")
        tickers := this.fetchTickerWs(symbol, params)
        ticker := this.safeDict(tickers, symbol)
        if IsTrue(IsEqual(ticker, nil)) {
            panic(NullResponse(Add(Add(this.id, " fetchTickers() could not find a ticker for "), symbol)))
        } else {
            return ticker
        }
    } else {
        panic(NotSupported(Add(this.id, " fetchTicker() is not supported yet")))
    }
}
func  (this *Exchange) watchTicker(symbol string, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchTicker() is not supported yet")))
}
func  (this *Exchange) fetchTickers(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchTickers() is not supported yet")))
}
func  (this *Exchange) fetchTickersWs(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchTickers() is not supported yet")))
}
func  (this *Exchange) fetchOrderBooks(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    limit := GetArg(optionalArgs, 1, nil)
    _ = limit
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchOrderBooks() is not supported yet")))
}
func  (this *Exchange) watchBidsAsks(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchBidsAsks() is not supported yet")))
}
func  (this *Exchange) watchTickers(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchTickers() is not supported yet")))
}
func  (this *Exchange) fetchOrder(id string, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchOrder() is not supported yet")))
}
func  (this *Exchange) fetchOrderWs(id string, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchOrderWs() is not supported yet")))
}
func  (this *Exchange) fetchOrderStatus(id string, optionalArgs ...interface{}) interface{}  {
    // TODO: TypeScript: change method signature by replacing
    // Promise<string> with Promise<Order['status']>.
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    order := this.fetchOrder(id, symbol, params)
    return GetValue(order, "status")
}
func  (this *Exchange) fetchUnifiedOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    return this.fetchOrder(this.safeString(order, "id"), this.safeString(order, "symbol"), params)
}
func  (this *Exchange) createOrder(symbol string, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    params := GetArg(optionalArgs, 5, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " createOrder() is not supported yet")))
}
func  (this *Exchange) createTrailingAmountOrder(symbol string, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createTrailingAmountOrder
    * @description create a trailing order by providing the symbol, type, side, amount, price and trailingAmount
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency, or number of contracts
    * @param {float} [price] the price for the order to be filled at, in units of the quote currency, ignored in market orders
    * @param {float} trailingAmount the quote amount to trail away from the current market price
    * @param {float} [trailingTriggerPrice] the price to activate a trailing order, default uses the price argument
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    trailingAmount := GetArg(optionalArgs, 5, nil)
    _ = trailingAmount
    trailingTriggerPrice := GetArg(optionalArgs, 6, nil)
    _ = trailingTriggerPrice
    params := GetArg(optionalArgs, 7, map[string]interface{} {})
    _ = params
    if IsTrue(IsEqual(trailingAmount, nil)) {
        panic(ArgumentsRequired(Add(this.id, " createTrailingAmountOrder() requires a trailingAmount argument")))
    }
    AddElementToObject(params, "trailingAmount", trailingAmount)
    if IsTrue(!IsEqual(trailingTriggerPrice, nil)) {
        AddElementToObject(params, "trailingTriggerPrice", trailingTriggerPrice)
    }
    if IsTrue(GetValue(this.has, "createTrailingAmountOrder")) {
        return this.createOrder(symbol, typeVar, side, amount, price, params)
    }
    panic(NotSupported(Add(this.id, " createTrailingAmountOrder() is not supported yet")))
}
func  (this *Exchange) createTrailingAmountOrderWs(symbol string, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createTrailingAmountOrderWs
    * @description create a trailing order by providing the symbol, type, side, amount, price and trailingAmount
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency, or number of contracts
    * @param {float} [price] the price for the order to be filled at, in units of the quote currency, ignored in market orders
    * @param {float} trailingAmount the quote amount to trail away from the current market price
    * @param {float} [trailingTriggerPrice] the price to activate a trailing order, default uses the price argument
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    trailingAmount := GetArg(optionalArgs, 5, nil)
    _ = trailingAmount
    trailingTriggerPrice := GetArg(optionalArgs, 6, nil)
    _ = trailingTriggerPrice
    params := GetArg(optionalArgs, 7, map[string]interface{} {})
    _ = params
    if IsTrue(IsEqual(trailingAmount, nil)) {
        panic(ArgumentsRequired(Add(this.id, " createTrailingAmountOrderWs() requires a trailingAmount argument")))
    }
    AddElementToObject(params, "trailingAmount", trailingAmount)
    if IsTrue(!IsEqual(trailingTriggerPrice, nil)) {
        AddElementToObject(params, "trailingTriggerPrice", trailingTriggerPrice)
    }
    if IsTrue(GetValue(this.has, "createTrailingAmountOrderWs")) {
        return this.createOrderWs(symbol, typeVar, side, amount, price, params)
    }
    panic(NotSupported(Add(this.id, " createTrailingAmountOrderWs() is not supported yet")))
}
func  (this *Exchange) createTrailingPercentOrder(symbol string, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createTrailingPercentOrder
    * @description create a trailing order by providing the symbol, type, side, amount, price and trailingPercent
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency, or number of contracts
    * @param {float} [price] the price for the order to be filled at, in units of the quote currency, ignored in market orders
    * @param {float} trailingPercent the percent to trail away from the current market price
    * @param {float} [trailingTriggerPrice] the price to activate a trailing order, default uses the price argument
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    trailingPercent := GetArg(optionalArgs, 5, nil)
    _ = trailingPercent
    trailingTriggerPrice := GetArg(optionalArgs, 6, nil)
    _ = trailingTriggerPrice
    params := GetArg(optionalArgs, 7, map[string]interface{} {})
    _ = params
    if IsTrue(IsEqual(trailingPercent, nil)) {
        panic(ArgumentsRequired(Add(this.id, " createTrailingPercentOrder() requires a trailingPercent argument")))
    }
    AddElementToObject(params, "trailingPercent", trailingPercent)
    if IsTrue(!IsEqual(trailingTriggerPrice, nil)) {
        AddElementToObject(params, "trailingTriggerPrice", trailingTriggerPrice)
    }
    if IsTrue(GetValue(this.has, "createTrailingPercentOrder")) {
        return this.createOrder(symbol, typeVar, side, amount, price, params)
    }
    panic(NotSupported(Add(this.id, " createTrailingPercentOrder() is not supported yet")))
}
func  (this *Exchange) createTrailingPercentOrderWs(symbol string, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createTrailingPercentOrderWs
    * @description create a trailing order by providing the symbol, type, side, amount, price and trailingPercent
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency, or number of contracts
    * @param {float} [price] the price for the order to be filled at, in units of the quote currency, ignored in market orders
    * @param {float} trailingPercent the percent to trail away from the current market price
    * @param {float} [trailingTriggerPrice] the price to activate a trailing order, default uses the price argument
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    trailingPercent := GetArg(optionalArgs, 5, nil)
    _ = trailingPercent
    trailingTriggerPrice := GetArg(optionalArgs, 6, nil)
    _ = trailingTriggerPrice
    params := GetArg(optionalArgs, 7, map[string]interface{} {})
    _ = params
    if IsTrue(IsEqual(trailingPercent, nil)) {
        panic(ArgumentsRequired(Add(this.id, " createTrailingPercentOrderWs() requires a trailingPercent argument")))
    }
    AddElementToObject(params, "trailingPercent", trailingPercent)
    if IsTrue(!IsEqual(trailingTriggerPrice, nil)) {
        AddElementToObject(params, "trailingTriggerPrice", trailingTriggerPrice)
    }
    if IsTrue(GetValue(this.has, "createTrailingPercentOrderWs")) {
        return this.createOrderWs(symbol, typeVar, side, amount, price, params)
    }
    panic(NotSupported(Add(this.id, " createTrailingPercentOrderWs() is not supported yet")))
}
func  (this *Exchange) createMarketOrderWithCost(symbol string, side interface{}, cost interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createMarketOrderWithCost
    * @description create a market order by providing the symbol, side and cost
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} side 'buy' or 'sell'
    * @param {float} cost how much you want to trade in units of the quote currency
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    if IsTrue(IsTrue(GetValue(this.has, "createMarketOrderWithCost")) || IsTrue((IsTrue(GetValue(this.has, "createMarketBuyOrderWithCost")) && IsTrue(GetValue(this.has, "createMarketSellOrderWithCost"))))) {
        return this.createOrder(symbol, "market", side, cost, 1, params)
    }
    panic(NotSupported(Add(this.id, " createMarketOrderWithCost() is not supported yet")))
}
func  (this *Exchange) createMarketBuyOrderWithCost(symbol string, cost interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createMarketBuyOrderWithCost
    * @description create a market buy order by providing the symbol and cost
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {float} cost how much you want to trade in units of the quote currency
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    if IsTrue(IsTrue(GetValue(this.options, "createMarketBuyOrderRequiresPrice")) || IsTrue(GetValue(this.has, "createMarketBuyOrderWithCost"))) {
        return this.createOrder(symbol, "market", "buy", cost, 1, params)
    }
    panic(NotSupported(Add(this.id, " createMarketBuyOrderWithCost() is not supported yet")))
}
func  (this *Exchange) createMarketSellOrderWithCost(symbol string, cost interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createMarketSellOrderWithCost
    * @description create a market sell order by providing the symbol and cost
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {float} cost how much you want to trade in units of the quote currency
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    if IsTrue(IsTrue(GetValue(this.options, "createMarketSellOrderRequiresPrice")) || IsTrue(GetValue(this.has, "createMarketSellOrderWithCost"))) {
        return this.createOrder(symbol, "market", "sell", cost, 1, params)
    }
    panic(NotSupported(Add(this.id, " createMarketSellOrderWithCost() is not supported yet")))
}
func  (this *Exchange) createMarketOrderWithCostWs(symbol string, side interface{}, cost interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createMarketOrderWithCostWs
    * @description create a market order by providing the symbol, side and cost
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} side 'buy' or 'sell'
    * @param {float} cost how much you want to trade in units of the quote currency
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    if IsTrue(IsTrue(GetValue(this.has, "createMarketOrderWithCostWs")) || IsTrue((IsTrue(GetValue(this.has, "createMarketBuyOrderWithCostWs")) && IsTrue(GetValue(this.has, "createMarketSellOrderWithCostWs"))))) {
        return this.createOrderWs(symbol, "market", side, cost, 1, params)
    }
    panic(NotSupported(Add(this.id, " createMarketOrderWithCostWs() is not supported yet")))
}
func  (this *Exchange) createTriggerOrder(symbol string, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createTriggerOrder
    * @description create a trigger stop order (type 1)
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency or the number of contracts
    * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
    * @param {float} triggerPrice the price to trigger the stop order, in units of the quote currency
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    triggerPrice := GetArg(optionalArgs, 5, nil)
    _ = triggerPrice
    params := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = params
    if IsTrue(IsEqual(triggerPrice, nil)) {
        panic(ArgumentsRequired(Add(this.id, " createTriggerOrder() requires a triggerPrice argument")))
    }
    AddElementToObject(params, "triggerPrice", triggerPrice)
    if IsTrue(GetValue(this.has, "createTriggerOrder")) {
        return this.createOrder(symbol, typeVar, side, amount, price, params)
    }
    panic(NotSupported(Add(this.id, " createTriggerOrder() is not supported yet")))
}
func  (this *Exchange) createTriggerOrderWs(symbol string, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createTriggerOrderWs
    * @description create a trigger stop order (type 1)
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency or the number of contracts
    * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
    * @param {float} triggerPrice the price to trigger the stop order, in units of the quote currency
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    triggerPrice := GetArg(optionalArgs, 5, nil)
    _ = triggerPrice
    params := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = params
    if IsTrue(IsEqual(triggerPrice, nil)) {
        panic(ArgumentsRequired(Add(this.id, " createTriggerOrderWs() requires a triggerPrice argument")))
    }
    AddElementToObject(params, "triggerPrice", triggerPrice)
    if IsTrue(GetValue(this.has, "createTriggerOrderWs")) {
        return this.createOrderWs(symbol, typeVar, side, amount, price, params)
    }
    panic(NotSupported(Add(this.id, " createTriggerOrderWs() is not supported yet")))
}
func  (this *Exchange) createStopLossOrder(symbol string, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createStopLossOrder
    * @description create a trigger stop loss order (type 2)
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency or the number of contracts
    * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
    * @param {float} stopLossPrice the price to trigger the stop loss order, in units of the quote currency
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    stopLossPrice := GetArg(optionalArgs, 5, nil)
    _ = stopLossPrice
    params := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = params
    if IsTrue(IsEqual(stopLossPrice, nil)) {
        panic(ArgumentsRequired(Add(this.id, " createStopLossOrder() requires a stopLossPrice argument")))
    }
    AddElementToObject(params, "stopLossPrice", stopLossPrice)
    if IsTrue(GetValue(this.has, "createStopLossOrder")) {
        return this.createOrder(symbol, typeVar, side, amount, price, params)
    }
    panic(NotSupported(Add(this.id, " createStopLossOrder() is not supported yet")))
}
func  (this *Exchange) createStopLossOrderWs(symbol string, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createStopLossOrderWs
    * @description create a trigger stop loss order (type 2)
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency or the number of contracts
    * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
    * @param {float} stopLossPrice the price to trigger the stop loss order, in units of the quote currency
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    stopLossPrice := GetArg(optionalArgs, 5, nil)
    _ = stopLossPrice
    params := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = params
    if IsTrue(IsEqual(stopLossPrice, nil)) {
        panic(ArgumentsRequired(Add(this.id, " createStopLossOrderWs() requires a stopLossPrice argument")))
    }
    AddElementToObject(params, "stopLossPrice", stopLossPrice)
    if IsTrue(GetValue(this.has, "createStopLossOrderWs")) {
        return this.createOrderWs(symbol, typeVar, side, amount, price, params)
    }
    panic(NotSupported(Add(this.id, " createStopLossOrderWs() is not supported yet")))
}
func  (this *Exchange) createTakeProfitOrder(symbol string, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createTakeProfitOrder
    * @description create a trigger take profit order (type 2)
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency or the number of contracts
    * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
    * @param {float} takeProfitPrice the price to trigger the take profit order, in units of the quote currency
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    takeProfitPrice := GetArg(optionalArgs, 5, nil)
    _ = takeProfitPrice
    params := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = params
    if IsTrue(IsEqual(takeProfitPrice, nil)) {
        panic(ArgumentsRequired(Add(this.id, " createTakeProfitOrder() requires a takeProfitPrice argument")))
    }
    AddElementToObject(params, "takeProfitPrice", takeProfitPrice)
    if IsTrue(GetValue(this.has, "createTakeProfitOrder")) {
        return this.createOrder(symbol, typeVar, side, amount, price, params)
    }
    panic(NotSupported(Add(this.id, " createTakeProfitOrder() is not supported yet")))
}
func  (this *Exchange) createTakeProfitOrderWs(symbol string, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createTakeProfitOrderWs
    * @description create a trigger take profit order (type 2)
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency or the number of contracts
    * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
    * @param {float} takeProfitPrice the price to trigger the take profit order, in units of the quote currency
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    takeProfitPrice := GetArg(optionalArgs, 5, nil)
    _ = takeProfitPrice
    params := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = params
    if IsTrue(IsEqual(takeProfitPrice, nil)) {
        panic(ArgumentsRequired(Add(this.id, " createTakeProfitOrderWs() requires a takeProfitPrice argument")))
    }
    AddElementToObject(params, "takeProfitPrice", takeProfitPrice)
    if IsTrue(GetValue(this.has, "createTakeProfitOrderWs")) {
        return this.createOrderWs(symbol, typeVar, side, amount, price, params)
    }
    panic(NotSupported(Add(this.id, " createTakeProfitOrderWs() is not supported yet")))
}
func  (this *Exchange) createOrderWithTakeProfitAndStopLoss(symbol string, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createOrderWithTakeProfitAndStopLoss
    * @description create an order with a stop loss or take profit attached (type 3)
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency or the number of contracts
    * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
    * @param {float} [takeProfit] the take profit price, in units of the quote currency
    * @param {float} [stopLoss] the stop loss price, in units of the quote currency
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @param {string} [params.takeProfitType] *not available on all exchanges* 'limit' or 'market'
    * @param {string} [params.stopLossType] *not available on all exchanges* 'limit' or 'market'
    * @param {string} [params.takeProfitPriceType] *not available on all exchanges* 'last', 'mark' or 'index'
    * @param {string} [params.stopLossPriceType] *not available on all exchanges* 'last', 'mark' or 'index'
    * @param {float} [params.takeProfitLimitPrice] *not available on all exchanges* limit price for a limit take profit order
    * @param {float} [params.stopLossLimitPrice] *not available on all exchanges* stop loss for a limit stop loss order
    * @param {float} [params.takeProfitAmount] *not available on all exchanges* the amount for a take profit
    * @param {float} [params.stopLossAmount] *not available on all exchanges* the amount for a stop loss
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    takeProfit := GetArg(optionalArgs, 5, nil)
    _ = takeProfit
    stopLoss := GetArg(optionalArgs, 6, nil)
    _ = stopLoss
    params := GetArg(optionalArgs, 7, map[string]interface{} {})
    _ = params
    params = this.setTakeProfitAndStopLossParams(symbol, typeVar, side, amount, price, takeProfit, stopLoss, params)
    if IsTrue(GetValue(this.has, "createOrderWithTakeProfitAndStopLoss")) {
        return this.createOrder(symbol, typeVar, side, amount, price, params)
    }
    panic(NotSupported(Add(this.id, " createOrderWithTakeProfitAndStopLoss() is not supported yet")))
}
func  (this *Exchange) setTakeProfitAndStopLossParams(symbol string, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    takeProfit := GetArg(optionalArgs, 5, nil)
    _ = takeProfit
    stopLoss := GetArg(optionalArgs, 6, nil)
    _ = stopLoss
    params := GetArg(optionalArgs, 7, map[string]interface{} {})
    _ = params
    if IsTrue(IsTrue((IsEqual(takeProfit, nil))) && IsTrue((IsEqual(stopLoss, nil)))) {
        panic(ArgumentsRequired(Add(this.id, " createOrderWithTakeProfitAndStopLoss() requires either a takeProfit or stopLoss argument")))
    }
    if IsTrue(!IsEqual(takeProfit, nil)) {
        AddElementToObject(params, "takeProfit", map[string]interface{} {
    "triggerPrice": takeProfit,
})
    }
    if IsTrue(!IsEqual(stopLoss, nil)) {
        AddElementToObject(params, "stopLoss", map[string]interface{} {
    "triggerPrice": stopLoss,
})
    }
    takeProfitType := this.safeString(params, "takeProfitType")
    takeProfitPriceType := this.safeString(params, "takeProfitPriceType")
    takeProfitLimitPrice := this.safeString(params, "takeProfitLimitPrice")
    takeProfitAmount := this.safeString(params, "takeProfitAmount")
    stopLossType := this.safeString(params, "stopLossType")
    stopLossPriceType := this.safeString(params, "stopLossPriceType")
    stopLossLimitPrice := this.safeString(params, "stopLossLimitPrice")
    stopLossAmount := this.safeString(params, "stopLossAmount")
    if IsTrue(!IsEqual(takeProfitType, nil)) {
        AddElementToObject(GetValue(params, "takeProfit"), "type", takeProfitType)
    }
    if IsTrue(!IsEqual(takeProfitPriceType, nil)) {
        AddElementToObject(GetValue(params, "takeProfit"), "priceType", takeProfitPriceType)
    }
    if IsTrue(!IsEqual(takeProfitLimitPrice, nil)) {
        AddElementToObject(GetValue(params, "takeProfit"), "price", this.parseToNumeric(takeProfitLimitPrice))
    }
    if IsTrue(!IsEqual(takeProfitAmount, nil)) {
        AddElementToObject(GetValue(params, "takeProfit"), "amount", this.parseToNumeric(takeProfitAmount))
    }
    if IsTrue(!IsEqual(stopLossType, nil)) {
        AddElementToObject(GetValue(params, "stopLoss"), "type", stopLossType)
    }
    if IsTrue(!IsEqual(stopLossPriceType, nil)) {
        AddElementToObject(GetValue(params, "stopLoss"), "priceType", stopLossPriceType)
    }
    if IsTrue(!IsEqual(stopLossLimitPrice, nil)) {
        AddElementToObject(GetValue(params, "stopLoss"), "price", this.parseToNumeric(stopLossLimitPrice))
    }
    if IsTrue(!IsEqual(stopLossAmount, nil)) {
        AddElementToObject(GetValue(params, "stopLoss"), "amount", this.parseToNumeric(stopLossAmount))
    }
    params = this.omit(params, []interface{}{"takeProfitType", "takeProfitPriceType", "takeProfitLimitPrice", "takeProfitAmount", "stopLossType", "stopLossPriceType", "stopLossLimitPrice", "stopLossAmount"})
    return params
}
func  (this *Exchange) createOrderWithTakeProfitAndStopLossWs(symbol string, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name createOrderWithTakeProfitAndStopLossWs
    * @description create an order with a stop loss or take profit attached (type 3)
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency or the number of contracts
    * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
    * @param {float} [takeProfit] the take profit price, in units of the quote currency
    * @param {float} [stopLoss] the stop loss price, in units of the quote currency
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @param {string} [params.takeProfitType] *not available on all exchanges* 'limit' or 'market'
    * @param {string} [params.stopLossType] *not available on all exchanges* 'limit' or 'market'
    * @param {string} [params.takeProfitPriceType] *not available on all exchanges* 'last', 'mark' or 'index'
    * @param {string} [params.stopLossPriceType] *not available on all exchanges* 'last', 'mark' or 'index'
    * @param {float} [params.takeProfitLimitPrice] *not available on all exchanges* limit price for a limit take profit order
    * @param {float} [params.stopLossLimitPrice] *not available on all exchanges* stop loss for a limit stop loss order
    * @param {float} [params.takeProfitAmount] *not available on all exchanges* the amount for a take profit
    * @param {float} [params.stopLossAmount] *not available on all exchanges* the amount for a stop loss
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    takeProfit := GetArg(optionalArgs, 5, nil)
    _ = takeProfit
    stopLoss := GetArg(optionalArgs, 6, nil)
    _ = stopLoss
    params := GetArg(optionalArgs, 7, map[string]interface{} {})
    _ = params
    params = this.setTakeProfitAndStopLossParams(symbol, typeVar, side, amount, price, takeProfit, stopLoss, params)
    if IsTrue(GetValue(this.has, "createOrderWithTakeProfitAndStopLossWs")) {
        return this.createOrderWs(symbol, typeVar, side, amount, price, params)
    }
    panic(NotSupported(Add(this.id, " createOrderWithTakeProfitAndStopLossWs() is not supported yet")))
}
func  (this *Exchange) createOrders(orders interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " createOrders() is not supported yet")))
}
func  (this *Exchange) createOrderWs(symbol string, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    params := GetArg(optionalArgs, 5, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " createOrderWs() is not supported yet")))
}
func  (this *Exchange) cancelOrder(id string, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " cancelOrder() is not supported yet")))
}
func  (this *Exchange) cancelOrderWs(id string, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " cancelOrderWs() is not supported yet")))
}
func  (this *Exchange) cancelOrdersWs(ids interface{}, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " cancelOrdersWs() is not supported yet")))
}
func  (this *Exchange) cancelAllOrders(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " cancelAllOrders() is not supported yet")))
}
func  (this *Exchange) cancelAllOrdersAfter(timeout interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " cancelAllOrdersAfter() is not supported yet")))
}
func  (this *Exchange) cancelOrdersForSymbols(orders interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " cancelOrdersForSymbols() is not supported yet")))
}
func  (this *Exchange) cancelAllOrdersWs(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " cancelAllOrdersWs() is not supported yet")))
}
func  (this *Exchange) cancelUnifiedOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    return this.cancelOrder(this.safeString(order, "id"), this.safeString(order, "symbol"), params)
}
func  (this *Exchange) fetchOrders(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    if IsTrue(IsTrue(GetValue(this.has, "fetchOpenOrders")) && IsTrue(GetValue(this.has, "fetchClosedOrders"))) {
        panic(NotSupported(Add(this.id, " fetchOrders() is not supported yet, consider using fetchOpenOrders() and fetchClosedOrders() instead")))
    }
    panic(NotSupported(Add(this.id, " fetchOrders() is not supported yet")))
}
func  (this *Exchange) fetchOrdersWs(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchOrdersWs() is not supported yet")))
}
func  (this *Exchange) fetchOrderTrades(id string, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchOrderTrades() is not supported yet")))
}
func  (this *Exchange) watchOrders(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchOrders() is not supported yet")))
}
func  (this *Exchange) fetchOpenOrders(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchOrders")) {
        orders := this.fetchOrders(symbol, since, limit, params)
        return this.filterBy(orders, "status", "open")
    }
    panic(NotSupported(Add(this.id, " fetchOpenOrders() is not supported yet")))
}
func  (this *Exchange) fetchOpenOrdersWs(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchOrdersWs")) {
        orders := this.fetchOrdersWs(symbol, since, limit, params)
        return this.filterBy(orders, "status", "open")
    }
    panic(NotSupported(Add(this.id, " fetchOpenOrdersWs() is not supported yet")))
}
func  (this *Exchange) fetchClosedOrders(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchOrders")) {
        orders := this.fetchOrders(symbol, since, limit, params)
        return this.filterBy(orders, "status", "closed")
    }
    panic(NotSupported(Add(this.id, " fetchClosedOrders() is not supported yet")))
}
func  (this *Exchange) fetchCanceledAndClosedOrders(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchCanceledAndClosedOrders() is not supported yet")))
}
func  (this *Exchange) fetchClosedOrdersWs(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchOrdersWs")) {
        orders := this.fetchOrdersWs(symbol, since, limit, params)
        return this.filterBy(orders, "status", "closed")
    }
    panic(NotSupported(Add(this.id, " fetchClosedOrdersWs() is not supported yet")))
}
func  (this *Exchange) fetchMyTrades(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchMyTrades() is not supported yet")))
}
func  (this *Exchange) fetchMyLiquidations(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchMyLiquidations() is not supported yet")))
}
func  (this *Exchange) fetchLiquidations(symbol string, optionalArgs ...interface{}) interface{}  {
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchLiquidations() is not supported yet")))
}
func  (this *Exchange) fetchMyTradesWs(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchMyTradesWs() is not supported yet")))
}
func  (this *Exchange) watchMyTrades(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " watchMyTrades() is not supported yet")))
}
func  (this *Exchange) fetchGreeks(symbol string, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchGreeks() is not supported yet")))
}
func  (this *Exchange) fetchOptionChain(code string, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchOptionChain() is not supported yet")))
}
func  (this *Exchange) fetchOption(symbol string, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchOption() is not supported yet")))
}
func  (this *Exchange) fetchConvertQuote(fromCode string, toCode string, optionalArgs ...interface{}) interface{}  {
    amount := GetArg(optionalArgs, 2, nil)
    _ = amount
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchConvertQuote() is not supported yet")))
}
func  (this *Exchange) fetchDepositsWithdrawals(optionalArgs ...interface{}) interface{}  {
    code := GetArg(optionalArgs, 0, nil)
    _ = code
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchDepositsWithdrawals() is not supported yet")))
}
func  (this *Exchange) fetchDeposits(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchDeposits() is not supported yet")))
}
func  (this *Exchange) fetchWithdrawals(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchWithdrawals() is not supported yet")))
}
func  (this *Exchange) fetchDepositsWs(optionalArgs ...interface{}) interface{}  {
    code := GetArg(optionalArgs, 0, nil)
    _ = code
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchDepositsWs() is not supported yet")))
}
func  (this *Exchange) fetchWithdrawalsWs(optionalArgs ...interface{}) interface{}  {
    code := GetArg(optionalArgs, 0, nil)
    _ = code
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchWithdrawalsWs() is not supported yet")))
}
func  (this *Exchange) fetchFundingRateHistory(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchFundingRateHistory() is not supported yet")))
}
func  (this *Exchange) fetchFundingHistory(optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 0, nil)
    _ = symbol
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchFundingHistory() is not supported yet")))
}
func  (this *Exchange) closePosition(symbol string, optionalArgs ...interface{}) interface{}  {
    side := GetArg(optionalArgs, 1, nil)
    _ = side
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " closePosition() is not supported yet")))
}
func  (this *Exchange) closeAllPositions(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " closeAllPositions() is not supported yet")))
}
func  (this *Exchange) fetchL3OrderBook(symbol string, optionalArgs ...interface{}) interface{}  {
    limit := GetArg(optionalArgs, 1, nil)
    _ = limit
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(BadRequest(Add(this.id, " fetchL3OrderBook() is not supported yet")))
}
func  (this *Exchange) parseLastPrice(price interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseLastPrice() is not supported yet")))
}
func  (this *Exchange) fetchDepositAddress(code string, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchDepositAddresses")) {
        depositAddresses := this.fetchDepositAddresses([]interface{}{code}, params)
        depositAddress := this.safeValue(depositAddresses, code)
        if IsTrue(IsEqual(depositAddress, nil)) {
            panic(InvalidAddress(Add(Add(Add(this.id, " fetchDepositAddress() could not find a deposit address for "), code), ", make sure you have created a corresponding deposit address in your wallet on the exchange website")))
        } else {
            return depositAddress
        }
    } else if IsTrue(GetValue(this.has, "fetchDepositAddressesByNetwork")) {
        network := this.safeString(params, "network")
        params = this.omit(params, "network")
        addressStructures := this.fetchDepositAddressesByNetwork(code, params)
        if IsTrue(!IsEqual(network, nil)) {
            return this.safeDict(addressStructures, network)
        } else {
            keys := ObjectKeys(addressStructures)
            key := this.safeString(keys, 0)
            return this.safeDict(addressStructures, key)
        }
    } else {
        panic(NotSupported(Add(this.id, " fetchDepositAddress() is not supported yet")))
    }
}
func  (this *Exchange) account() interface{}  {
    return map[string]interface{} {
        "free": nil,
        "used": nil,
        "total": nil,
    }
}
func  (this *Exchange) commonCurrencyCode(code string) interface{}  {
    if !IsTrue(this.substituteCommonCurrencyCodes) {
        return code
    }
    return this.safeString(this.commonCurrencies, code, code)
}
func  (this *Exchange) currency(code string) interface{}  {
    if IsTrue(IsEqual(this.currencies, nil)) {
        panic(ExchangeError(Add(this.id, " currencies not loaded")))
    }
    if IsTrue(IsString(code)) {
        if IsTrue(InOp(this.currencies, code)) {
            return GetValue(this.currencies, code)
        } else if IsTrue(InOp(this.currencies_by_id, code)) {
            return GetValue(this.currencies_by_id, code)
        }
    }
    panic(ExchangeError(Add(Add(this.id, " does not have currency code "), code)))
}
func  (this *Exchange) market(symbol string) interface{}  {
    if IsTrue(IsEqual(this.markets, nil)) {
        panic(ExchangeError(Add(this.id, " markets not loaded")))
    }
    if IsTrue(InOp(this.markets, symbol)) {
        return GetValue(this.markets, symbol)
    } else if IsTrue(InOp(this.markets_by_id, symbol)) {
        markets := GetValue(this.markets_by_id, symbol)
        defaultType := this.safeString2(this.options, "defaultType", "defaultSubType", "spot")
        for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
            market := GetValue(markets, i)
            if IsTrue(GetValue(market, defaultType)) {
                return market
            }
        }
        return GetValue(markets, 0)
    } else if IsTrue(IsTrue(IsTrue(IsTrue((EndsWith(symbol, "-C"))) || IsTrue((EndsWith(symbol, "-P")))) || IsTrue((StartsWith(symbol, "C-")))) || IsTrue((StartsWith(symbol, "P-")))) {
        return this.createExpiredOptionMarket(symbol)
    }
    panic(BadSymbol(Add(Add(this.id, " does not have market symbol "), symbol)))
}
func  (this *Exchange) createExpiredOptionMarket(symbol string) interface{}  {
    panic(NotSupported(Add(this.id, " createExpiredOptionMarket () is not supported yet")))
}
func  (this *Exchange) handleWithdrawTagAndParams(tag interface{}, params interface{}) interface{}  {
    if IsTrue(IsTrue((!IsEqual(tag, nil))) && IsTrue((IsObject(tag)))) {
        params = this.extend(tag, params)
        tag = nil
    }
    if IsTrue(IsEqual(tag, nil)) {
        tag = this.safeString(params, "tag")
        if IsTrue(!IsEqual(tag, nil)) {
            params = this.omit(params, "tag")
        }
    }
    return []interface{}{tag, params}
}
func  (this *Exchange) createLimitOrder(symbol string, side interface{}, amount interface{}, price interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    return this.createOrder(symbol, "limit", side, amount, price, params)
}
func  (this *Exchange) createLimitOrderWs(symbol string, side interface{}, amount interface{}, price interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    return this.createOrderWs(symbol, "limit", side, amount, price, params)
}
func  (this *Exchange) createMarketOrder(symbol string, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 3, nil)
    _ = price
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    return this.createOrder(symbol, "market", side, amount, price, params)
}
func  (this *Exchange) createMarketOrderWs(symbol string, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 3, nil)
    _ = price
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    return this.createOrderWs(symbol, "market", side, amount, price, params)
}
func  (this *Exchange) createLimitBuyOrder(symbol string, amount interface{}, price interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    return this.createOrder(symbol, "limit", "buy", amount, price, params)
}
func  (this *Exchange) createLimitBuyOrderWs(symbol string, amount interface{}, price interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    return this.createOrderWs(symbol, "limit", "buy", amount, price, params)
}
func  (this *Exchange) createLimitSellOrder(symbol string, amount interface{}, price interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    return this.createOrder(symbol, "limit", "sell", amount, price, params)
}
func  (this *Exchange) createLimitSellOrderWs(symbol string, amount interface{}, price interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    return this.createOrderWs(symbol, "limit", "sell", amount, price, params)
}
func  (this *Exchange) createMarketBuyOrder(symbol string, amount interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    return this.createOrder(symbol, "market", "buy", amount, nil, params)
}
func  (this *Exchange) createMarketBuyOrderWs(symbol string, amount interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    return this.createOrderWs(symbol, "market", "buy", amount, nil, params)
}
func  (this *Exchange) createMarketSellOrder(symbol string, amount interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    return this.createOrder(symbol, "market", "sell", amount, nil, params)
}
func  (this *Exchange) createMarketSellOrderWs(symbol string, amount interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    return this.createOrderWs(symbol, "market", "sell", amount, nil, params)
}
func  (this *Exchange) costToPrecision(symbol string, cost interface{}) interface{}  {
    market := this.market(symbol)
    return this.decimalToPrecision(cost, TRUNCATE, GetValue(GetValue(market, "precision"), "price"), this.precisionMode, this.paddingMode)
}
func  (this *Exchange) priceToPrecision(symbol string, price interface{}) interface{}  {
    market := this.market(symbol)
    result := this.decimalToPrecision(price, ROUND, GetValue(GetValue(market, "precision"), "price"), this.precisionMode, this.paddingMode)
    if IsTrue(IsEqual(result, "0")) {
        panic(InvalidOrder(Add(Add(Add(Add(this.id, " price of "), GetValue(market, "symbol")), " must be greater than minimum price precision of "), this.numberToString(GetValue(GetValue(market, "precision"), "price")))))
    }
    return result
}
func  (this *Exchange) amountToPrecision(symbol string, amount interface{}) interface{}  {
    market := this.market(symbol)
    result := this.decimalToPrecision(amount, TRUNCATE, GetValue(GetValue(market, "precision"), "amount"), this.precisionMode, this.paddingMode)
    if IsTrue(IsEqual(result, "0")) {
        panic(InvalidOrder(Add(Add(Add(Add(this.id, " amount of "), GetValue(market, "symbol")), " must be greater than minimum amount precision of "), this.numberToString(GetValue(GetValue(market, "precision"), "amount")))))
    }
    return result
}
func  (this *Exchange) feeToPrecision(symbol string, fee interface{}) interface{}  {
    market := this.market(symbol)
    return this.decimalToPrecision(fee, ROUND, GetValue(GetValue(market, "precision"), "price"), this.precisionMode, this.paddingMode)
}
func  (this *Exchange) currencyToPrecision(code string, fee interface{}, optionalArgs ...interface{}) interface{}  {
    networkCode := GetArg(optionalArgs, 2, nil)
    _ = networkCode
    currency := GetValue(this.currencies, code)
    precision := this.safeValue(currency, "precision")
    if IsTrue(!IsEqual(networkCode, nil)) {
        networks := this.safeDict(currency, "networks", map[string]interface{} {})
        networkItem := this.safeDict(networks, networkCode, map[string]interface{} {})
        precision = this.safeValue(networkItem, "precision", precision)
    }
    if IsTrue(IsEqual(precision, nil)) {
        return this.forceString(fee)
    } else {
        return this.decimalToPrecision(fee, ROUND, precision, this.precisionMode, this.paddingMode)
    }
}
func  (this *Exchange) forceString(value interface{}) interface{}  {
    if IsTrue(!IsString(value)) {
        return this.numberToString(value)
    }
    return value
}
func  (this *Exchange) isTickPrecision() interface{}  {
    return IsEqual(this.precisionMode, TICK_SIZE)
}
func  (this *Exchange) isDecimalPrecision() interface{}  {
    return IsEqual(this.precisionMode, DECIMAL_PLACES)
}
func  (this *Exchange) isSignificantPrecision() interface{}  {
    return IsEqual(this.precisionMode, SIGNIFICANT_DIGITS)
}
func  (this *Exchange) safeNumber(obj interface{}, key interface{}, optionalArgs ...interface{}) interface{}  {
    defaultNumber := GetArg(optionalArgs, 2, nil)
    _ = defaultNumber
    value := this.safeString(obj, key)
    return this.parseNumber(value, defaultNumber)
}
func  (this *Exchange) safeNumberN(obj interface{}, arr interface{}, optionalArgs ...interface{}) interface{}  {
    defaultNumber := GetArg(optionalArgs, 2, nil)
    _ = defaultNumber
    value := this.safeStringN(obj, arr)
    return this.parseNumber(value, defaultNumber)
}
func  (this *Exchange) parsePrecision(precision string) interface{}  {
    /**
     * @ignore
     * @method
     * @param {string} precision The number of digits to the right of the decimal
     * @returns {string} a string number equal to 1e-precision
     */
    if IsTrue(IsEqual(precision, nil)) {
        return nil
    }
    precisionNumber := parseInt(precision)
    if IsTrue(IsEqual(precisionNumber, 0)) {
        return "1"
    }
    parsedPrecision := "0."
    for i := 0; IsLessThan(i, Subtract(precisionNumber, 1)); i++ {
        parsedPrecision = Add(parsedPrecision, "0")
    }
    return Add(parsedPrecision, "1")
}
func  (this *Exchange) integerPrecisionToAmount(precision interface{}) interface{}  {
    /**
     * @ignore
     * @method
     * @description handles positive & negative numbers too. parsePrecision() does not handle negative numbers, but this method handles
     * @param {string} precision The number of digits to the right of the decimal
     * @returns {string} a string number equal to 1e-precision
     */
    if IsTrue(IsEqual(precision, nil)) {
        return nil
    }
    if IsTrue(Precise.stringGe(precision, "0")) {
        return this.parsePrecision(precision)
    } else {
        positivePrecisionString := Precise.stringAbs(precision)
        positivePrecision := parseInt(positivePrecisionString)
        parsedPrecision := "1"
        for i := 0; IsLessThan(i, Subtract(positivePrecision, 1)); i++ {
            parsedPrecision = Add(parsedPrecision, "0")
        }
        return Add(parsedPrecision, "0")
    }
}
func  (this *Exchange) loadTimeDifference(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    serverTime := this.fetchTime(params)
    after := this.milliseconds()
    AddElementToObject(this.options, "timeDifference", Subtract(after, serverTime))
    return GetValue(this.options, "timeDifference")
}
func  (this *Exchange) implodeHostname(url string) interface{}  {
    return this.implodeParams(url, map[string]interface{} {
        "hostname": this.hostname,
    })
}
func  (this *Exchange) fetchMarketLeverageTiers(symbol string, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchLeverageTiers")) {
        market := this.market(symbol)
        if !IsTrue(GetValue(market, "contract")) {
            panic(BadSymbol(Add(this.id, " fetchMarketLeverageTiers() supports contract markets only")))
        }
        tiers := this.fetchLeverageTiers([]interface{}{symbol})
        return this.safeValue(tiers, symbol)
    } else {
        panic(NotSupported(Add(this.id, " fetchMarketLeverageTiers() is not supported yet")))
    }
}
func  (this *Exchange) createPostOnlyOrder(symbol string, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    params := GetArg(optionalArgs, 5, map[string]interface{} {})
    _ = params
    if !IsTrue(GetValue(this.has, "createPostOnlyOrder")) {
        panic(NotSupported(Add(this.id, "createPostOnlyOrder() is not supported yet")))
    }
    query := this.extend(params, map[string]interface{} {
        "postOnly": true,
    })
    return this.createOrder(symbol, typeVar, side, amount, price, query)
}
func  (this *Exchange) createPostOnlyOrderWs(symbol string, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    params := GetArg(optionalArgs, 5, map[string]interface{} {})
    _ = params
    if !IsTrue(GetValue(this.has, "createPostOnlyOrderWs")) {
        panic(NotSupported(Add(this.id, "createPostOnlyOrderWs() is not supported yet")))
    }
    query := this.extend(params, map[string]interface{} {
        "postOnly": true,
    })
    return this.createOrderWs(symbol, typeVar, side, amount, price, query)
}
func  (this *Exchange) createReduceOnlyOrder(symbol string, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    params := GetArg(optionalArgs, 5, map[string]interface{} {})
    _ = params
    if !IsTrue(GetValue(this.has, "createReduceOnlyOrder")) {
        panic(NotSupported(Add(this.id, "createReduceOnlyOrder() is not supported yet")))
    }
    query := this.extend(params, map[string]interface{} {
        "reduceOnly": true,
    })
    return this.createOrder(symbol, typeVar, side, amount, price, query)
}
func  (this *Exchange) createReduceOnlyOrderWs(symbol string, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    params := GetArg(optionalArgs, 5, map[string]interface{} {})
    _ = params
    if !IsTrue(GetValue(this.has, "createReduceOnlyOrderWs")) {
        panic(NotSupported(Add(this.id, "createReduceOnlyOrderWs() is not supported yet")))
    }
    query := this.extend(params, map[string]interface{} {
        "reduceOnly": true,
    })
    return this.createOrderWs(symbol, typeVar, side, amount, price, query)
}
func  (this *Exchange) createStopOrder(symbol string, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    stopPrice := GetArg(optionalArgs, 5, nil)
    _ = stopPrice
    params := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = params
    if !IsTrue(GetValue(this.has, "createStopOrder")) {
        panic(NotSupported(Add(this.id, " createStopOrder() is not supported yet")))
    }
    if IsTrue(IsEqual(stopPrice, nil)) {
        panic(ArgumentsRequired(Add(this.id, " create_stop_order() requires a stopPrice argument")))
    }
    query := this.extend(params, map[string]interface{} {
        "stopPrice": stopPrice,
    })
    return this.createOrder(symbol, typeVar, side, amount, price, query)
}
func  (this *Exchange) createStopOrderWs(symbol string, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    stopPrice := GetArg(optionalArgs, 5, nil)
    _ = stopPrice
    params := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = params
    if !IsTrue(GetValue(this.has, "createStopOrderWs")) {
        panic(NotSupported(Add(this.id, " createStopOrderWs() is not supported yet")))
    }
    if IsTrue(IsEqual(stopPrice, nil)) {
        panic(ArgumentsRequired(Add(this.id, " createStopOrderWs() requires a stopPrice argument")))
    }
    query := this.extend(params, map[string]interface{} {
        "stopPrice": stopPrice,
    })
    return this.createOrderWs(symbol, typeVar, side, amount, price, query)
}
func  (this *Exchange) createStopLimitOrder(symbol string, side interface{}, amount interface{}, price interface{}, stopPrice interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 5, map[string]interface{} {})
    _ = params
    if !IsTrue(GetValue(this.has, "createStopLimitOrder")) {
        panic(NotSupported(Add(this.id, " createStopLimitOrder() is not supported yet")))
    }
    query := this.extend(params, map[string]interface{} {
        "stopPrice": stopPrice,
    })
    return this.createOrder(symbol, "limit", side, amount, price, query)
}
func  (this *Exchange) createStopLimitOrderWs(symbol string, side interface{}, amount interface{}, price interface{}, stopPrice interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 5, map[string]interface{} {})
    _ = params
    if !IsTrue(GetValue(this.has, "createStopLimitOrderWs")) {
        panic(NotSupported(Add(this.id, " createStopLimitOrderWs() is not supported yet")))
    }
    query := this.extend(params, map[string]interface{} {
        "stopPrice": stopPrice,
    })
    return this.createOrderWs(symbol, "limit", side, amount, price, query)
}
func  (this *Exchange) createStopMarketOrder(symbol string, side interface{}, amount interface{}, stopPrice interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    if !IsTrue(GetValue(this.has, "createStopMarketOrder")) {
        panic(NotSupported(Add(this.id, " createStopMarketOrder() is not supported yet")))
    }
    query := this.extend(params, map[string]interface{} {
        "stopPrice": stopPrice,
    })
    return this.createOrder(symbol, "market", side, amount, nil, query)
}
func  (this *Exchange) createStopMarketOrderWs(symbol string, side interface{}, amount interface{}, stopPrice interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    if !IsTrue(GetValue(this.has, "createStopMarketOrderWs")) {
        panic(NotSupported(Add(this.id, " createStopMarketOrderWs() is not supported yet")))
    }
    query := this.extend(params, map[string]interface{} {
        "stopPrice": stopPrice,
    })
    return this.createOrderWs(symbol, "market", side, amount, nil, query)
}
func  (this *Exchange) safeCurrencyCode(currencyId interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 1, nil)
    _ = currency
    currency = this.safeCurrency(currencyId, currency)
    return GetValue(currency, "code")
}
func  (this *Exchange) filterBySymbolSinceLimit(array interface{}, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    tail := GetArg(optionalArgs, 4, false)
    _ = tail
    return this.filterByValueSinceLimit(array, "symbol", symbol, since, limit, "timestamp", tail)
}
func  (this *Exchange) filterByCurrencySinceLimit(array interface{}, optionalArgs ...interface{}) interface{}  {
    code := GetArg(optionalArgs, 1, nil)
    _ = code
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    tail := GetArg(optionalArgs, 4, false)
    _ = tail
    return this.filterByValueSinceLimit(array, "currency", code, since, limit, "timestamp", tail)
}
func  (this *Exchange) filterBySymbolsSinceLimit(array interface{}, optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 1, nil)
    _ = symbols
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    tail := GetArg(optionalArgs, 4, false)
    _ = tail
    result := this.filterByArray(array, "symbol", symbols, false)
    return this.filterBySinceLimit(result, since, limit, "timestamp", tail)
}
func  (this *Exchange) parseLastPrices(pricesData interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // the value of tickers is either a dict or a list
    //
    // dict
    //
    //     {
    //         'marketId1': { ... },
    //         'marketId2': { ... },
    //         ...
    //     }
    //
    // list
    //
    //     [
    //         { 'market': 'marketId1', ... },
    //         { 'market': 'marketId2', ... },
    //         ...
    //     ]
    //
    symbols := GetArg(optionalArgs, 1, nil)
    _ = symbols
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    results := []interface{}{}
    if IsTrue(IsArray(pricesData)) {
        for i := 0; IsLessThan(i, GetArrayLength(pricesData)); i++ {
            priceData := this.extend(this.parseLastPrice(GetValue(pricesData, i)), params)
            results = AppendToArray(results,priceData).([]interface{})
        }
    } else {
        marketIds := ObjectKeys(pricesData)
        for i := 0; IsLessThan(i, GetArrayLength(marketIds)); i++ {
            marketId := GetValue(marketIds, i)
            market := this.safeMarket(marketId)
            priceData := this.extend(this.parseLastPrice(GetValue(pricesData, marketId), market), params)
            results = AppendToArray(results,priceData).([]interface{})
        }
    }
    symbols = this.marketSymbols(symbols)
    return this.filterByArray(results, "symbol", symbols)
}
func  (this *Exchange) parseTickers(tickers interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // the value of tickers is either a dict or a list
    //
    //
    // dict
    //
    //     {
    //         'marketId1': { ... },
    //         'marketId2': { ... },
    //         'marketId3': { ... },
    //         ...
    //     }
    //
    // list
    //
    //     [
    //         { 'market': 'marketId1', ... },
    //         { 'market': 'marketId2', ... },
    //         { 'market': 'marketId3', ... },
    //         ...
    //     ]
    //
    symbols := GetArg(optionalArgs, 1, nil)
    _ = symbols
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    results := []interface{}{}
    if IsTrue(IsArray(tickers)) {
        for i := 0; IsLessThan(i, GetArrayLength(tickers)); i++ {
            ticker := this.extend(this.parseTicker(GetValue(tickers, i)), params)
            results = AppendToArray(results,ticker).([]interface{})
        }
    } else {
        marketIds := ObjectKeys(tickers)
        for i := 0; IsLessThan(i, GetArrayLength(marketIds)); i++ {
            marketId := GetValue(marketIds, i)
            market := this.safeMarket(marketId)
            ticker := this.extend(this.parseTicker(GetValue(tickers, marketId), market), params)
            results = AppendToArray(results,ticker).([]interface{})
        }
    }
    symbols = this.marketSymbols(symbols)
    return this.filterByArray(results, "symbol", symbols)
}
func  (this *Exchange) parseDepositAddresses(addresses interface{}, optionalArgs ...interface{}) interface{}  {
    codes := GetArg(optionalArgs, 1, nil)
    _ = codes
    indexed := GetArg(optionalArgs, 2, true)
    _ = indexed
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(addresses)); i++ {
        address := this.extend(this.parseDepositAddress(GetValue(addresses, i)), params)
        result = AppendToArray(result,address).([]interface{})
    }
    if IsTrue(!IsEqual(codes, nil)) {
        result = this.filterByArray(result, "currency", codes, false)
    }
    if IsTrue(indexed) {
        return this.indexBy(result, "currency")
    }
    return result
}
func  (this *Exchange) parseBorrowInterests(response interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    interests := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        row := GetValue(response, i)
        interests = AppendToArray(interests,this.parseBorrowInterest(row, market)).([]interface{})
    }
    return interests
}
func  (this *Exchange) parseIsolatedBorrowRates(info interface{}) interface{}  {
    result := map[string]interface{} {}
    for i := 0; IsLessThan(i, GetArrayLength(info)); i++ {
        item := GetValue(info, i)
        borrowRate := this.parseIsolatedBorrowRate(item)
        symbol := this.safeString(borrowRate, "symbol")
        AddElementToObject(result, symbol, borrowRate)
    }
    return result
}
func  (this *Exchange) parseFundingRateHistories(response interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    rates := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        entry := GetValue(response, i)
        rates = AppendToArray(rates,this.parseFundingRateHistory(entry, market)).([]interface{})
    }
    sorted := this.sortBy(rates, "timestamp")
    symbol := Ternary(IsTrue((IsEqual(market, nil))), nil, GetValue(market, "symbol"))
    return this.filterBySymbolSinceLimit(sorted, symbol, since, limit)
}
func  (this *Exchange) safeSymbol(marketId interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    delimiter := GetArg(optionalArgs, 2, nil)
    _ = delimiter
    marketType := GetArg(optionalArgs, 3, nil)
    _ = marketType
    market = this.safeMarket(marketId, market, delimiter, marketType)
    return GetValue(market, "symbol")
}
func  (this *Exchange) parseFundingRate(contract string, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseFundingRate() is not supported yet")))
}
func  (this *Exchange) parseFundingRates(response interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    result := map[string]interface{} {}
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        parsed := this.parseFundingRate(GetValue(response, i), market)
        AddElementToObject(result, GetValue(parsed, "symbol"), parsed)
    }
    return result
}
func  (this *Exchange) handleTriggerAndParams(params interface{}) interface{}  {
    isTrigger := this.safeBool2(params, "trigger", "stop")
    if IsTrue(isTrigger) {
        params = this.omit(params, []interface{}{"trigger", "stop"})
    }
    return []interface{}{isTrigger, params}
}
func  (this *Exchange) isTriggerOrder(params interface{}) interface{}  {
    // for backwards compatibility
    return this.handleTriggerAndParams(params)
}
func  (this *Exchange) isPostOnly(isMarketOrder bool, exchangeSpecificParam interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @param {string} type Order type
    * @param {boolean} exchangeSpecificParam exchange specific postOnly
    * @param {object} [params] exchange specific params
    * @returns {boolean} true if a post only order, false otherwise
    */
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    timeInForce := this.safeStringUpper(params, "timeInForce")
    postOnly := this.safeBool2(params, "postOnly", "post_only", false)
    // we assume timeInForce is uppercase from safeStringUpper (params, 'timeInForce')
    ioc := IsEqual(timeInForce, "IOC")
    fok := IsEqual(timeInForce, "FOK")
    timeInForcePostOnly := IsEqual(timeInForce, "PO")
    postOnly = IsTrue(IsTrue(postOnly) || IsTrue(timeInForcePostOnly)) || IsTrue(exchangeSpecificParam)
    if IsTrue(postOnly) {
        if IsTrue(IsTrue(ioc) || IsTrue(fok)) {
            panic(InvalidOrder(Add(Add(this.id, " postOnly orders cannot have timeInForce equal to "), timeInForce)))
        } else if IsTrue(isMarketOrder) {
            panic(InvalidOrder(Add(this.id, " market orders cannot be postOnly")))
        } else {
            return true
        }
    } else {
        return false
    }
}
func  (this *Exchange) handlePostOnly(isMarketOrder bool, exchangeSpecificPostOnlyOption bool, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @param {string} type Order type
    * @param {boolean} exchangeSpecificBoolean exchange specific postOnly
    * @param {object} [params] exchange specific params
    * @returns {Array}
    */
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    timeInForce := this.safeStringUpper(params, "timeInForce")
    postOnly := this.safeBool(params, "postOnly", false)
    ioc := IsEqual(timeInForce, "IOC")
    fok := IsEqual(timeInForce, "FOK")
    po := IsEqual(timeInForce, "PO")
    postOnly = IsTrue(IsTrue(postOnly) || IsTrue(po)) || IsTrue(exchangeSpecificPostOnlyOption)
    if IsTrue(postOnly) {
        if IsTrue(IsTrue(ioc) || IsTrue(fok)) {
            panic(InvalidOrder(Add(Add(this.id, " postOnly orders cannot have timeInForce equal to "), timeInForce)))
        } else if IsTrue(isMarketOrder) {
            panic(InvalidOrder(Add(this.id, " market orders cannot be postOnly")))
        } else {
            if IsTrue(po) {
                params = this.omit(params, "timeInForce")
            }
            params = this.omit(params, "postOnly")
            return []interface{}{true, params}
        }
    }
    return []interface{}{false, params}
}
func  (this *Exchange) fetchLastPrices(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchLastPrices() is not supported yet")))
}
func  (this *Exchange) fetchTradingFees(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchTradingFees() is not supported yet")))
}
func  (this *Exchange) fetchTradingFeesWs(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchTradingFeesWs() is not supported yet")))
}
func  (this *Exchange) fetchTradingFee(symbol string, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    if !IsTrue(GetValue(this.has, "fetchTradingFees")) {
        panic(NotSupported(Add(this.id, " fetchTradingFee() is not supported yet")))
    }
    fees := this.fetchTradingFees(params)
    return this.safeDict(fees, symbol)
}
func  (this *Exchange) fetchConvertCurrencies(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchConvertCurrencies() is not supported yet")))
}
func  (this *Exchange) parseOpenInterest(interest interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseOpenInterest () is not supported yet")))
}
func  (this *Exchange) parseOpenInterests(response interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    interests := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        entry := GetValue(response, i)
        interest := this.parseOpenInterest(entry, market)
        interests = AppendToArray(interests,interest).([]interface{})
    }
    sorted := this.sortBy(interests, "timestamp")
    symbol := this.safeString(market, "symbol")
    return this.filterBySymbolSinceLimit(sorted, symbol, since, limit)
}
func  (this *Exchange) fetchFundingRate(symbol string, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchFundingRates")) {
        this.loadMarkets()
        market := this.market(symbol)
        symbol = GetValue(market, "symbol")
        if !IsTrue(GetValue(market, "contract")) {
            panic(BadSymbol(Add(this.id, " fetchFundingRate() supports contract markets only")))
        }
        rates := this.fetchFundingRates([]interface{}{symbol}, params)
        rate := this.safeValue(rates, symbol)
        if IsTrue(IsEqual(rate, nil)) {
            panic(NullResponse(Add(Add(this.id, " fetchFundingRate () returned no data for "), symbol)))
        } else {
            return rate
        }
    } else {
        panic(NotSupported(Add(this.id, " fetchFundingRate () is not supported yet")))
    }
}
func  (this *Exchange) fetchMarkOHLCV(symbol interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name exchange#fetchMarkOHLCV
    * @description fetches historical mark price candlestick data containing the open, high, low, and close price of a market
    * @param {string} symbol unified symbol of the market to fetch OHLCV data for
    * @param {string} timeframe the length of time each candle represents
    * @param {int} [since] timestamp in ms of the earliest candle to fetch
    * @param {int} [limit] the maximum amount of candles to fetch
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {float[][]} A list of candles ordered as timestamp, open, high, low, close, undefined
    */
    timeframe := GetArg(optionalArgs, 1, "1m")
    _ = timeframe
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchMarkOHLCV")) {
        request := map[string]interface{} {
            "price": "mark",
        }
        return this.fetchOHLCV(symbol, timeframe, since, limit, this.extend(request, params))
    } else {
        panic(NotSupported(Add(this.id, " fetchMarkOHLCV () is not supported yet")))
    }
}
func  (this *Exchange) fetchIndexOHLCV(symbol string, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name exchange#fetchIndexOHLCV
    * @description fetches historical index price candlestick data containing the open, high, low, and close price of a market
    * @param {string} symbol unified symbol of the market to fetch OHLCV data for
    * @param {string} timeframe the length of time each candle represents
    * @param {int} [since] timestamp in ms of the earliest candle to fetch
    * @param {int} [limit] the maximum amount of candles to fetch
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {} A list of candles ordered as timestamp, open, high, low, close, undefined
    */
    timeframe := GetArg(optionalArgs, 1, "1m")
    _ = timeframe
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchIndexOHLCV")) {
        request := map[string]interface{} {
            "price": "index",
        }
        return this.fetchOHLCV(symbol, timeframe, since, limit, this.extend(request, params))
    } else {
        panic(NotSupported(Add(this.id, " fetchIndexOHLCV () is not supported yet")))
    }
}
func  (this *Exchange) fetchPremiumIndexOHLCV(symbol string, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name exchange#fetchPremiumIndexOHLCV
    * @description fetches historical premium index price candlestick data containing the open, high, low, and close price of a market
    * @param {string} symbol unified symbol of the market to fetch OHLCV data for
    * @param {string} timeframe the length of time each candle represents
    * @param {int} [since] timestamp in ms of the earliest candle to fetch
    * @param {int} [limit] the maximum amount of candles to fetch
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {float[][]} A list of candles ordered as timestamp, open, high, low, close, undefined
    */
    timeframe := GetArg(optionalArgs, 1, "1m")
    _ = timeframe
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchPremiumIndexOHLCV")) {
        request := map[string]interface{} {
            "price": "premiumIndex",
        }
        return this.fetchOHLCV(symbol, timeframe, since, limit, this.extend(request, params))
    } else {
        panic(NotSupported(Add(this.id, " fetchPremiumIndexOHLCV () is not supported yet")))
    }
}
func  (this *Exchange) handleTimeInForce(optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * Must add timeInForce to this.options to use this method
    * @returns {string} returns the exchange specific value for timeInForce
    */
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    timeInForce := this.safeStringUpper(params, "timeInForce") // supported values GTC, IOC, PO
    if IsTrue(!IsEqual(timeInForce, nil)) {
        exchangeValue := this.safeString(GetValue(this.options, "timeInForce"), timeInForce)
        if IsTrue(IsEqual(exchangeValue, nil)) {
            panic(ExchangeError(Add(Add(Add(this.id, " does not support timeInForce \""), timeInForce), "\"")))
        }
        return exchangeValue
    }
    return nil
}
func  (this *Exchange) convertTypeToAccount(account interface{}) interface{}  {
    /**
     * @ignore
     * @method
     * Must add accountsByType to this.options to use this method
     * @param {string} account key for account name in this.options['accountsByType']
     * @returns the exchange specific account name or the isolated margin id for transfers
     */
    accountsByType := this.safeDict(this.options, "accountsByType", map[string]interface{} {})
    lowercaseAccount := ToLower(account)
    if IsTrue(InOp(accountsByType, lowercaseAccount)) {
        return GetValue(accountsByType, lowercaseAccount)
    } else if IsTrue(IsTrue((InOp(this.markets, account))) || IsTrue((InOp(this.markets_by_id, account)))) {
        market := this.market(account)
        return GetValue(market, "id")
    } else {
        return account
    }
}
func  (this *Exchange) checkRequiredArgument(methodName string, argument interface{}, argumentName interface{}, optionalArgs ...interface{})  {
    /**
    * @ignore
    * @method
    * @param {string} methodName the name of the method that the argument is being checked for
    * @param {string} argument the argument's actual value provided
    * @param {string} argumentName the name of the argument being checked (for logging purposes)
    * @param {string[]} options a list of options that the argument can be
    * @returns {undefined}
    */
    options := GetArg(optionalArgs, 3, []interface{}{})
    _ = options
    optionsLength := GetArrayLength(options)
    if IsTrue(IsTrue((IsEqual(argument, nil))) || IsTrue((IsTrue((IsGreaterThan(optionsLength, 0))) && IsTrue((!IsTrue((this.inArray(argument, options)))))))) {
        messageOptions := Join(options, ", ")
        message := Add(Add(Add(Add(Add(this.id, " "), methodName), "() requires a "), argumentName), " argument")
        if IsTrue(!IsEqual(messageOptions, "")) {
            message = Add(message, Add(Add(Add(", one of ", "("), messageOptions), ")"))
        }
        panic(ArgumentsRequired(message))
    }
}
func  (this *Exchange) checkRequiredMarginArgument(methodName string, symbol interface{}, marginMode string)  {
    /**
     * @ignore
     * @method
     * @param {string} symbol unified symbol of the market
     * @param {string} methodName name of the method that requires a symbol
     * @param {string} marginMode is either 'isolated' or 'cross'
     */
    if IsTrue(IsTrue((IsEqual(marginMode, "isolated"))) && IsTrue((IsEqual(symbol, nil)))) {
        panic(ArgumentsRequired(Add(Add(Add(this.id, " "), methodName), "() requires a symbol argument for isolated margin")))
    } else if IsTrue(IsTrue((IsEqual(marginMode, "cross"))) && IsTrue((!IsEqual(symbol, nil)))) {
        panic(ArgumentsRequired(Add(Add(Add(this.id, " "), methodName), "() cannot have a symbol argument for cross margin")))
    }
}
func  (this *Exchange) parseDepositWithdrawFees(response interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @param {object[]|object} response unparsed response from the exchange
    * @param {string[]|undefined} codes the unified currency codes to fetch transactions fees for, returns all currencies when undefined
    * @param {str} currencyIdKey *should only be undefined when response is a dictionary* the object key that corresponds to the currency id
    * @returns {object} objects with withdraw and deposit fees, indexed by currency codes
    */
    codes := GetArg(optionalArgs, 1, nil)
    _ = codes
    currencyIdKey := GetArg(optionalArgs, 2, nil)
    _ = currencyIdKey
    depositWithdrawFees := map[string]interface{} {}
    isArray := IsArray(response)
    responseKeys := response
    if !IsTrue(isArray) {
        responseKeys = ObjectKeys(response)
    }
    for i := 0; IsLessThan(i, GetArrayLength(responseKeys)); i++ {
        entry := GetValue(responseKeys, i)
        dictionary := Ternary(IsTrue(isArray), entry, GetValue(response, entry))
        currencyId := Ternary(IsTrue(isArray), this.safeString(dictionary, currencyIdKey), entry)
        currency := this.safeCurrency(currencyId)
        code := this.safeString(currency, "code")
        if IsTrue(IsTrue((IsEqual(codes, nil))) || IsTrue((this.inArray(code, codes)))) {
            AddElementToObject(depositWithdrawFees, code, this.parseDepositWithdrawFee(dictionary, currency))
        }
    }
    return depositWithdrawFees
}
func  (this *Exchange) parseDepositWithdrawFee(fee interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 1, nil)
    _ = currency
    panic(NotSupported(Add(this.id, " parseDepositWithdrawFee() is not supported yet")))
}
func  (this *Exchange) depositWithdrawFee(info interface{}) interface{}  {
    return map[string]interface{} {
        "info": info,
        "withdraw": map[string]interface{} {
            "fee": nil,
            "percentage": nil,
        },
        "deposit": map[string]interface{} {
            "fee": nil,
            "percentage": nil,
        },
        "networks": map[string]interface{} {},
    }
}
func  (this *Exchange) assignDefaultDepositWithdrawFees(fee interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description Takes a depositWithdrawFee structure and assigns the default values for withdraw and deposit
    * @param {object} fee A deposit withdraw fee structure
    * @param {object} currency A currency structure, the response from this.currency ()
    * @returns {object} A deposit withdraw fee structure
    */
    currency := GetArg(optionalArgs, 1, nil)
    _ = currency
    networkKeys := ObjectKeys(GetValue(fee, "networks"))
    numNetworks := GetArrayLength(networkKeys)
    if IsTrue(IsEqual(numNetworks, 1)) {
        AddElementToObject(fee, "withdraw", GetValue(GetValue(GetValue(fee, "networks"), GetValue(networkKeys, 0)), "withdraw"))
        AddElementToObject(fee, "deposit", GetValue(GetValue(GetValue(fee, "networks"), GetValue(networkKeys, 0)), "deposit"))
        return fee
    }
    currencyCode := this.safeString(currency, "code")
    for i := 0; IsLessThan(i, numNetworks); i++ {
        network := GetValue(networkKeys, i)
        if IsTrue(IsEqual(network, currencyCode)) {
            AddElementToObject(fee, "withdraw", GetValue(GetValue(GetValue(fee, "networks"), GetValue(networkKeys, i)), "withdraw"))
            AddElementToObject(fee, "deposit", GetValue(GetValue(GetValue(fee, "networks"), GetValue(networkKeys, i)), "deposit"))
        }
    }
    return fee
}
func  (this *Exchange) parseIncome(info interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseIncome () is not supported yet")))
}
func  (this *Exchange) parseIncomes(incomes interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description parses funding fee info from exchange response
    * @param {object[]} incomes each item describes once instance of currency being received or paid
    * @param {object} market ccxt market
    * @param {int} [since] when defined, the response items are filtered to only include items after this timestamp
    * @param {int} [limit] limits the number of items in the response
    * @returns {object[]} an array of [funding history structures]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
    */
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(incomes)); i++ {
        entry := GetValue(incomes, i)
        parsed := this.parseIncome(entry, market)
        result = AppendToArray(result,parsed).([]interface{})
    }
    sorted := this.sortBy(result, "timestamp")
    return this.filterBySinceLimit(sorted, since, limit)
}
func  (this *Exchange) getMarketFromSymbols(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    if IsTrue(IsEqual(symbols, nil)) {
        return nil
    }
    firstMarket := this.safeString(symbols, 0)
    market := this.market(firstMarket)
    return market
}
func  (this *Exchange) parseWsOHLCVs(ohlcvs interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    timeframe := GetArg(optionalArgs, 2, "1m")
    _ = timeframe
    since := GetArg(optionalArgs, 3, nil)
    _ = since
    limit := GetArg(optionalArgs, 4, nil)
    _ = limit
    results := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(ohlcvs)); i++ {
        results = AppendToArray(results,this.parseWsOHLCV(GetValue(ohlcvs, i), market)).([]interface{})
    }
    return results
}
func  (this *Exchange) fetchTransactions(optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name exchange#fetchTransactions
    * @deprecated
    * @description *DEPRECATED* use fetchDepositsWithdrawals instead
    * @param {string} code unified currency code for the currency of the deposit/withdrawals, default is undefined
    * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
    * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
    */
    code := GetArg(optionalArgs, 0, nil)
    _ = code
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchDepositsWithdrawals")) {
        return this.fetchDepositsWithdrawals(code, since, limit, params)
    } else {
        panic(NotSupported(Add(this.id, " fetchTransactions () is not supported yet")))
    }
}
func  (this *Exchange) filterByArrayPositions(objects interface{}, key interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description Typed wrapper for filterByArray that returns a list of positions
    */
    values := GetArg(optionalArgs, 2, nil)
    _ = values
    indexed := GetArg(optionalArgs, 3, true)
    _ = indexed
    return this.filterByArray(objects, key, values, indexed)
}
func  (this *Exchange) filterByArrayTickers(objects interface{}, key interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description Typed wrapper for filterByArray that returns a dictionary of tickers
    */
    values := GetArg(optionalArgs, 2, nil)
    _ = values
    indexed := GetArg(optionalArgs, 3, true)
    _ = indexed
    return this.filterByArray(objects, key, values, indexed)
}
func  (this *Exchange) createOHLCVObject(symbol string, timeframe string, data interface{}) interface{}  {
    res := map[string]interface{} {}
    AddElementToObject(res, symbol, map[string]interface{} {})
    AddElementToObject(GetValue(res, symbol), timeframe, data)
    return res
}
func  (this *Exchange) handleMaxEntriesPerRequestAndParams(method string, optionalArgs ...interface{}) interface{}  {
    maxEntriesPerRequest := GetArg(optionalArgs, 1, nil)
    _ = maxEntriesPerRequest
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    var newMaxEntriesPerRequest interface{} = nil
    newMaxEntriesPerRequestparamsVariable := this.handleOptionAndParams(params, method, "maxEntriesPerRequest");
    newMaxEntriesPerRequest = GetValue(newMaxEntriesPerRequestparamsVariable,0);
    params = GetValue(newMaxEntriesPerRequestparamsVariable,1)
    if IsTrue(IsTrue((!IsEqual(newMaxEntriesPerRequest, nil))) && IsTrue((!IsEqual(newMaxEntriesPerRequest, maxEntriesPerRequest)))) {
        maxEntriesPerRequest = newMaxEntriesPerRequest
    }
    if IsTrue(IsEqual(maxEntriesPerRequest, nil)) {
        maxEntriesPerRequest = 1000 // default to 1000
    }
    return []interface{}{maxEntriesPerRequest, params}
}
func  (this *Exchange) fetchPaginatedCallDynamic(method string, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    maxEntriesPerRequest := GetArg(optionalArgs, 5, nil)
    _ = maxEntriesPerRequest
    var maxCalls interface{} = nil
    maxCallsparamsVariable := this.handleOptionAndParams(params, method, "paginationCalls", 10);
    maxCalls = GetValue(maxCallsparamsVariable,0);
    params = GetValue(maxCallsparamsVariable,1)
    var maxRetries interface{} = nil
    maxRetriesparamsVariable := this.handleOptionAndParams(params, method, "maxRetries", 3);
    maxRetries = GetValue(maxRetriesparamsVariable,0);
    params = GetValue(maxRetriesparamsVariable,1)
    var paginationDirection interface{} = nil
    paginationDirectionparamsVariable := this.handleOptionAndParams(params, method, "paginationDirection", "backward");
    paginationDirection = GetValue(paginationDirectionparamsVariable,0);
    params = GetValue(paginationDirectionparamsVariable,1)
    var paginationTimestamp interface{} = nil
    calls := 0
    result := []interface{}{}
    errors := 0
    until := this.safeInteger2(params, "untill", "till") // do not omit it from params here
    maxEntriesPerRequestparamsVariable := this.handleMaxEntriesPerRequestAndParams(method, maxEntriesPerRequest, params);
    maxEntriesPerRequest = GetValue(maxEntriesPerRequestparamsVariable,0);
    params = GetValue(maxEntriesPerRequestparamsVariable,1)
    if IsTrue((IsEqual(paginationDirection, "forward"))) {
        if IsTrue(IsEqual(since, nil)) {
            panic(ArgumentsRequired(Add(this.id, " pagination requires a since argument when paginationDirection set to forward")))
        }
        paginationTimestamp = since
    }
    for (IsLessThan(calls, maxCalls)) {
        calls = Add(calls, 1)
        
        {		ret__ := func(this *Exchange) (ret_ interface{}) {
        		defer func() {
        			if e := recover().(interface{}); e != nil {
        				ret_ = func(this *Exchange) interface{} {
        					// catch block:
                                        errors = Add(errors, 1)
                    if IsTrue(IsGreaterThan(errors, maxRetries)) {
                        panic(e)
                    }
        					return nil
        				}(this)
        			}
        		}()
        		// try block:
                            if IsTrue(IsEqual(paginationDirection, "backward")) {
                        // do it backwards, starting from the last
                        // UNTIL filtering is required in order to work
                        if IsTrue(!IsEqual(paginationTimestamp, nil)) {
                            AddElementToObject(params, "until", Subtract(paginationTimestamp, 1))
                        }
                        response := callDynamically(method, symbol, nil, maxEntriesPerRequest, params)
                        responseLength := GetArrayLength(response)
                        if IsTrue(this.verbose) {
                            backwardMessage := Add(Add(Add(Add(Add("Dynamic pagination call ", this.numberToString(calls)), " method "), method), " response length "), this.numberToString(responseLength))
                            if IsTrue(!IsEqual(paginationTimestamp, nil)) {
                                backwardMessage = Add(backwardMessage, Add(" timestamp ", this.numberToString(paginationTimestamp)))
                            }
                            this.log(backwardMessage)
                        }
                        if IsTrue(IsEqual(responseLength, 0)) {
                            break
                        }
                        errors = 0
                        result = this.arrayConcat(result, response)
                        firstElement := this.safeValue(response, 0)
                        paginationTimestamp = this.safeInteger2(firstElement, "timestamp", 0)
                        if IsTrue(IsTrue((!IsEqual(since, nil))) && IsTrue((IsLessThanOrEqual(paginationTimestamp, since)))) {
                            break
                        }
                    } else {
                        // do it forwards, starting from the since
                        response := callDynamically(method, symbol, paginationTimestamp, maxEntriesPerRequest, params)
                        responseLength := GetArrayLength(response)
                        if IsTrue(this.verbose) {
                            forwardMessage := Add(Add(Add(Add(Add("Dynamic pagination call ", this.numberToString(calls)), " method "), method), " response length "), this.numberToString(responseLength))
                            if IsTrue(!IsEqual(paginationTimestamp, nil)) {
                                forwardMessage = Add(forwardMessage, Add(" timestamp ", this.numberToString(paginationTimestamp)))
                            }
                            this.log(forwardMessage)
                        }
                        if IsTrue(IsEqual(responseLength, 0)) {
                            break
                        }
                        errors = 0
                        result = this.arrayConcat(result, response)
                        last := this.safeValue(response, Subtract(responseLength, 1))
                        paginationTimestamp = Subtract(this.safeInteger(last, "timestamp"), 1)
                        if IsTrue(IsTrue((!IsEqual(until, nil))) && IsTrue((IsGreaterThanOrEqual(paginationTimestamp, until)))) {
                            break
                        }
                    }
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
    }
    uniqueResults := this.removeRepeatedElementsFromArray(result)
    key := Ternary(IsTrue((IsEqual(method, "fetchOHLCV"))), 0, "timestamp")
    return this.filterBySinceLimit(uniqueResults, since, limit, key)
}
func  (this *Exchange) safeDeterministicCall(method string, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    timeframe := GetArg(optionalArgs, 4, nil)
    _ = timeframe
    params := GetArg(optionalArgs, 5, map[string]interface{} {})
    _ = params
    var maxRetries interface{} = nil
    maxRetriesparamsVariable := this.handleOptionAndParams(params, method, "maxRetries", 3);
    maxRetries = GetValue(maxRetriesparamsVariable,0);
    params = GetValue(maxRetriesparamsVariable,1)
    errors := 0
    for IsLessThanOrEqual(errors, maxRetries) {
        
        {		ret__ := func(this *Exchange) (ret_ interface{}) {
        		defer func() {
        			if e := recover().(interface{}); e != nil {
        				ret_ = func(this *Exchange) interface{} {
        					// catch block:
                                        if IsTrue(IsInstance(e, RateLimitExceeded)) {
                        panic(e)
                    }
                    errors = Add(errors, 1)
                    if IsTrue(IsGreaterThan(errors, maxRetries)) {
                        panic(e)
                    }
        					return nil
        				}(this)
        			}
        		}()
        		// try block:
                            if IsTrue(IsTrue(timeframe) && IsTrue(!IsEqual(method, "fetchFundingRateHistory"))) {
                        return callDynamically(method, symbol, timeframe, since, limit, params)
                    } else {
                        return callDynamically(method, symbol, since, limit, params)
                    }
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
    }
    return []interface{}{}
}
func  (this *Exchange) fetchPaginatedCallDeterministic(method string, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    timeframe := GetArg(optionalArgs, 4, nil)
    _ = timeframe
    params := GetArg(optionalArgs, 5, map[string]interface{} {})
    _ = params
    maxEntriesPerRequest := GetArg(optionalArgs, 6, nil)
    _ = maxEntriesPerRequest
    var maxCalls interface{} = nil
    maxCallsparamsVariable := this.handleOptionAndParams(params, method, "paginationCalls", 10);
    maxCalls = GetValue(maxCallsparamsVariable,0);
    params = GetValue(maxCallsparamsVariable,1)
    maxEntriesPerRequestparamsVariable := this.handleMaxEntriesPerRequestAndParams(method, maxEntriesPerRequest, params);
    maxEntriesPerRequest = GetValue(maxEntriesPerRequestparamsVariable,0);
    params = GetValue(maxEntriesPerRequestparamsVariable,1)
    current := this.milliseconds()
    tasks := []interface{}{}
    time := Multiply(this.parseTimeframe(timeframe), 1000)
    step := Multiply(time, maxEntriesPerRequest)
    currentSince := Subtract(Subtract(current, (Multiply(maxCalls, step))), 1)
    if IsTrue(!IsEqual(since, nil)) {
        currentSince = mathMax(currentSince, since)
    } else {
        currentSince = mathMax(currentSince, 1241440531000) // avoid timestamps older than 2009
    }
    until := this.safeInteger2(params, "until", "till") // do not omit it here
    if IsTrue(!IsEqual(until, nil)) {
        requiredCalls := MathCeil(Divide((Subtract(until, since)), step))
        if IsTrue(IsGreaterThan(requiredCalls, maxCalls)) {
            panic(BadRequest(Add(Add(Add(Add(this.id, " the number of required calls is greater than the max number of calls allowed, either increase the paginationCalls or decrease the since-until gap. Current paginationCalls limit is "), ToString(maxCalls)), " required calls is "), ToString(requiredCalls))))
        }
    }
    for i := 0; IsLessThan(i, maxCalls); i++ {
        if IsTrue(IsTrue((!IsEqual(until, nil))) && IsTrue((IsGreaterThanOrEqual(currentSince, until)))) {
            break
        }
        if IsTrue(IsGreaterThanOrEqual(currentSince, current)) {
            break
        }
        tasks = AppendToArray(tasks,this.safeDeterministicCall(method, symbol, currentSince, maxEntriesPerRequest, timeframe, params)).([]interface{})
        currentSince = Subtract(this.sum(currentSince, step), 1)
    }
    results := promiseAll(tasks)
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(results)); i++ {
        result = this.arrayConcat(result, GetValue(results, i))
    }
    uniqueResults := this.removeRepeatedElementsFromArray(result)
    key := Ternary(IsTrue((IsEqual(method, "fetchOHLCV"))), 0, "timestamp")
    return this.filterBySinceLimit(uniqueResults, since, limit, key)
}
func  (this *Exchange) fetchPaginatedCallCursor(method string, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    cursorReceived := GetArg(optionalArgs, 5, nil)
    _ = cursorReceived
    cursorSent := GetArg(optionalArgs, 6, nil)
    _ = cursorSent
    cursorIncrement := GetArg(optionalArgs, 7, nil)
    _ = cursorIncrement
    maxEntriesPerRequest := GetArg(optionalArgs, 8, nil)
    _ = maxEntriesPerRequest
    var maxCalls interface{} = nil
    maxCallsparamsVariable := this.handleOptionAndParams(params, method, "paginationCalls", 10);
    maxCalls = GetValue(maxCallsparamsVariable,0);
    params = GetValue(maxCallsparamsVariable,1)
    var maxRetries interface{} = nil
    maxRetriesparamsVariable := this.handleOptionAndParams(params, method, "maxRetries", 3);
    maxRetries = GetValue(maxRetriesparamsVariable,0);
    params = GetValue(maxRetriesparamsVariable,1)
    maxEntriesPerRequestparamsVariable := this.handleMaxEntriesPerRequestAndParams(method, maxEntriesPerRequest, params);
    maxEntriesPerRequest = GetValue(maxEntriesPerRequestparamsVariable,0);
    params = GetValue(maxEntriesPerRequestparamsVariable,1)
    var cursorValue interface{} = nil
    i := 0
    errors := 0
    result := []interface{}{}
    for IsLessThan(i, maxCalls) {
        
        {		ret__ := func(this *Exchange) (ret_ interface{}) {
        		defer func() {
        			if e := recover().(interface{}); e != nil {
        				ret_ = func(this *Exchange) interface{} {
        					// catch block:
                                        errors = Add(errors, 1)
                    if IsTrue(IsGreaterThan(errors, maxRetries)) {
                        panic(e)
                    }
        					return nil
        				}(this)
        			}
        		}()
        		// try block:
                            if IsTrue(!IsEqual(cursorValue, nil)) {
                        if IsTrue(!IsEqual(cursorIncrement, nil)) {
                            cursorValue = Add(this.parseToInt(cursorValue), cursorIncrement)
                        }
                        AddElementToObject(params, cursorSent, cursorValue)
                    }
                    var response interface{} = nil
                    if IsTrue(IsEqual(method, "fetchAccounts")) {
                        response = callDynamically(method, params)
                    } else if IsTrue(IsEqual(method, "getLeverageTiersPaginated")) {
                        response = callDynamically(method, symbol, params)
                    } else {
                        response = callDynamically(method, symbol, since, maxEntriesPerRequest, params)
                    }
                    errors = 0
                    responseLength := GetArrayLength(response)
                    if IsTrue(this.verbose) {
                        cursorString := Ternary(IsTrue((IsEqual(cursorValue, nil))), "", cursorValue)
                        iteration := (Add(i, 1))
                        cursorMessage := Add(Add(Add(Add(Add(Add(Add("Cursor pagination call ", ToString(iteration)), " method "), method), " response length "), ToString(responseLength)), " cursor "), cursorString)
                        this.log(cursorMessage)
                    }
                    if IsTrue(IsEqual(responseLength, 0)) {
                        break
                    }
                    result = this.arrayConcat(result, response)
                    last := this.safeValue(response, Subtract(responseLength, 1))
                    cursorValue = this.safeValue(GetValue(last, "info"), cursorReceived)
                    if IsTrue(IsEqual(cursorValue, nil)) {
                        break
                    }
                    lastTimestamp := this.safeInteger(last, "timestamp")
                    if IsTrue(IsTrue(!IsEqual(lastTimestamp, nil)) && IsTrue(IsLessThan(lastTimestamp, since))) {
                        break
                    }
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        i = Add(i, 1)
    }
    sorted := this.sortCursorPaginatedResult(result)
    key := Ternary(IsTrue((IsEqual(method, "fetchOHLCV"))), 0, "timestamp")
    return this.filterBySinceLimit(sorted, since, limit, key)
}
func  (this *Exchange) fetchPaginatedCallIncremental(method string, optionalArgs ...interface{}) interface{}  {
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    pageKey := GetArg(optionalArgs, 5, nil)
    _ = pageKey
    maxEntriesPerRequest := GetArg(optionalArgs, 6, nil)
    _ = maxEntriesPerRequest
    var maxCalls interface{} = nil
    maxCallsparamsVariable := this.handleOptionAndParams(params, method, "paginationCalls", 10);
    maxCalls = GetValue(maxCallsparamsVariable,0);
    params = GetValue(maxCallsparamsVariable,1)
    var maxRetries interface{} = nil
    maxRetriesparamsVariable := this.handleOptionAndParams(params, method, "maxRetries", 3);
    maxRetries = GetValue(maxRetriesparamsVariable,0);
    params = GetValue(maxRetriesparamsVariable,1)
    maxEntriesPerRequestparamsVariable := this.handleMaxEntriesPerRequestAndParams(method, maxEntriesPerRequest, params);
    maxEntriesPerRequest = GetValue(maxEntriesPerRequestparamsVariable,0);
    params = GetValue(maxEntriesPerRequestparamsVariable,1)
    i := 0
    errors := 0
    result := []interface{}{}
    for IsLessThan(i, maxCalls) {
        
        {		ret__ := func(this *Exchange) (ret_ interface{}) {
        		defer func() {
        			if e := recover().(interface{}); e != nil {
        				ret_ = func(this *Exchange) interface{} {
        					// catch block:
                                        errors = Add(errors, 1)
                    if IsTrue(IsGreaterThan(errors, maxRetries)) {
                        panic(e)
                    }
        					return nil
        				}(this)
        			}
        		}()
        		// try block:
                            AddElementToObject(params, pageKey, Add(i, 1))
                    response := callDynamically(method, symbol, since, maxEntriesPerRequest, params)
                    errors = 0
                    responseLength := GetArrayLength(response)
                    if IsTrue(this.verbose) {
                        iteration := ToString((Add(i, 1)))
                        incrementalMessage := Add(Add(Add(Add(Add("Incremental pagination call ", iteration), " method "), method), " response length "), ToString(responseLength))
                        this.log(incrementalMessage)
                    }
                    if IsTrue(IsEqual(responseLength, 0)) {
                        break
                    }
                    result = this.arrayConcat(result, response)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        i = Add(i, 1)
    }
    sorted := this.sortCursorPaginatedResult(result)
    key := Ternary(IsTrue((IsEqual(method, "fetchOHLCV"))), 0, "timestamp")
    return this.filterBySinceLimit(sorted, since, limit, key)
}
func  (this *Exchange) sortCursorPaginatedResult(result interface{}) interface{}  {
    first := this.safeValue(result, 0)
    if IsTrue(!IsEqual(first, nil)) {
        if IsTrue(InOp(first, "timestamp")) {
            return this.sortBy(result, "timestamp", true)
        }
        if IsTrue(InOp(first, "id")) {
            return this.sortBy(result, "id", true)
        }
    }
    return result
}
func  (this *Exchange) removeRepeatedElementsFromArray(input interface{}) interface{}  {
    uniqueResult := map[string]interface{} {}
    for i := 0; IsLessThan(i, GetArrayLength(input)); i++ {
        entry := GetValue(input, i)
        id := this.safeString(entry, "id")
        if IsTrue(!IsEqual(id, nil)) {
            if IsTrue(IsEqual(this.safeString(uniqueResult, id), nil)) {
                AddElementToObject(uniqueResult, id, entry)
            }
        } else {
            timestamp := this.safeInteger2(entry, "timestamp", 0)
            if IsTrue(!IsEqual(timestamp, nil)) {
                if IsTrue(IsEqual(this.safeString(uniqueResult, timestamp), nil)) {
                    AddElementToObject(uniqueResult, timestamp, entry)
                }
            }
        }
    }
    values := ObjectValues(uniqueResult)
    valuesLength := GetArrayLength(values)
    if IsTrue(IsGreaterThan(valuesLength, 0)) {
        return values
    }
    return input
}
func  (this *Exchange) handleUntilOption(key string, request interface{}, params interface{}, optionalArgs ...interface{}) interface{}  {
    multiplier := GetArg(optionalArgs, 3, 1)
    _ = multiplier
    until := this.safeInteger2(params, "until", "till")
    if IsTrue(!IsEqual(until, nil)) {
        AddElementToObject(request, key, this.parseToInt(Multiply(until, multiplier)))
        params = this.omit(params, []interface{}{"until", "till"})
    }
    return []interface{}{request, params}
}
func  (this *Exchange) safeOpenInterest(interest interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    return this.extend(interest, map[string]interface{} {
        "symbol": this.safeString(market, "symbol"),
        "baseVolume": this.safeNumber(interest, "baseVolume"),
        "quoteVolume": this.safeNumber(interest, "quoteVolume"),
        "openInterestAmount": this.safeNumber(interest, "openInterestAmount"),
        "openInterestValue": this.safeNumber(interest, "openInterestValue"),
        "timestamp": this.safeInteger(interest, "timestamp"),
        "datetime": this.safeString(interest, "datetime"),
        "info": this.safeValue(interest, "info"),
    })
}
func  (this *Exchange) parseLiquidation(liquidation interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseLiquidation () is not supported yet")))
}
func  (this *Exchange) parseLiquidations(liquidations interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description parses liquidation info from the exchange response
    * @param {object[]} liquidations each item describes an instance of a liquidation event
    * @param {object} market ccxt market
    * @param {int} [since] when defined, the response items are filtered to only include items after this timestamp
    * @param {int} [limit] limits the number of items in the response
    * @returns {object[]} an array of [liquidation structures]{@link https://docs.ccxt.com/#/?id=liquidation-structure}
    */
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    result := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(liquidations)); i++ {
        entry := GetValue(liquidations, i)
        parsed := this.parseLiquidation(entry, market)
        result = AppendToArray(result,parsed).([]interface{})
    }
    sorted := this.sortBy(result, "timestamp")
    symbol := this.safeString(market, "symbol")
    return this.filterBySymbolSinceLimit(sorted, symbol, since, limit)
}
func  (this *Exchange) parseGreeks(greeks interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseGreeks () is not supported yet")))
}
func  (this *Exchange) parseOption(chain interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 1, nil)
    _ = currency
    market := GetArg(optionalArgs, 2, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseOption () is not supported yet")))
}
func  (this *Exchange) parseOptionChain(response interface{}, optionalArgs ...interface{}) interface{}  {
    currencyKey := GetArg(optionalArgs, 1, nil)
    _ = currencyKey
    symbolKey := GetArg(optionalArgs, 2, nil)
    _ = symbolKey
    optionStructures := map[string]interface{} {}
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        info := GetValue(response, i)
        currencyId := this.safeString(info, currencyKey)
        currency := this.safeCurrency(currencyId)
        marketId := this.safeString(info, symbolKey)
        market := this.safeMarket(marketId, nil, nil, "option")
        AddElementToObject(optionStructures, GetValue(market, "symbol"), this.parseOption(info, currency, market))
    }
    return optionStructures
}
func  (this *Exchange) parseMarginModes(response interface{}, optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 1, nil)
    _ = symbols
    symbolKey := GetArg(optionalArgs, 2, nil)
    _ = symbolKey
    marketType := GetArg(optionalArgs, 3, nil)
    _ = marketType
    marginModeStructures := map[string]interface{} {}
    if IsTrue(IsEqual(marketType, nil)) {
        marketType = "swap" // default to swap
    }
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        info := GetValue(response, i)
        marketId := this.safeString(info, symbolKey)
        market := this.safeMarket(marketId, nil, nil, marketType)
        if IsTrue(IsTrue((IsEqual(symbols, nil))) || IsTrue(this.inArray(GetValue(market, "symbol"), symbols))) {
            AddElementToObject(marginModeStructures, GetValue(market, "symbol"), this.parseMarginMode(info, market))
        }
    }
    return marginModeStructures
}
func  (this *Exchange) parseMarginMode(marginMode interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseMarginMode () is not supported yet")))
}
func  (this *Exchange) parseLeverages(response interface{}, optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 1, nil)
    _ = symbols
    symbolKey := GetArg(optionalArgs, 2, nil)
    _ = symbolKey
    marketType := GetArg(optionalArgs, 3, nil)
    _ = marketType
    leverageStructures := map[string]interface{} {}
    if IsTrue(IsEqual(marketType, nil)) {
        marketType = "swap" // default to swap
    }
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        info := GetValue(response, i)
        marketId := this.safeString(info, symbolKey)
        market := this.safeMarket(marketId, nil, nil, marketType)
        if IsTrue(IsTrue((IsEqual(symbols, nil))) || IsTrue(this.inArray(GetValue(market, "symbol"), symbols))) {
            AddElementToObject(leverageStructures, GetValue(market, "symbol"), this.parseLeverage(info, market))
        }
    }
    return leverageStructures
}
func  (this *Exchange) parseLeverage(leverage interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseLeverage () is not supported yet")))
}
func  (this *Exchange) parseConversions(conversions interface{}, optionalArgs ...interface{}) interface{}  {
    code := GetArg(optionalArgs, 1, nil)
    _ = code
    fromCurrencyKey := GetArg(optionalArgs, 2, nil)
    _ = fromCurrencyKey
    toCurrencyKey := GetArg(optionalArgs, 3, nil)
    _ = toCurrencyKey
    since := GetArg(optionalArgs, 4, nil)
    _ = since
    limit := GetArg(optionalArgs, 5, nil)
    _ = limit
    params := GetArg(optionalArgs, 6, map[string]interface{} {})
    _ = params
    conversions = this.toArray(conversions)
    result := []interface{}{}
    var fromCurrency interface{} = nil
    var toCurrency interface{} = nil
    for i := 0; IsLessThan(i, GetArrayLength(conversions)); i++ {
        entry := GetValue(conversions, i)
        fromId := this.safeString(entry, fromCurrencyKey)
        toId := this.safeString(entry, toCurrencyKey)
        if IsTrue(!IsEqual(fromId, nil)) {
            fromCurrency = this.safeCurrency(fromId)
        }
        if IsTrue(!IsEqual(toId, nil)) {
            toCurrency = this.safeCurrency(toId)
        }
        conversion := this.extend(this.parseConversion(entry, fromCurrency, toCurrency), params)
        result = AppendToArray(result,conversion).([]interface{})
    }
    sorted := this.sortBy(result, "timestamp")
    var currency interface{} = nil
    if IsTrue(!IsEqual(code, nil)) {
        currency = this.safeCurrency(code)
        code = GetValue(currency, "code")
    }
    if IsTrue(IsEqual(code, nil)) {
        return this.filterBySinceLimit(sorted, since, limit)
    }
    fromConversion := this.filterBy(sorted, "fromCurrency", code)
    toConversion := this.filterBy(sorted, "toCurrency", code)
    both := this.arrayConcat(fromConversion, toConversion)
    return this.filterBySinceLimit(both, since, limit)
}
func  (this *Exchange) parseConversion(conversion interface{}, optionalArgs ...interface{}) interface{}  {
    fromCurrency := GetArg(optionalArgs, 1, nil)
    _ = fromCurrency
    toCurrency := GetArg(optionalArgs, 2, nil)
    _ = toCurrency
    panic(NotSupported(Add(this.id, " parseConversion () is not supported yet")))
}
func  (this *Exchange) convertExpireDate(date string) interface{}  {
    // parse YYMMDD to datetime string
    year := Slice(date, 0, 2)
    month := Slice(date, 2, 4)
    day := Slice(date, 4, 6)
    reconstructedDate := Add(Add(Add(Add(Add(Add("20", year), "-"), month), "-"), day), "T00:00:00Z")
    return reconstructedDate
}
func  (this *Exchange) convertExpireDateToMarketIdDate(date string) interface{}  {
    // parse 240119 to 19JAN24
    year := Slice(date, 0, 2)
    monthRaw := Slice(date, 2, 4)
    var month interface{} = nil
    day := Slice(date, 4, 6)
    if IsTrue(IsEqual(monthRaw, "01")) {
        month = "JAN"
    } else if IsTrue(IsEqual(monthRaw, "02")) {
        month = "FEB"
    } else if IsTrue(IsEqual(monthRaw, "03")) {
        month = "MAR"
    } else if IsTrue(IsEqual(monthRaw, "04")) {
        month = "APR"
    } else if IsTrue(IsEqual(monthRaw, "05")) {
        month = "MAY"
    } else if IsTrue(IsEqual(monthRaw, "06")) {
        month = "JUN"
    } else if IsTrue(IsEqual(monthRaw, "07")) {
        month = "JUL"
    } else if IsTrue(IsEqual(monthRaw, "08")) {
        month = "AUG"
    } else if IsTrue(IsEqual(monthRaw, "09")) {
        month = "SEP"
    } else if IsTrue(IsEqual(monthRaw, "10")) {
        month = "OCT"
    } else if IsTrue(IsEqual(monthRaw, "11")) {
        month = "NOV"
    } else if IsTrue(IsEqual(monthRaw, "12")) {
        month = "DEC"
    }
    reconstructedDate := Add(Add(day, month), year)
    return reconstructedDate
}
func  (this *Exchange) convertMarketIdExpireDate(date string) interface{}  {
    // parse 03JAN24 to 240103
    monthMappping := map[string]interface{} {
        "JAN": "01",
        "FEB": "02",
        "MAR": "03",
        "APR": "04",
        "MAY": "05",
        "JUN": "06",
        "JUL": "07",
        "AUG": "08",
        "SEP": "09",
        "OCT": "10",
        "NOV": "11",
        "DEC": "12",
    }
    // if exchange omits first zero and provides i.e. '3JAN24' instead of '03JAN24'
    if IsTrue(IsEqual(GetLength(date), 6)) {
        date = Add("0", date)
    }
    year := Slice(date, 0, 2)
    monthName := Slice(date, 2, 5)
    month := this.safeString(monthMappping, monthName)
    day := Slice(date, 5, 7)
    reconstructedDate := Add(Add(day, month), year)
    return reconstructedDate
}
func  (this *Exchange) fetchPositionHistory(symbol string, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name exchange#fetchPositionHistory
    * @description fetches the history of margin added or reduced from contract isolated positions
    * @param {string} [symbol] unified market symbol
    * @param {int} [since] timestamp in ms of the position
    * @param {int} [limit] the maximum amount of candles to fetch, default=1000
    * @param {object} params extra parameters specific to the exchange api endpoint
    * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
    */
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    if IsTrue(GetValue(this.has, "fetchPositionsHistory")) {
        positions := this.fetchPositionsHistory([]interface{}{symbol}, since, limit, params)
        return this.safeDict(positions, 0)
    } else {
        panic(NotSupported(Add(this.id, " fetchPositionHistory () is not supported yet")))
    }
}
func  (this *Exchange) fetchPositionsHistory(optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchPositionsHistory () is not supported yet")))
}
func  (this *Exchange) parseMarginModification(data interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    panic(NotSupported(Add(this.id, " parseMarginModification() is not supported yet")))
}
func  (this *Exchange) parseMarginModifications(response interface{}, optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 1, nil)
    _ = symbols
    symbolKey := GetArg(optionalArgs, 2, nil)
    _ = symbolKey
    marketType := GetArg(optionalArgs, 3, nil)
    _ = marketType
    marginModifications := []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        info := GetValue(response, i)
        marketId := this.safeString(info, symbolKey)
        market := this.safeMarket(marketId, nil, nil, marketType)
        if IsTrue(IsTrue((IsEqual(symbols, nil))) || IsTrue(this.inArray(GetValue(market, "symbol"), symbols))) {
            marginModifications = AppendToArray(marginModifications,this.parseMarginModification(info, market)).([]interface{})
        }
    }
    return marginModifications
}
func  (this *Exchange) fetchTransfer(id string, optionalArgs ...interface{}) interface{}  {
    code := GetArg(optionalArgs, 1, nil)
    _ = code
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchTransfer () is not supported yet")))
}
func  (this *Exchange) fetchTransfers(optionalArgs ...interface{}) interface{}  {
    code := GetArg(optionalArgs, 0, nil)
    _ = code
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    params := GetArg(optionalArgs, 3, map[string]interface{} {})
    _ = params
    panic(NotSupported(Add(this.id, " fetchTransfers () is not supported yet")))
}

